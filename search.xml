<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>算法简介</title>
    <url>/2021/06/30/01.%E7%AE%97%E6%B3%95%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<p><a href="https://imgtu.com/i/RUGLZ9"><img src="https://z3.ax1x.com/2021/06/28/RUGLZ9.png" alt="RUGLZ9.png"></a></p>
<p><a href="https://imgtu.com/i/RUGOaR"><img src="https://z3.ax1x.com/2021/06/28/RUGOaR.png" alt="RUGOaR.png"></a></p>
]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>01.算法简介</category>
      </categories>
      <tags>
        <tag>算法与数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构与算法的关系</title>
    <url>/2021/06/30/02.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%9A%84%E5%85%B3%E7%B3%BB/</url>
    <content><![CDATA[<p><a href="https://imgtu.com/i/RUJJJ0"><img src="https://z3.ax1x.com/2021/06/28/RUJJJ0.png" alt="RUJJJ0.png"></a></p>
<p><a href="https://imgtu.com/i/RUJYWV"><img src="https://z3.ax1x.com/2021/06/28/RUJYWV.png" alt="RUJYWV.png"></a></p>
]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>02.数据结构与算法的关系</category>
      </categories>
      <tags>
        <tag>算法与数据结构</tag>
        <tag>线性结构与非线性结构</tag>
      </tags>
  </entry>
  <entry>
    <title>稀疏数组与队列</title>
    <url>/2021/06/30/03.%E7%A8%80%E7%96%8F%E6%95%B0%E7%BB%84%E5%92%8C%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<h2 id="稀疏数组"><a class="markdownIt-Anchor" href="#稀疏数组">#</a> 稀疏数组</h2>
<p><a href="https://imgtu.com/i/RwkEUe"><img src="https://z3.ax1x.com/2021/06/29/RwkEUe.png" alt="RwkEUe.png"></a></p>
<p><a href="https://imgtu.com/i/RwkAED"><img src="https://z3.ax1x.com/2021/06/29/RwkAED.png" alt="RwkAED.png"></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SparceArray</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建一个原始的二维数组</span></span><br><span class="line">        <span class="comment">//0:表示没有旗子，1表示黑子 2表示黑子</span></span><br><span class="line">        <span class="keyword">int</span> chessArr1[][]=<span class="keyword">new</span> <span class="keyword">int</span> [<span class="number">11</span>][<span class="number">11</span>];</span><br><span class="line">        chessArr1[<span class="number">1</span>][<span class="number">2</span>]=<span class="number">1</span>;</span><br><span class="line">        chessArr1[<span class="number">2</span>][<span class="number">3</span>]=<span class="number">2</span>;</span><br><span class="line">        <span class="comment">//输出原始的二维数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] row:chessArr1)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> data:row)&#123;</span><br><span class="line">                System.out.printf(<span class="string">&quot;%d\t&quot;</span>, data);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将二维数组 转稀疏数组 的思想</span></span><br><span class="line">        <span class="comment">//1.先遍历二维数组 得到非0数据的个数</span></span><br><span class="line">        <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">11</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">11</span>;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(chessArr1[i][j]!=<span class="number">0</span>)&#123;</span><br><span class="line">                    sum++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//2.创建对应的稀疏数组</span></span><br><span class="line">        <span class="keyword">int</span> sparseArr[][]=<span class="keyword">new</span> <span class="keyword">int</span> [sum+<span class="number">1</span>][<span class="number">3</span>];</span><br><span class="line">        <span class="comment">//给稀疏数组赋值</span></span><br><span class="line">        sparseArr[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">11</span>;</span><br><span class="line">        sparseArr[<span class="number">0</span>][<span class="number">1</span>]=<span class="number">11</span>;</span><br><span class="line">        sparseArr[<span class="number">0</span>][<span class="number">2</span>]=sum;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历二维数组，将非0的值存放到sparseArr中</span></span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">0</span>;<span class="comment">//count 用于记录是第几个非0数据</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">11</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">11</span>;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(chessArr1[i][j]!=<span class="number">0</span>)&#123;</span><br><span class="line">                    count++;</span><br><span class="line">                    sparseArr[count][<span class="number">0</span>]=i;</span><br><span class="line">                    sparseArr[count][<span class="number">1</span>]=j;</span><br><span class="line">                    sparseArr[count][<span class="number">2</span>]=chessArr1[i][j];</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//输出稀疏数组的形式</span></span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println(<span class="string">&quot;得到的稀疏数组为~~~~~~&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;sparseArr.length;i++)&#123;</span><br><span class="line">            System.out.printf(<span class="string">&quot;%d\t%d\t%d\t\n&quot;</span>,sparseArr[i][<span class="number">0</span>],sparseArr[i][<span class="number">1</span>],sparseArr[i][<span class="number">2</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">        <span class="comment">//将稀疏数组恢复成二维数组</span></span><br><span class="line">        <span class="comment">//1.先读取稀疏数组的第一行</span></span><br><span class="line">        <span class="keyword">int</span> chessArr2[][]=<span class="keyword">new</span> <span class="keyword">int</span> [sparseArr[<span class="number">0</span>][<span class="number">0</span>]][sparseArr[<span class="number">0</span>][<span class="number">1</span>]];</span><br><span class="line">        <span class="comment">//2.读取稀疏数组后几行数据（第二行开始），赋值给二维数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;sparseArr.length;i++)&#123;</span><br><span class="line">            chessArr2[sparseArr[i][<span class="number">0</span>]][sparseArr[i][<span class="number">1</span>]]=sparseArr[i][<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//恢复后的二维数组</span></span><br><span class="line">        System.out.println(<span class="string">&quot;恢复后的二维数组&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] row:chessArr2) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> data:row)&#123;</span><br><span class="line">                System.out.printf(<span class="string">&quot;%d\t&quot;</span>,data);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="队列"><a class="markdownIt-Anchor" href="#队列">#</a> 队列</h2>
<p><strong>介绍</strong></p>
<ol>
<li>
<p>队列是一个有序列表，可以用数组或是链表来实现</p>
</li>
<li>
<p>遵循先入先出的原则</p>
</li>
</ol>
<p><a href="https://imgtu.com/i/RwkPu6"><img src="https://z3.ax1x.com/2021/06/29/RwkPu6.png" alt="RwkPu6.png"></a></p>
<p><a href="https://imgtu.com/i/RwkiDK"><img src="https://z3.ax1x.com/2021/06/29/RwkiDK.png" alt="RwkiDK.png"></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayQueueDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//测试一把</span></span><br><span class="line">        <span class="comment">//创建一个队列</span></span><br><span class="line">        ArrayQueue arrayQueue = <span class="keyword">new</span> ArrayQueue(<span class="number">3</span>);</span><br><span class="line">        <span class="keyword">char</span> key=<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">boolean</span> loop=<span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">//输出一个菜单</span></span><br><span class="line">        <span class="keyword">while</span>(loop)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;s(show):显示队列&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;e(exit):退出程序&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;a(add):添加数据到队列&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;g(get):从队列取出数据&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;h(head):查看队列头数据&quot;</span>);</span><br><span class="line">            key=scanner.next().charAt(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">switch</span> (key)&#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;s&#x27;</span>:<span class="comment">//显示队列</span></span><br><span class="line">                    arrayQueue.showQueue();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;e&#x27;</span>:<span class="comment">//退出程序</span></span><br><span class="line">                    scanner.close();</span><br><span class="line">                    loop=<span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;a&#x27;</span>:<span class="comment">//添加数据到队列</span></span><br><span class="line">                    System.out.println(<span class="string">&quot;请输入一个数&quot;</span>);</span><br><span class="line">                    <span class="keyword">int</span> value = scanner.nextInt();</span><br><span class="line">                    arrayQueue.addQueue(value);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;g&#x27;</span>:<span class="comment">//从队列取出数据</span></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">int</span> queue = arrayQueue.getQueue();</span><br><span class="line">                        System.out.printf(<span class="string">&quot;取出的数据是%d\n&quot;</span>,queue);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        System.out.println(e.getMessage());</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;h&#x27;</span>:<span class="comment">//查看队列头数据</span></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">int</span> i = arrayQueue.headQueue();</span><br><span class="line">                        System.out.printf(<span class="string">&quot;队列头的数据是%d\n&quot;</span>,i);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        System.out.println(e.getMessage());</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    System.out.println(<span class="string">&quot;请输出正确信息&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;程序退出&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用数组模拟队列-编写一个人ArrayQueue类</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArrayQueue</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxSize;<span class="comment">//表示数组的最大容量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> front;<span class="comment">//队列头</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> rear;<span class="comment">//队列尾</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] arr;<span class="comment">//该数组用于存放数据，模拟队列</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建队列的构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayQueue</span><span class="params">(<span class="keyword">int</span> arrMaxSize)</span> </span>&#123;</span><br><span class="line">        maxSize = arrMaxSize;</span><br><span class="line">        arr = <span class="keyword">new</span> <span class="keyword">int</span>[maxSize];</span><br><span class="line">        front = -<span class="number">1</span>;<span class="comment">//指向队列头部，分析出front是指向队列头的前一个位置</span></span><br><span class="line">        rear = -<span class="number">1</span>;<span class="comment">//指向队列尾部，指向队列尾的数据【既就是队列最后一个数据】</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断队列是否满</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFull</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> rear == maxSize - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断队列是否为空</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> rear == front;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加数据到队列</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addQueue</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(isFull())&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;队列满，无法在添加数据&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        rear++;<span class="comment">//rear后移</span></span><br><span class="line">        arr[rear]=n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取队列的数据，出队列</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getQueue</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//判断队列是否空</span></span><br><span class="line">        <span class="keyword">if</span>(isEmpty())&#123;</span><br><span class="line">            <span class="comment">//抛出异常处理</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;队列为空,不能取数据&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        front++;</span><br><span class="line">        <span class="keyword">return</span> arr[front];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//显示队列的所有数据</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showQueue</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//遍历</span></span><br><span class="line">        <span class="keyword">if</span>(isEmpty())&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;队列为空，无数据&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">            System.out.printf(<span class="string">&quot;arr[%d]=%d\n&quot;</span>,i,arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//显示队列的头数据，注意不是取出数据</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">headQueue</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty())&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;队列为空,无数据&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr[front+<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><a href="https://imgtu.com/i/RwkFHO"><img src="https://z3.ax1x.com/2021/06/29/RwkFHO.png" alt="RwkFHO.png"></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CircleArrayQueue</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//测试一把</span></span><br><span class="line">        System.out.println(<span class="string">&quot;测试数组模拟环形队列的案例~~~~~&quot;</span>);</span><br><span class="line">        <span class="comment">//说明：设置4，其队列最大有效数个数为3</span></span><br><span class="line">        CircleArray circleArray = <span class="keyword">new</span> CircleArray(<span class="number">4</span>);</span><br><span class="line">        <span class="keyword">char</span> key = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">boolean</span> loop = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">//输出一个菜单</span></span><br><span class="line">        <span class="keyword">while</span> (loop) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;s(show):显示队列&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;e(exit):退出程序&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;a(add):添加数据到队列&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;g(get):从队列取出数据&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;h(head):查看队列头数据&quot;</span>);</span><br><span class="line">            key = scanner.next().charAt(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">switch</span> (key) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;s&#x27;</span>:<span class="comment">//显示队列</span></span><br><span class="line">                    circleArray.showQueue();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;e&#x27;</span>:<span class="comment">//退出程序</span></span><br><span class="line">                    scanner.close();</span><br><span class="line">                    loop = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;a&#x27;</span>:<span class="comment">//添加数据到队列</span></span><br><span class="line">                    System.out.println(<span class="string">&quot;请输入一个数&quot;</span>);</span><br><span class="line">                    <span class="keyword">int</span> value = scanner.nextInt();</span><br><span class="line">                    circleArray.addQueue(value);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;g&#x27;</span>:<span class="comment">//从队列取出数据</span></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">int</span> queue = circleArray.getQueue();</span><br><span class="line">                        System.out.printf(<span class="string">&quot;取出的数据是%d\n&quot;</span>, queue);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        System.out.println(e.getMessage());</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;h&#x27;</span>:<span class="comment">//查看队列头数据</span></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">int</span> i = circleArray.headQueue();</span><br><span class="line">                        System.out.printf(<span class="string">&quot;队列头的数据是%d\n&quot;</span>, i);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        System.out.println(e.getMessage());</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    System.out.println(<span class="string">&quot;请输出正确信息&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;程序退出&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CircleArray</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxSize;<span class="comment">//表示数组的最大容量</span></span><br><span class="line">    <span class="comment">//front 变量的含义做一个调整：front 就指向队列的第一个元素，也就是说arr[front]就是队列的第一个元素</span></span><br><span class="line">    <span class="comment">//front 的初始值 = 0</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> front;<span class="comment">//队列头</span></span><br><span class="line">    <span class="comment">//rear 变量的含义做一个调整：rear 就指向队列的最后一个元素的后一个位置，希望空出一个空间作为约定</span></span><br><span class="line">    <span class="comment">//rear 的初始值 = 0</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> rear;<span class="comment">//队列尾</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] arr;<span class="comment">//该数组用于存放数据，模拟队列</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CircleArray</span><span class="params">(<span class="keyword">int</span> arrMaxSize)</span> </span>&#123;</span><br><span class="line">        maxSize = arrMaxSize;</span><br><span class="line">        arr = <span class="keyword">new</span> <span class="keyword">int</span>[maxSize];</span><br><span class="line">        <span class="comment">//front 和 rear 初始值为0 可以不写</span></span><br><span class="line">        <span class="comment">//front = 0;</span></span><br><span class="line">        <span class="comment">//rear = 0;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断队列是否满</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFull</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (rear + <span class="number">1</span>) % maxSize == front;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断队列是否为空</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> rear == front;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加数据到队列</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addQueue</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isFull()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;队列满，无法在添加数据&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//因为rear本身就指向队列的最后一个元素的后一个元素，所以直接将数据加入</span></span><br><span class="line">        arr[rear] = n;</span><br><span class="line">        <span class="comment">//将rear后移，这里必须考虑取模</span></span><br><span class="line">        rear = (rear + <span class="number">1</span>) % maxSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取队列的数据，出队列</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//判断队列是否空</span></span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            <span class="comment">//抛出异常处理</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;队列为空,不能取数据&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//因为front本身就指向队列的第一个元素</span></span><br><span class="line">        <span class="comment">//1.先把front对应的值保留到一个临时变量</span></span><br><span class="line">        <span class="comment">//2.将front后移   考虑取模</span></span><br><span class="line">        <span class="comment">//3.将零食保存的变量返回</span></span><br><span class="line">        <span class="keyword">int</span> value = arr[front];</span><br><span class="line">        front = (front + <span class="number">1</span>) % maxSize;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//显示队列的所有数据</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//遍历</span></span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;队列为空，无数据&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//思路：从front开始遍历，遍历多少个元素</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = front; i &lt; front + size(); i++) &#123;</span><br><span class="line">            System.out.printf(<span class="string">&quot;arr[%d]=%d\n&quot;</span>, i % maxSize, arr[i % maxSize]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//求出当前队列有多少个有效数据</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//rear  =  2</span></span><br><span class="line">        <span class="comment">//front  =  1</span></span><br><span class="line">        <span class="comment">//maxSize  =  3</span></span><br><span class="line">        <span class="keyword">return</span> (rear + maxSize - front) % maxSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//显示队列的头数据，注意不是取出数据</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">headQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;队列为空,无数据&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//因为front本身就指向队列的第一个元素</span></span><br><span class="line">        <span class="keyword">return</span> arr[front];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>03.稀疏数组与队列</category>
      </categories>
      <tags>
        <tag>算法与数据结构</tag>
        <tag>稀疏数组</tag>
        <tag>队列</tag>
      </tags>
  </entry>
  <entry>
    <title>递归</title>
    <url>/2021/07/07/06.%E9%80%92%E5%BD%92/</url>
    <content><![CDATA[<h3 id="递归recursion"><a class="markdownIt-Anchor" href="#递归recursion">#</a> 递归 (Recursion)</h3>
<h4 id="递归的概念"><a class="markdownIt-Anchor" href="#递归的概念">#</a> 递归的概念</h4>
<p>递归就是方法自己调用自己，每次调用时传入不同的变量 **.**<strong> 递归有助于编程者解决复杂的问题</strong>，同时可以让代码变得简洁。</p>
<h3 id="递归的调用机制"><a class="markdownIt-Anchor" href="#递归的调用机制">#</a> 递归的调用机制</h3>
<p><a href="https://imgtu.com/i/R7ETeJ"><img src="https://z3.ax1x.com/2021/07/06/R7ETeJ.png" alt="R7ETeJ.png"></a></p>
<h4 id="代码演示"><a class="markdownIt-Anchor" href="#代码演示">#</a> 代码演示</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> demo1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RecursionTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> i = factorial(<span class="number">3</span>);</span><br><span class="line">        System.out.println(i);</span><br><span class="line">        test(<span class="number">4</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//递归</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &gt; <span class="number">2</span>) &#123;</span><br><span class="line">            test(n - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;n=&quot;</span> + n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//阶乘</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">factorial</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> factorial(n - <span class="number">1</span>) * n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="递归的用途"><a class="markdownIt-Anchor" href="#递归的用途">#</a> 递归的用途</h3>
<ul>
<li>
<p>各种数学问题如: 8 皇后问题，汉诺塔，阶乘问题，迷宫问题，球和篮子的问题 (google 编程大赛)</p>
</li>
<li>
<p>各种算法中也会使用到递归，比如快排，归并排序，二分查找，分治算法等.</p>
</li>
<li>
<p>将用栈解决的问题–&gt; 第归代码比较简洁</p>
</li>
</ul>
<h3 id="递归遵守的规则"><a class="markdownIt-Anchor" href="#递归遵守的规则">#</a> 递归遵守的规则</h3>
<ul>
<li>执行一个方法时，就创建一个新的受保护的独立空间 (栈空间)</li>
<li>方法的局部变量是独立的，不会相互影响，比如 n 变量</li>
<li>如果方法中使用的是引用类型变量 (比如数组)，就会共享该引用类型的数据.</li>
<li>递归必须向退出递归的条件逼近，否则就是无限递归，出现 StackOverflowError，死龟了：)</li>
<li>当一个方法执行完毕，或者遇到 return，就会返回，遵守谁调用，就将结果返回给谁，同时当方法执行完毕或者返回时，该方法也就执行完毕。</li>
</ul>
<h3 id="递归的案例"><a class="markdownIt-Anchor" href="#递归的案例">#</a> 递归的案例</h3>
<h4 id="迷宫问题"><a class="markdownIt-Anchor" href="#迷宫问题">#</a> 迷宫问题</h4>
<h5 id="问题介绍"><a class="markdownIt-Anchor" href="#问题介绍">#</a> 问题介绍</h5>
<p><a href="https://imgtu.com/i/R7ELJx"><img src="https://z3.ax1x.com/2021/07/06/R7ELJx.png" alt="R7ELJx.png"></a></p>
<h5 id="代码实现"><a class="markdownIt-Anchor" href="#代码实现">#</a> 代码实现</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> demo2;</span><br><span class="line"></span><br><span class="line"><span class="comment">//迷宫问题</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MiGong</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//先创建一个二维数组</span></span><br><span class="line">        <span class="comment">//模拟地图</span></span><br><span class="line">        <span class="keyword">int</span>[][] map = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">8</span>][<span class="number">7</span>];</span><br><span class="line">        <span class="comment">//使用 1 表示墙</span></span><br><span class="line">        <span class="comment">//上下全部置为 1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++) &#123;</span><br><span class="line">            map[<span class="number">0</span>][i] = <span class="number">1</span>;</span><br><span class="line">            map[<span class="number">7</span>][i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//左右全部置为 1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line">            map[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">            map[i][<span class="number">6</span>] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//设置挡板  用 1 表示</span></span><br><span class="line">        map[<span class="number">3</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        map[<span class="number">3</span>][<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">        map[<span class="number">6</span>][<span class="number">4</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//输出地图</span></span><br><span class="line">        System.out.println(<span class="string">&quot;地图情况&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">7</span>; j++) &#123;</span><br><span class="line">                System.out.print(map[i][j] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用递归回溯给小球找路</span></span><br><span class="line"></span><br><span class="line">        setWay(map, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//输出新的地图，小球走过，并标识过的地图</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;小球走过，并标识过的地图&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">7</span>; j++) &#123;</span><br><span class="line">                System.out.print(map[i][j] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用递归回溯来给小球找路</span></span><br><span class="line">    <span class="comment">//1、 map 表示地图</span></span><br><span class="line">    <span class="comment">//2、 i,j 表示哪个位置开始出发(1,1)</span></span><br><span class="line">    <span class="comment">//3、 如果小球能到map[6][5] 位置，则说明通路找到了</span></span><br><span class="line">    <span class="comment">//4、 当map[i][j] 为 0 时表示该点没有走，为 1 时表示墙；2 表示通路可以走，3 表示已经走了 但是走不通</span></span><br><span class="line">    <span class="comment">//5、 在走迷宫时，需要确定一个策略（方法） 下 -&gt; 右 -&gt; 上 -&gt; 左，如果该点走不通，在回溯</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> map 表示地图</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i   从哪个位置开始找</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> j</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 如果找到通路，就返回true，否则返回false</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">setWay</span><span class="params">(<span class="keyword">int</span>[][] map, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (map[<span class="number">6</span>][<span class="number">5</span>] == <span class="number">2</span>) &#123;<span class="comment">//表示通路已经找到</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (map[i][j] == <span class="number">0</span>) &#123;<span class="comment">//如果该点没有走过</span></span><br><span class="line">                <span class="comment">//按照策略走 下 -&gt; 右 -&gt; 上 -&gt; 左</span></span><br><span class="line">                map[i][j] = <span class="number">2</span>;<span class="comment">//假定该点可以走通</span></span><br><span class="line">                <span class="keyword">if</span> (setWay(map, i + <span class="number">1</span>, j)) &#123;<span class="comment">//向下走</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (setWay(map, i, j + <span class="number">1</span>)) &#123;<span class="comment">//向右走</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (setWay(map, i - <span class="number">1</span>, j)) &#123;<span class="comment">//向上走</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (setWay(map, i, j - <span class="number">1</span>)) &#123;<span class="comment">//向左走</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//说明该点走不通，是死路</span></span><br><span class="line">                    map[i][j] = <span class="number">3</span>;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;<span class="comment">//如果map[i][j] != 0,可能是1,2,3</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="八皇后问题"><a class="markdownIt-Anchor" href="#八皇后问题">#</a> 八皇后问题</h4>
<h5 id="问题介绍-2"><a class="markdownIt-Anchor" href="#问题介绍-2">#</a> 问题介绍</h5>
<p><a href="https://imgtu.com/i/R7ExyD"><img src="https://z3.ax1x.com/2021/07/06/R7ExyD.png" alt="R7ExyD.png"></a></p>
<h5 id="算法分析"><a class="markdownIt-Anchor" href="#算法分析">#</a> 算法分析</h5>
<ol>
<li>
<p>第一个皇后先放第一行第一列</p>
</li>
<li>
<p>第二个皇后放在第二行第一列、然后判断是否 OK [即判断是冲突]， 如果不 OK，继续放在第二列、第三列、依次把所有列都放完，找到一个合适</p>
</li>
<li>
<p>继续第三个皇后，还是第一列、第二列…… 直到第 8 个皇后也能放在一个不冲突的位置，算是找到了一个正确解</p>
</li>
<li>
<p>当得到一个正确解时，在栈回退到上一个栈时，就会开始回溯，即将第一个皇后，放到第一列的所有正确解，全部得到.</p>
</li>
<li>
<p>然后回头继续第一个皇后放第二列，后面继续循环执行 1,2,3,4 的步骤</p>
</li>
</ol>
<h5 id="说明"><a class="markdownIt-Anchor" href="#说明">#</a> 说明</h5>
<p>理论上应该创建一个二维数组来表示棋盘，但是实际上可以通过算法，用一个一维数组即可解决问题. arr [8] = {0 , 4, 7, 5, 2, 6, 1, 3} // 对应 arr 下标 表示第几行，即第几个皇后，arr [i] = val , val 表示第 i+1 个皇后，放在第 i+1 行的第 val+1 列</p>
<h5 id="代码演示-2"><a class="markdownIt-Anchor" href="#代码演示-2">#</a> 代码演示</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> demo3;</span><br><span class="line"></span><br><span class="line"><span class="comment">//八皇后问题</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Queue</span> </span>&#123;</span><br><span class="line">    <span class="comment">//先定义一个max，表示共有多少个皇后</span></span><br><span class="line">    <span class="keyword">int</span> max=<span class="number">8</span>;</span><br><span class="line">    <span class="comment">//定义数组array，保存皇后放置位置的结果，比如arr = &#123;0,4,7,5,2,6,1,3&#125;</span></span><br><span class="line">    <span class="keyword">int</span>[] array = <span class="keyword">new</span> <span class="keyword">int</span>[max];</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//测试</span></span><br><span class="line">        Queue queue = <span class="keyword">new</span> Queue();</span><br><span class="line">        queue.check(<span class="number">0</span>);</span><br><span class="line">        System.out.printf(<span class="string">&quot;一共有%d种解法&quot;</span>,count);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//编写一个方法，放置第n个皇后</span></span><br><span class="line">    <span class="comment">//特别注意：check 是 每一次递归时，进入到check都有 for (int i = 0; i &lt; max; i++)，因此会有回溯</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == max)&#123;<span class="comment">//n=8,其实八个皇后已然放好了</span></span><br><span class="line">            print();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//依次放入皇后，并判断是否冲突</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; max; i++) &#123;</span><br><span class="line">            <span class="comment">//先把当前这个皇后n,放到该行的第一列</span></span><br><span class="line">            array[n]=i;</span><br><span class="line">            <span class="comment">//判断当放置第n个皇后到i列时，是否冲突</span></span><br><span class="line">            <span class="keyword">if</span>(judge(n))&#123;</span><br><span class="line">                <span class="comment">//接着放置n+1个皇后，开始递归</span></span><br><span class="line">                check(n+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果冲突，就继续执行array[n] = i;即将第n个皇后，放置在本行的后移一个位置</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查看当我们放置第n个皇后时，就去检测该皇后是否和前面已经摆放的皇后冲突</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> n 表示第n皇后</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">judge</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="comment">//1.array[i]==array[n]  表示判断 第n个皇后是否和前面的n-1个皇后在同一列</span></span><br><span class="line">            <span class="comment">//2.Math.abs(n-i)==Math.abs(array[n]-array[i])  表示判断第n个皇后是否和第i个皇后在同一斜线上</span></span><br><span class="line">            <span class="keyword">if</span>(array[i]==array[n] || Math.abs(n-i)==Math.abs(array[n]-array[i]))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//写一个方法，可以将皇后摆放的位置输出</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">        count++;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">            System.out.print(array[i]+<span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>06.递归</category>
      </categories>
      <tags>
        <tag>算法与数据结构</tag>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title>查找算法</title>
    <url>/2021/07/07/08.%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="查找算法介绍"><a class="markdownIt-Anchor" href="#查找算法介绍">#</a> 查找算法介绍</h1>
<p>在 java 中，我们常用的查找有四种：</p>
<ol>
<li>顺序（线性）查找</li>
<li>二分查找 / 折半查找</li>
<li>插值查找</li>
<li>斐波那契查找</li>
</ol>
<h2 id="顺序线性查找算法"><a class="markdownIt-Anchor" href="#顺序线性查找算法">#</a> 顺序（线性）查找算法</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SeqSearch</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr=&#123;<span class="number">1</span>,<span class="number">8</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">74</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">1</span>,<span class="number">6</span>,-<span class="number">238</span>&#125;;<span class="comment">//无序数组</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> index = seqSearch(arr,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (index == -<span class="number">1</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;没有找到&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;找到该值下标为&quot;</span>+index);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//普通的线性查找</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">seqSearch</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">        <span class="comment">//线性查找是注意比较，发现有相同值，就返回下标</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] == value) &#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="二分查找-折半查找算法"><a class="markdownIt-Anchor" href="#二分查找-折半查找算法">#</a> 二分查找 / 折半查找算法</h2>
<p><a href="https://imgtu.com/i/R7e1MT"><img src="https://z3.ax1x.com/2021/07/06/R7e1MT.png" alt="R7e1MT.png"></a></p>
<h3 id="代码示例"><a class="markdownIt-Anchor" href="#代码示例">#</a> 代码示例</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> demo02;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//二分查找必须保证该数组是有序的</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinarySearch</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>, <span class="number">8</span>, <span class="number">10</span>, <span class="number">89</span>, <span class="number">100</span>,<span class="number">100</span>,<span class="number">100</span>, <span class="number">213</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> resIndex=binarySearch(arr,<span class="number">0</span>,arr.length,<span class="number">100</span>);</span><br><span class="line">        System.out.println(resIndex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr     数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> left    左边的索引</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> right   右边的索引</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> findVal 需要查找的值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 如果找到就返回下标，没有找到就返回-1</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> findVal)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> midVal = arr[mid];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(left&gt;right)&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (findVal &gt; midVal) &#123;<span class="comment">//向右递归</span></span><br><span class="line">            <span class="keyword">return</span> binarySearch(arr, mid + <span class="number">1</span>, right, findVal);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (findVal &lt; midVal) &#123;<span class="comment">//向左递归</span></span><br><span class="line">            <span class="keyword">return</span> binarySearch(arr, left, mid - <span class="number">1</span>, findVal);</span><br><span class="line">        &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="进阶代码"><a class="markdownIt-Anchor" href="#进阶代码">#</a> 进阶代码</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> demo02;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *课后习题：</span></span><br><span class="line"><span class="comment"> * &#123;1, 8, 10, 89, 100,100,100, 213&#125;当一个有序数组中</span></span><br><span class="line"><span class="comment"> * 有多个相同数值时，如何将所有的数值都查找到</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 思路分析：</span></span><br><span class="line"><span class="comment"> * 1、在找到mid 索引值，不需要马上返回</span></span><br><span class="line"><span class="comment"> * 2、向mid 索引值的左边扫描，将所有满足 100 的元素的下标，加入到集合 ArrayList 中</span></span><br><span class="line"><span class="comment"> * 3、向mid 索引值的右边扫描，将所有满足 100 的元素的下标，加入到集合 ArrayList</span></span><br><span class="line"><span class="comment"> * 4、将 ArrayList 返回</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">//二分查找必须保证该数组是有序的</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinarySearch_pro</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>, <span class="number">8</span>, <span class="number">10</span>, <span class="number">89</span>, <span class="number">100</span>,<span class="number">100</span>,<span class="number">100</span>, <span class="number">213</span>&#125;;</span><br><span class="line"></span><br><span class="line">        ArrayList&lt;Integer&gt; integers = binarySearch_pro(arr, <span class="number">0</span>, arr.length-<span class="number">1</span>, <span class="number">100</span>);</span><br><span class="line">        System.out.println(integers);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr     数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> left    左边的索引</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> right   右边的索引</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> findVal 需要查找的值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 如果找到就返回下标，没有找到就返回-1</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ArrayList&lt;Integer&gt; <span class="title">binarySearch_pro</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> findVal)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> midVal = arr[mid];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(left&gt;right)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (findVal &gt; midVal) &#123;<span class="comment">//向右递归</span></span><br><span class="line">            <span class="keyword">return</span> binarySearch_pro(arr, mid + <span class="number">1</span>, right, findVal);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (findVal &lt; midVal) &#123;<span class="comment">//向左递归</span></span><br><span class="line">            <span class="keyword">return</span> binarySearch_pro(arr, left, mid - <span class="number">1</span>, findVal);</span><br><span class="line">        &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 思路分析：</span></span><br><span class="line"><span class="comment">             * 1、在找到mid 索引值，不需要马上返回</span></span><br><span class="line"><span class="comment">             * 2、向mid 索引值的左边扫描，将所有满足 100 的元素的下标，加入到集合 ArrayList中</span></span><br><span class="line"><span class="comment">             * 3、向mid 索引值的右边扫描，将所有满足 100 的元素的下标，加入到集合 ArrayList</span></span><br><span class="line"><span class="comment">             * 4、将 ArrayList 返回</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            ArrayList&lt;Integer&gt; resIndexList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="comment">//向mid 索引值的左边扫描，将所有满足 100 的元素的下标，加入到集合 ArrayList 中</span></span><br><span class="line">            <span class="keyword">int</span> temp=mid-<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span> (temp&lt;<span class="number">0</span>||arr[temp]!=findVal)&#123;</span><br><span class="line">                    <span class="comment">//退出</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//否则，就将temp放入到resIndexList 中</span></span><br><span class="line">                resIndexList.add(temp);</span><br><span class="line">                temp-=<span class="number">1</span>; <span class="comment">//temp 左移</span></span><br><span class="line">            &#125;</span><br><span class="line">            resIndexList.add(mid);</span><br><span class="line">            <span class="comment">//向mid 索引值的右边扫描，将所有满足 100 的元素的下标，加入到集合 ArrayList</span></span><br><span class="line">            temp=mid+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span> (temp&gt;arr.length-<span class="number">1</span> || arr[temp]!=findVal)&#123;</span><br><span class="line">                    <span class="comment">//退出</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//否则，就将temp放入到resIndexList 中</span></span><br><span class="line">                resIndexList.add(temp);</span><br><span class="line">                temp+=<span class="number">1</span>; <span class="comment">//temp 右移</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> resIndexList;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="插值查找算法"><a class="markdownIt-Anchor" href="#插值查找算法">#</a> 插值查找算法</h2>
<h3 id="原理介绍"><a class="markdownIt-Anchor" href="#原理介绍">#</a> 原理介绍</h3>
<ol>
<li>
<p>插值查找算法类似于二分查找，不同的是插值查找每次从<strong>自适应</strong> mid 处开始查找。</p>
</li>
<li>
<p>将折半查找中的求 mid 索引的公式，low 表示左边索引 left, high 表示右边索引 right。key 就是前面我们讲的 findVal</p>
<p><a href="https://imgtu.com/i/R7eJZ4"><img src="https://z3.ax1x.com/2021/07/06/R7eJZ4.png" alt="R7eJZ4.png"></a></p>
</li>
<li>
<p>int mid = low + (high - low) * (key - arr[low]) / (arr[high] - arr[low]) ;   <em>插值索引</em><br>
对应前面的代码公式：<br>
int mid = left + (right – left) * (findVal – arr[left]) / (arr[right] – arr[left])</p>
</li>
</ol>
<p><a href="https://imgtu.com/i/R7edRx"><img src="https://z3.ax1x.com/2021/07/06/R7edRx.png" alt="R7edRx.png"></a></p>
<h3 id="注意事项"><a class="markdownIt-Anchor" href="#注意事项">#</a> 注意事项</h3>
<ol>
<li>
<p>对于数据量较大，<strong>关键字分布比较均匀</strong>的查找表来说，采用<strong>插值查找，速度较快.</strong></p>
</li>
<li>
<p>关键字分布不均匀的情况下，该方法不一定比折半查找要好</p>
</li>
</ol>
<h3 id="代码展示"><a class="markdownIt-Anchor" href="#代码展示">#</a> 代码展示</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> demo03;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InsertValueSearch</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">100</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            arr[i] = i + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> index = insertValueSearch(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;index=&quot;</span>+index);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 编写插值查找算法</span></span><br><span class="line"><span class="comment">     * 说明：插值查找算法也要求数组是有序的</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr     数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> left    左边索引</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> right   右边索引</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> findVal 查找的值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 如果找到就返回对应的下标，没有就返回 -1</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">insertValueSearch</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> findVal)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断退出</span></span><br><span class="line">        <span class="keyword">if</span> (left &gt; right || findVal &lt; arr[<span class="number">0</span>] || findVal &gt; arr[arr.length - <span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//求出 mid</span></span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) * (findVal - arr[left]) / (arr[right] - arr[left]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> midVal=arr[mid];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(findVal&gt;midVal)&#123; <span class="comment">//说明应该向右边递归查找</span></span><br><span class="line">            <span class="keyword">return</span> insertValueSearch(arr,mid+<span class="number">1</span>,right,findVal);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(findVal&lt;midVal)&#123; <span class="comment">//说明应该向左边递归查找</span></span><br><span class="line">            <span class="keyword">return</span> insertValueSearch(arr,left,mid-<span class="number">1</span>,findVal);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="斐波那契查找算法"><a class="markdownIt-Anchor" href="#斐波那契查找算法">#</a> 斐波那契查找算法</h2>
<h3 id="基本介绍"><a class="markdownIt-Anchor" href="#基本介绍">#</a> 基本介绍</h3>
<p>黄金分割点是指把一条<a href="">线段</a>分割为两部分，使其中一部分与全长之比等于另一部分与这部分之比。取其前三位数字的近似值是<a href=""> 0.618</a>。由于按此比例设计的造型十分美丽，因此称为<a href="">黄金分割</a>，也称为<a href="">中外比</a>。这是一个神奇的数字，会带来意向不大的效果。</p>
<p><strong>斐波那契数列</strong> {1, 1, 2, 3, 5, 8, 13, 21, 34, 55} 发现斐波那契数列的两个相邻数 的比例，无限接近 黄金分割值 0.618</p>
<h3 id="原理分析"><a class="markdownIt-Anchor" href="#原理分析">#</a> 原理分析</h3>
<p><strong>斐波那契 (黄金分割法) 原理:</strong></p>
<p><strong>斐波那契查找</strong>原理与前两种相似，仅仅改变了中间结点（mid）的位置，mid 不再是中间或插值得到，而是位于黄金分割点附近，即<strong> mid=low+F (k-1)-1</strong>（F 代表斐波那契数列），如下图所示</p>
<p><a href="https://imgtu.com/i/R7ecod"><img src="https://z3.ax1x.com/2021/07/06/R7ecod.png" alt="R7ecod.png"></a></p>
<p><strong>对 F (k-1)-1 的理解：</strong></p>
<p>1、由斐波那契数列 <strong>F[k]=F[k-1]+F[k-2]</strong> 的性质，可以得到 <strong>（F[k]-1）=（F[k-1]-1）+（F[k-2]-1）+1</strong> 。该式说明：只要顺序表的长度为<strong> F [k]-1</strong>，则可以将该表分成长度为<strong> F [k-1]-1</strong> 和<strong> F [k-2]-1</strong> 的两段，即如上图所示。从而中间位置为<strong> mid=low+F (k-1)-1</strong></p>
<p>2、类似的，每一子段也可以用相同的方式分割</p>
<p>3、但顺序表长度 n 不一定刚好等于 F [k]-1，所以需要将原来的顺序表长度 n 增加至 F [k]-1。这里的 k 值只要能使得 F [k]-1 恰好大于或等于 n 即可，由以下代码得到，顺序表长度增加后，新增的位置（从 n+1 到 F [k]-1 位置），都赋为 n 位置的值即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(n&gt;fib(k)-<span class="number">1</span>)</span><br><span class="line">    k++;</span><br></pre></td></tr></table></figure>
<h3 id="代码分析"><a class="markdownIt-Anchor" href="#代码分析">#</a> 代码分析</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> demo04;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Fibonaci</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> maxSize = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>, <span class="number">8</span>, <span class="number">10</span>, <span class="number">89</span>, <span class="number">1000</span>, <span class="number">1024</span>&#125;;</span><br><span class="line">        System.out.println(fibSearch(arr, <span class="number">8</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//因为后面 mid=low+F(k-1)-1,需要使用斐波那契数列，所以先获取到一个菲波那契数列</span></span><br><span class="line">    <span class="comment">//非递归方式得到一个斐波那契数列</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] fib() &#123;</span><br><span class="line">        <span class="keyword">int</span>[] f = <span class="keyword">new</span> <span class="keyword">int</span>[maxSize];</span><br><span class="line">        f[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        f[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; maxSize; i++) &#123;</span><br><span class="line">            f[i] = f[i - <span class="number">1</span>] + f[i - <span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> a   数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 需要查找的数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回对应的下标，如果没有就返回-1；</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">//编写斐波那契算法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">fibSearch</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> high = a.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">0</span>;<span class="comment">//表示斐波那契数值下标</span></span><br><span class="line">        <span class="keyword">int</span> mid = <span class="number">0</span>;<span class="comment">//放mid 的值</span></span><br><span class="line">        <span class="keyword">int</span>[] f = fib();<span class="comment">//获取斐波那契数列</span></span><br><span class="line">        <span class="comment">//获取斐波那契分割数值的下标</span></span><br><span class="line">        <span class="keyword">while</span> (high &gt; f[k] - <span class="number">1</span>) &#123;</span><br><span class="line">            k++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//因为f[k] 值可能大于 a 的长度，因此我们需要使用Arrays类，构造一个新的数组，并指向temp[]</span></span><br><span class="line">        <span class="comment">//不足的部分会使用 0 填充</span></span><br><span class="line">        <span class="keyword">int</span>[] temp = Arrays.copyOf(a, f[k]);</span><br><span class="line">        <span class="comment">//实际上需要使用a数组最后的数据填充temp</span></span><br><span class="line">        <span class="comment">//举例：</span></span><br><span class="line">        <span class="comment">//&#123;1,8,10,89,1000,1024,0,0,0&#125; -----&gt; &#123;1,8,10,89,1000,1024,1024,1024,1024&#125;</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = high + <span class="number">1</span>; i &lt; temp.length; i++) &#123;</span><br><span class="line">            temp[i] = a[high];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用while来循环处理，找到我们的数 key</span></span><br><span class="line">        <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">            mid =low + f[k - <span class="number">1</span>] - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (key &lt; temp[mid]) &#123;<span class="comment">//向数组左边查找</span></span><br><span class="line">                high = mid - <span class="number">1</span>;</span><br><span class="line">                <span class="comment">//为什么是k--</span></span><br><span class="line">                <span class="comment">//说明</span></span><br><span class="line">                <span class="comment">//1.全部元素 = 前面的元素 + 后面的元素</span></span><br><span class="line">                <span class="comment">//2.f[k] = f[k-1] +f[k-2]</span></span><br><span class="line">                <span class="comment">//3.因为前面有f[k-1] 个元素，所有可以继续拆分f[k-1]=f[k-2]+f[k-3]</span></span><br><span class="line">                <span class="comment">//即 在f[k-1] 的前面继续查找 k--</span></span><br><span class="line">                <span class="comment">//即下次循环 mid=f[k-1-1]-1</span></span><br><span class="line">                k--;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key &gt; temp[mid]) &#123;<span class="comment">//向数组右边查找</span></span><br><span class="line">                low = mid + <span class="number">1</span>;</span><br><span class="line">                <span class="comment">//为什么是k-=2;</span></span><br><span class="line">                <span class="comment">//说明</span></span><br><span class="line">                <span class="comment">//1.全部元素 = 前面的元素 + 后面的元素</span></span><br><span class="line">                <span class="comment">//2.f[k] = f[k-1] +f[k-2]</span></span><br><span class="line">                <span class="comment">//3.因为前面有f[k-2] 个元素，所有可以继续拆分f[k-2]=f[k-3]+f[k-4]</span></span><br><span class="line">                <span class="comment">//即 在f[k-2] 的前面继续查找 k-=2</span></span><br><span class="line">                <span class="comment">//即下次循环 mid=f[k-1-2]-1</span></span><br><span class="line">                k -= <span class="number">2</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;<span class="comment">//找到</span></span><br><span class="line">                <span class="comment">//需要确定，返回的是哪个下标</span></span><br><span class="line">                <span class="keyword">if</span> (mid &lt;= high) &#123;</span><br><span class="line">                    <span class="keyword">return</span> mid;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> high;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>08.查找算法</category>
      </categories>
      <tags>
        <tag>算法与数据结构</tag>
        <tag>线性查找</tag>
        <tag>二分/折半查找</tag>
        <tag>插值查找</tag>
        <tag>斐波那契查找</tag>
      </tags>
  </entry>
  <entry>
    <title>哈希表</title>
    <url>/2021/07/07/09.%E5%93%88%E5%B8%8C%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="哈希表"><a class="markdownIt-Anchor" href="#哈希表">#</a> 哈希表</h1>
<h2 id="基本介绍"><a class="markdownIt-Anchor" href="#基本介绍">#</a> 基本介绍</h2>
<p><strong>散列表</strong>（Hash table，也叫哈希表）</p>
<p>​	根据关键码值（key value）而直接进行访问<strong>数据结构</strong>。也就是说，他通过吧关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做<strong>散列函数</strong>，存放记录的数组叫做<strong>散列表</strong></p>
<p><a href="https://imgtu.com/i/R7mCTJ"><img src="https://z3.ax1x.com/2021/07/06/R7mCTJ.png" alt="R7mCTJ.png"></a></p>
<p><a href="https://imgtu.com/i/R7mFYR"><img src="https://z3.ax1x.com/2021/07/06/R7mFYR.png" alt="R7mFYR.png"></a></p>
<p><a href="https://imgtu.com/i/R7e7wQ"><img src="https://z3.ax1x.com/2021/07/06/R7e7wQ.png" alt="R7e7wQ.png"></a></p>
<h3 id="例题"><a class="markdownIt-Anchor" href="#例题">#</a> 例题</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">有一个公司,当有新的员工来报道时,要求将该员工的信息加入(id,性别,年龄,名字,住址..),当输入该员工的id时,要求查找到该员工的所有信息.</span><br><span class="line">要求: </span><br><span class="line">不使用数据库,,速度越快越好=&gt;哈希表(散列)</span><br><span class="line">添加时，保证按照id从低到高插入  </span><br><span class="line">[课后思考：如果id不是从低到高插入，但要求各条链表仍是从低到高，怎么解决?]</span><br></pre></td></tr></table></figure>
<p><a href="https://imgtu.com/i/R7mkf1"><img src="https://z3.ax1x.com/2021/07/06/R7mkf1.png" alt="R7mkf1.png"></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> demo01;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashTabDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建哈希表</span></span><br><span class="line">        HashTab hashTab=<span class="keyword">new</span> HashTab(<span class="number">7</span>);</span><br><span class="line">        <span class="comment">//写一个简单陈的菜单</span></span><br><span class="line">        String key=<span class="string">&quot;&quot;</span>;</span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;add:  添加雇员&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;list: 显示雇员&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;find: 查找雇员&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;exit: 退出系统&quot;</span>);</span><br><span class="line"></span><br><span class="line">            key=scanner.next();</span><br><span class="line">            <span class="keyword">switch</span> (key)&#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;add&quot;</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;输入id&quot;</span>);</span><br><span class="line">                    <span class="keyword">int</span> id = scanner.nextInt();</span><br><span class="line">                    System.out.println(<span class="string">&quot;输入姓名&quot;</span>);</span><br><span class="line">                    String name = scanner.next();</span><br><span class="line">                    <span class="comment">//创建雇员</span></span><br><span class="line">                    Emp emp=<span class="keyword">new</span> Emp(id,name);</span><br><span class="line">                    hashTab.add(emp);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;list&quot;</span>:</span><br><span class="line">                    hashTab.list();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;find&quot;</span>:</span><br><span class="line">                    System.out.println(<span class="string">&quot;请输入查找的 id&quot;</span>);</span><br><span class="line">                    id = scanner.nextInt();</span><br><span class="line">                    hashTab.findEmpById(id);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;exit&quot;</span>:</span><br><span class="line">                    scanner.close();</span><br><span class="line">                    System.exit(<span class="number">0</span>);</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建HashTable 管理多条链表</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HashTab</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> EmpLinkedList[] empLinkedListArray;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;  <span class="comment">//表示共有多少条链表</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashTab</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.size=size;</span><br><span class="line">        <span class="comment">//初始化 empLinkedListArray</span></span><br><span class="line">        empLinkedListArray = <span class="keyword">new</span> EmpLinkedList[size];</span><br><span class="line">        <span class="comment">// ?????这是不要忘了分别初始化每条链表</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            empLinkedListArray[i]=<span class="keyword">new</span> EmpLinkedList();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加雇员</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Emp emp)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//根据员工的id，得到该员工应当添加到那条链表</span></span><br><span class="line">        <span class="keyword">int</span> empLinkListNO=hashFun(emp.id);</span><br><span class="line">        <span class="comment">//将emp 添加到对应的链表中</span></span><br><span class="line">        empLinkedListArray[empLinkListNO].add(emp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历所有的链表,遍历hashTab</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">list</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            empLinkedListArray[i].list(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据输入的id，查找雇员</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">findEmpById</span><span class="params">(<span class="keyword">int</span> id)</span></span>&#123;</span><br><span class="line">        <span class="comment">//使用散列函数确定到哪条链表查找</span></span><br><span class="line">        <span class="keyword">int</span> empLinkedListNO=hashFun(id);</span><br><span class="line">        Emp emp=empLinkedListArray[empLinkedListNO].findEmpById(id);</span><br><span class="line">        <span class="keyword">if</span> (emp!=<span class="keyword">null</span>)&#123;<span class="comment">//找到</span></span><br><span class="line">            System.out.printf(<span class="string">&quot;在第 %d 链表中找到 雇员 id=%d\n&quot;</span>,(empLinkedListNO+<span class="number">1</span>),id);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;在哈希表中，没有找到该雇员~~&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//编写一个散列函数，使用一个简单的取模法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashFun</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id % size;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//表示 一个雇员</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Emp</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> Emp next;  <span class="comment">//  next 默认为null</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Emp</span><span class="params">(<span class="keyword">int</span> id, String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建 EmpLinkedList，表示链表</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EmpLinkedList</span> </span>&#123;</span><br><span class="line">    <span class="comment">//头指针，指向第一个Emp，因此我们这个链表的head是直接指向第一个 Emp</span></span><br><span class="line">    <span class="keyword">private</span> Emp head; <span class="comment">//默认为null</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加雇员到链表</span></span><br><span class="line">    <span class="comment">//说明</span></span><br><span class="line">    <span class="comment">//1.假定，当添加雇员时，id 是自增长的，即id的分配总是从小到大</span></span><br><span class="line">    <span class="comment">//   因此我们将该雇员直接加入到本链表的最后即可</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Emp emp)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//如果是添加第一个雇员</span></span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">            head = emp;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果不是第一个雇员，则使用一个辅助 指针，帮助定位到最后</span></span><br><span class="line">        Emp curEmp = head;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (curEmp.next == <span class="keyword">null</span>) &#123;<span class="comment">//说明到链表最后</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            curEmp = curEmp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//退出时直接将 emp 加入到链表</span></span><br><span class="line">        curEmp.next = emp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历链表的雇员信息</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">list</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//说明链表为 null</span></span><br><span class="line">            System.out.println(<span class="string">&quot;第&quot;</span>+(no+<span class="number">1</span>)+<span class="string">&quot;条链表为 null&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.print(<span class="string">&quot;第&quot;</span>+(no+<span class="number">1</span>)+<span class="string">&quot;条链表的信息为：&quot;</span>);</span><br><span class="line">        Emp curEmp = head;<span class="comment">//辅助指针</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            System.out.printf(<span class="string">&quot;=&gt; id=%d,name=%s\n&quot;</span>, curEmp.id, curEmp.name);</span><br><span class="line">            <span class="keyword">if</span> (curEmp.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//说明curEmp 已经是最后一个节点</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            curEmp = curEmp.next;<span class="comment">//后移</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据id查找雇员</span></span><br><span class="line">    <span class="comment">//如果查找到，就返回Emp，如果没找到，就返回 null</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Emp <span class="title">findEmpById</span><span class="params">(<span class="keyword">int</span> id)</span></span>&#123;</span><br><span class="line">        <span class="comment">//判断链表是否为 null</span></span><br><span class="line">        <span class="keyword">if</span>(head==<span class="keyword">null</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;链表为 null&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//辅助指针</span></span><br><span class="line">        Emp curEmp=head;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(curEmp.id==id)&#123;<span class="comment">//找到</span></span><br><span class="line">                <span class="keyword">break</span>;<span class="comment">//这时curEmp就指向要查找的雇员</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//退出条件</span></span><br><span class="line">            <span class="keyword">if</span>(curEmp.next==<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="comment">//说明遍历当前链表没有找到该雇员</span></span><br><span class="line">                curEmp=<span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            curEmp=curEmp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> curEmp;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>09.哈希表</category>
      </categories>
      <tags>
        <tag>算法与数据结构</tag>
        <tag>哈希表</tag>
      </tags>
  </entry>
  <entry>
    <title>CSDN路线图</title>
    <url>/2021/06/30/CSDN/</url>
    <content><![CDATA[<p><a href="https://blog.csdn.net/One_L_Star/article/details/102394373">https://blog.csdn.net/One_L_Star/article/details/102394373</a><a href="https://imgtu.com/i/RU1A3D"><img src="https://z3.ax1x.com/2021/06/28/RU1A3D.png" alt="RU1A3D.png"></a><br>
<a href="https://imgtu.com/i/RU1VjH"><img src="https://z3.ax1x.com/2021/06/28/RU1VjH.png" alt="RU1VjH.png"></a><br>
<a href="https://imgtu.com/i/RU1eud"><img src="https://z3.ax1x.com/2021/06/28/RU1eud.png" alt="RU1eud.png"></a><br>
<a href="https://imgtu.com/i/RU1nHI"><img src="https://z3.ax1x.com/2021/06/28/RU1nHI.png" alt="RU1nHI.png"></a><br>
<a href="https://imgtu.com/i/RU1KEt"><img src="https://z3.ax1x.com/2021/06/28/RU1KEt.png" alt="RU1KEt.png"></a></p>
<p><a href="https://imgtu.com/i/RU1Ege"><img src="https://z3.ax1x.com/2021/06/28/RU1Ege.png" alt="RU1Ege.png"></a><br>
<a href="https://imgtu.com/i/RU1i4K"><img src="https://z3.ax1x.com/2021/06/28/RU1i4K.png" alt="RU1i4K.png"></a><br>
<a href="https://imgtu.com/i/RU1k9O"><img src="https://z3.ax1x.com/2021/06/28/RU1k9O.png" alt="RU1k9O.png"></a></p>
]]></content>
      <categories>
        <category>路线图</category>
      </categories>
      <tags>
        <tag>路线图</tag>
      </tags>
  </entry>
  <entry>
    <title>尚硅谷路线图</title>
    <url>/2021/06/30/%E5%B0%9A%E7%A1%85%E8%B0%B7%E8%B7%AF%E7%BA%BF%E5%9B%BE/</url>
    <content><![CDATA[<p><a href="https://imgtu.com/i/RUnSBV"><img src="https://z3.ax1x.com/2021/06/28/RUnSBV.jpg" alt="RUnSBV.jpg"></a></p>
<p><a href="https://imgtu.com/i/RUnQ4e"><img src="https://z3.ax1x.com/2021/06/28/RUnQ4e.png" alt="RUnQ4e.png"></a><br>
<a href="https://imgtu.com/i/RUnMND"><img src="https://z3.ax1x.com/2021/06/28/RUnMND.png" alt="RUnMND.png"></a><br>
<a href="https://imgtu.com/i/RUnKAO"><img src="https://z3.ax1x.com/2021/06/28/RUnKAO.png" alt="RUnKAO.png"></a></p>
<p><a href="https://imgtu.com/i/RUn19H"><img src="https://z3.ax1x.com/2021/06/28/RUn19H.png" alt="RUn19H.png"></a></p>
]]></content>
      <categories>
        <category>路线图</category>
      </categories>
      <tags>
        <tag>路线图</tag>
      </tags>
  </entry>
  <entry>
    <title>敖丙路线图</title>
    <url>/2021/06/30/%E6%95%96%E4%B8%99%E8%84%91%E5%9B%BE/</url>
    <content><![CDATA[<p><a href="https://imgtu.com/i/RNNajO"><img src="https://z3.ax1x.com/2021/06/28/RNNajO.jpg" alt="RNNajO.jpg"></a></p>
]]></content>
      <categories>
        <category>路线图</category>
      </categories>
      <tags>
        <tag>路线图</tag>
      </tags>
  </entry>
  <entry>
    <title>狂神路线图</title>
    <url>/2021/06/30/%E7%8B%82%E7%A5%9E%E8%B7%AF%E7%BA%BF%E5%9B%BE/</url>
    <content><![CDATA[<p><a href="https://www.bilibili.com/read/cv5702420">https://www.bilibili.com/read/cv5702420</a></p>
<p><a href="https://imgtu.com/i/RU3lZR"><img src="https://z3.ax1x.com/2021/06/28/RU3lZR.png" alt="RU3lZR.png"></a></p>
<p><a href="https://imgtu.com/i/RU3ML9"><img src="https://z3.ax1x.com/2021/06/28/RU3ML9.png" alt="RU3ML9.png"></a><br>
<a href="https://imgtu.com/i/RU31d1"><img src="https://z3.ax1x.com/2021/06/28/RU31d1.png" alt="RU31d1.png"></a><br>
<a href="https://imgtu.com/i/RU3Gi6"><img src="https://z3.ax1x.com/2021/06/28/RU3Gi6.png" alt="RU3Gi6.png"></a></p>
<p><a href="https://imgtu.com/i/RU3KsJ"><img src="https://z3.ax1x.com/2021/06/28/RU3KsJ.png" alt="RU3KsJ.png"></a><br>
<a href="https://imgtu.com/i/RU3ZGT"><img src="https://z3.ax1x.com/2021/06/28/RU3ZGT.png" alt="RU3ZGT.png"></a><br>
<a href="https://imgtu.com/i/RU3uM4"><img src="https://z3.ax1x.com/2021/06/28/RU3uM4.png" alt="RU3uM4.png"></a><br>
<a href="https://imgtu.com/i/RU3mzF"><img src="https://z3.ax1x.com/2021/06/28/RU3mzF.png" alt="RU3mzF.png"></a><br>
<a href="https://imgtu.com/i/RU3eRU"><img src="https://z3.ax1x.com/2021/06/28/RU3eRU.png" alt="RU3eRU.png"></a><br>
<a href="https://imgtu.com/i/RU33Ix"><img src="https://z3.ax1x.com/2021/06/28/RU33Ix.png" alt="RU33Ix.png"></a></p>
]]></content>
      <categories>
        <category>路线图</category>
      </categories>
      <tags>
        <tag>路线图</tag>
      </tags>
  </entry>
  <entry>
    <title>黑马路线图</title>
    <url>/2021/06/30/%E9%BB%91%E9%A9%AC%E8%B7%AF%E7%BA%BF%E5%9B%BE/</url>
    <content><![CDATA[<p><a href="https://imgtu.com/i/RUlhcQ"><img src="https://z3.ax1x.com/2021/06/28/RUlhcQ.png" alt="RUlhcQ.png"></a></p>
]]></content>
      <categories>
        <category>路线图</category>
      </categories>
      <tags>
        <tag>路线图</tag>
      </tags>
  </entry>
  <entry>
    <title>我的笔记</title>
    <url>/2021/06/30/%E7%BD%AE%E9%A1%B6/</url>
    <content><![CDATA[<p>katex: true 开启数学公式<br>
 sticky: 100  置顶</p>
]]></content>
      <categories>
        <category>我的笔记</category>
        <category>生活</category>
      </categories>
      <tags>
        <tag>随手记</tag>
      </tags>
  </entry>
  <entry>
    <title>链表LinkedList</title>
    <url>/2021/06/30/04.%E9%93%BE%E8%A1%A8LinkedList/</url>
    <content><![CDATA[<h2 id="链表linkedlist"><a class="markdownIt-Anchor" href="#链表linkedlist">#</a> 链表 LinkedList</h2>
<h3 id="链表简介"><a class="markdownIt-Anchor" href="#链表简介">#</a> 链表简介</h3>
<p>链表是有序的列表，它在内存中的存储</p>
<p><a href="https://imgtu.com/i/RwA5yq"><img src="https://z3.ax1x.com/2021/06/29/RwA5yq.png" alt="RwA5yq.png"></a></p>
<p>小结：</p>
<ol>
<li>
<p>链表是以节点的方式来存储，是链式存储</p>
</li>
<li>
<p>每个节点包含 data 域， next 域：指向下一个节点.</p>
</li>
<li>
<p>如图：发现链表的<strong>各个节点不一定是连续存储</strong>.</p>
</li>
<li>
<p>链表分带头节点的链表和没有头节点的链表，根据实际的需求来确定</p>
<p>1. 单链表（带头结点）逻辑结构示意图</p>
</li>
</ol>
<p><a href="https://imgtu.com/i/RwA7wT"><img src="https://z3.ax1x.com/2021/06/29/RwA7wT.png" alt="RwA7wT.png"></a></p>
<h2 id="单链表"><a class="markdownIt-Anchor" href="#单链表">#</a> 单链表</h2>
<h3 id="单链表的应用增删改查"><a class="markdownIt-Anchor" href="#单链表的应用增删改查">#</a> 单链表的应用【增删改查】</h3>
<p><a href="https://imgtu.com/i/RwALY4"><img src="https://z3.ax1x.com/2021/06/29/RwALY4.png" alt="RwALY4.png"></a></p>
<p><a href="https://imgtu.com/i/RwAOfJ"><img src="https://z3.ax1x.com/2021/06/29/RwAOfJ.png" alt="RwAOfJ.png"></a></p>
<p><a href="https://imgtu.com/i/RwEkfH"><img src="https://z3.ax1x.com/2021/06/29/RwEkfH.png" alt="RwEkfH.png"></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.LinkedList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleLinkedListDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//进行测试</span></span><br><span class="line">        <span class="comment">//先创建几个节点</span></span><br><span class="line">        HeroNode hero1 = <span class="keyword">new</span> HeroNode(<span class="number">1</span>, <span class="string">&quot;佐菲&quot;</span>, <span class="string">&quot;炎头队长&quot;</span>);</span><br><span class="line">        HeroNode hero2 = <span class="keyword">new</span> HeroNode(<span class="number">2</span>, <span class="string">&quot;曼&quot;</span>, <span class="string">&quot;老二&quot;</span>);</span><br><span class="line">        HeroNode hero3 = <span class="keyword">new</span> HeroNode(<span class="number">3</span>, <span class="string">&quot;赛文&quot;</span>, <span class="string">&quot;seven&quot;</span>);</span><br><span class="line">        HeroNode hero4 = <span class="keyword">new</span> HeroNode(<span class="number">4</span>, <span class="string">&quot;杰克&quot;</span>, <span class="string">&quot;归曼&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建一个链表</span></span><br><span class="line">        SingleLinkedList singleLinkedList = <span class="keyword">new</span> SingleLinkedList();</span><br><span class="line">        <span class="comment">//添加</span></span><br><span class="line">        <span class="comment">//singleLinkedList.add(hero1);</span></span><br><span class="line">        <span class="comment">//singleLinkedList.add(hero2);</span></span><br><span class="line">        <span class="comment">//singleLinkedList.add(hero3);</span></span><br><span class="line">        <span class="comment">//singleLinkedList.add(hero4);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//加入按照编号的顺序</span></span><br><span class="line">        singleLinkedList.addByOrder(hero1);</span><br><span class="line">        singleLinkedList.addByOrder(hero4);</span><br><span class="line">        singleLinkedList.addByOrder(hero3);</span><br><span class="line">        singleLinkedList.addByOrder(hero2);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;修改前的链表&quot;</span>);</span><br><span class="line">        singleLinkedList.list();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//测试修改节点的代码</span></span><br><span class="line">        HeroNode newheroNode=<span class="keyword">new</span> HeroNode(<span class="number">2</span>,<span class="string">&quot;奥特曼&quot;</span>,<span class="string">&quot;初代&quot;</span>);</span><br><span class="line">        singleLinkedList.update(newheroNode);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;修改后的链表&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;删除前的链表&quot;</span>);</span><br><span class="line">        singleLinkedList.list();</span><br><span class="line"></span><br><span class="line">        singleLinkedList.del(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//显示一把</span></span><br><span class="line">        System.out.println(<span class="string">&quot;删除后的链表&quot;</span>);</span><br><span class="line">        singleLinkedList.list();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义SingleLinkedList 管理我们的英雄</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingleLinkedList</span></span>&#123;</span><br><span class="line">    <span class="comment">//先初始化一个头节点，头节点不要动，不存放具体数据</span></span><br><span class="line">    <span class="keyword">private</span> HeroNode head=<span class="keyword">new</span> HeroNode(<span class="number">0</span>,<span class="string">&quot;&quot;</span>,<span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加节点到单向链表</span></span><br><span class="line">    <span class="comment">//思路，当不考虑标号顺序时</span></span><br><span class="line">    <span class="comment">//1.找到当前链表的最后节点</span></span><br><span class="line">    <span class="comment">//2.将最后这个节点的 next域 指向新的节点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(HeroNode heroNode)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//因为head节点不能动，因此我们需要一个辅助节点(指针。变量)temp</span></span><br><span class="line">        HeroNode temp=head;</span><br><span class="line">        <span class="comment">//遍历链表，找到最后</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="comment">//找到链表的最后</span></span><br><span class="line">            <span class="keyword">if</span>(temp.next==<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果没有找到，temp后移</span></span><br><span class="line">            temp=temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//当退出while循环时，temp就指向新的节点</span></span><br><span class="line">        temp.next=heroNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//第二种方式添加英雄时，根据排名将英雄插入到指定位置</span></span><br><span class="line">    <span class="comment">//(如果有这个排名，则添加失败，并给出提示)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addByOrder</span><span class="params">(HeroNode heroNode)</span></span>&#123;</span><br><span class="line">        <span class="comment">//因为头节点不能动，因此我们仍然通过一个辅助指针(元素)来帮助找到添加的位置</span></span><br><span class="line">        <span class="comment">//因为单链表，因此我们找的temp 是位于 添加位置的前一个节点，否则插入不了</span></span><br><span class="line">        HeroNode temp=head;</span><br><span class="line">        <span class="keyword">boolean</span> flag=<span class="keyword">false</span>;<span class="comment">//标志添加的编号是否存在，默认为false</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(temp.next==<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="comment">//说明temp已经在链表的最后</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(temp.next.no&gt;heroNode.no)&#123;</span><br><span class="line">                <span class="comment">//位置找到，就在temp的后面插入</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (temp.next.no==heroNode.no)&#123;</span><br><span class="line">                <span class="comment">//说明希望添加的heroNode的编号已经存在</span></span><br><span class="line">                flag=<span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            temp=temp.next;<span class="comment">//后移，遍历当前链表</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断flag的值</span></span><br><span class="line">        <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">            <span class="comment">//不能添加，说明编号存在</span></span><br><span class="line">            System.out.printf(<span class="string">&quot;准备插入的英雄编号 %d 已经存在，不能添加\n&quot;</span>,heroNode.no);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//插入到链表中 temp的后面</span></span><br><span class="line">            heroNode.next=temp.next;</span><br><span class="line">            temp.next=heroNode;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//修改节点的信息，根据编号来修改，既no不能修改</span></span><br><span class="line">    <span class="comment">//说明</span></span><br><span class="line">    <span class="comment">//1.根据newheroNode 的 no 来修改即可</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(HeroNode newheroNode)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head.next==<span class="keyword">null</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;链表为空~~~~&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//找到需要修改的节点</span></span><br><span class="line">        <span class="comment">//先定义一个辅助变量</span></span><br><span class="line">        HeroNode temp=head.next;</span><br><span class="line">        <span class="keyword">boolean</span> flag=<span class="keyword">false</span>;<span class="comment">//表示是否找到该节点</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(temp==<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;<span class="comment">//已经遍历到链表最后，无该编号节点</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(temp.no==newheroNode.no)&#123;</span><br><span class="line">                <span class="comment">//找到了该节点</span></span><br><span class="line">                flag=<span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            temp= temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//根据flag判断是否找到了要修改的节点</span></span><br><span class="line">        <span class="keyword">if</span> (flag)&#123;</span><br><span class="line">            temp.name=newheroNode.name;</span><br><span class="line">            temp.nickname=newheroNode.nickname;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//没有找到该节点</span></span><br><span class="line">            System.out.printf(<span class="string">&quot;没有找到编号为 %d 的节点,无法修改该节点\n&quot;</span>,newheroNode.no);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除节点的代码</span></span><br><span class="line">    <span class="comment">//思路</span></span><br><span class="line">    <span class="comment">//1. head 节点不能动，因此我们需要一个temp辅助节点找到待删除节点的前一个节点</span></span><br><span class="line">    <span class="comment">//2. 说明我们在比较时，时temp.next.no 和需要节点的no 进行比较</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> no)</span></span>&#123;</span><br><span class="line">        HeroNode temp=head;</span><br><span class="line">        <span class="keyword">boolean</span> flag=<span class="keyword">false</span>;<span class="comment">//标志是否找到待删除的节点</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(temp.next==<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(temp.next.no==no)&#123;</span><br><span class="line">                <span class="comment">//找到待删除节点的前一个节点</span></span><br><span class="line">                flag=<span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            temp=temp.next;<span class="comment">//temp后移，遍历</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">            <span class="comment">//找到了 可以删除了</span></span><br><span class="line">            temp.next=temp.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.printf(<span class="string">&quot;要删除的编号为 %d 的英雄不存在\n&quot;</span>,no);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//显示链表[遍历]</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">list</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//判断链表是否为空</span></span><br><span class="line">        <span class="keyword">if</span>(head.next==<span class="keyword">null</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;链表为空&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//因为头节点，不能动，因此我们需要一个辅助变量来遍历</span></span><br><span class="line">        HeroNode temp=head.next;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="comment">//判断是否到链表最后</span></span><br><span class="line">            <span class="keyword">if</span>(temp==<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//输出节点的信息</span></span><br><span class="line">            System.out.println(temp);</span><br><span class="line">            <span class="comment">//将temp后移，一定要小心</span></span><br><span class="line">            temp=temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义HeroNode，每个HeroNode，对象就是一个节点</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HeroNode</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> no;</span><br><span class="line">    <span class="keyword">public</span> String name;<span class="comment">//英雄名字</span></span><br><span class="line">    <span class="keyword">public</span> String nickname;<span class="comment">//昵称</span></span><br><span class="line">    <span class="keyword">public</span> HeroNode next;<span class="comment">//指向下一个节点</span></span><br><span class="line">    <span class="comment">//构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HeroNode</span><span class="params">(<span class="keyword">int</span> no,String name,String nickName)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.no=no;</span><br><span class="line">        <span class="keyword">this</span>.name=name;</span><br><span class="line">        <span class="keyword">this</span>.nickname=nickName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//为了显示方便，我们重写toString</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;HeroNode&#123;no=&quot;</span> + no +<span class="string">&quot;, name=&quot;</span> + name +<span class="string">&quot;, nickname=&quot;</span> + nickname +<span class="string">&quot;&#125;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="单链表的面试题"><a class="markdownIt-Anchor" href="#单链表的面试题">#</a> 单链表的面试题</h3>
<h3 id="求单链表中有效节点的个数"><a class="markdownIt-Anchor" href="#求单链表中有效节点的个数">#</a> 求单链表中有效节点的个数</h3>
<h3 id="查找单链表中的倒数第k个节点新浪面试题"><a class="markdownIt-Anchor" href="#查找单链表中的倒数第k个节点新浪面试题">#</a> 查找单链表中的倒数第 K 个节点【新浪面试题】</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.LinkListText;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedListTestDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        HeroNode h1=<span class="keyword">new</span> HeroNode(<span class="number">1</span>,<span class="string">&quot;kono&quot;</span>,<span class="string">&quot;0ne&quot;</span>);</span><br><span class="line">        HeroNode h2=<span class="keyword">new</span> HeroNode(<span class="number">2</span>,<span class="string">&quot;alphonse&quot;</span>,<span class="string">&quot;two&quot;</span>);</span><br><span class="line">        HeroNode h3=<span class="keyword">new</span> HeroNode(<span class="number">3</span>,<span class="string">&quot;kino&quot;</span>,<span class="string">&quot;three&quot;</span>);</span><br><span class="line">        HeroNode h4=<span class="keyword">new</span> HeroNode(<span class="number">4</span>,<span class="string">&quot;mibius&quot;</span>,<span class="string">&quot;four&quot;</span>);</span><br><span class="line">        HeroNode h5=<span class="keyword">new</span> HeroNode(<span class="number">5</span>,<span class="string">&quot;Taro&quot;</span>,<span class="string">&quot;five&quot;</span>);</span><br><span class="line">        HeroNode h6=<span class="keyword">new</span> HeroNode(<span class="number">6</span>,<span class="string">&quot;Taiga&quot;</span>,<span class="string">&quot;six&quot;</span>);</span><br><span class="line">        LinkedList linkedList=<span class="keyword">new</span> LinkedList();</span><br><span class="line">        linkedList.add(h1);</span><br><span class="line">        linkedList.add(h2);</span><br><span class="line">        linkedList.add(h3);</span><br><span class="line">        linkedList.add(h4);</span><br><span class="line">        linkedList.add(h5);</span><br><span class="line">        linkedList.add(h6);</span><br><span class="line">        linkedList.List();</span><br><span class="line"></span><br><span class="line">        System.out.println(LinkedList.getLength(linkedList.getHead()));</span><br><span class="line"></span><br><span class="line">        System.out.println(LinkedList.findLastIndexNode(linkedList.getHead(),<span class="number">4</span>));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinkedList</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> HeroNode head=<span class="keyword">new</span> HeroNode(<span class="number">0</span>,<span class="string">&quot;&quot;</span>,<span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查找单链表中的倒数第k个节点 【新浪面试题】</span></span><br><span class="line">    <span class="comment">//思路</span></span><br><span class="line">    <span class="comment">//1.编写一个方法,接收head节点，同时接收一个index</span></span><br><span class="line">    <span class="comment">//2. index表示是倒数第index个节点</span></span><br><span class="line">    <span class="comment">//3.先把链表从头到尾遍历，得到链表的总的长度getLength</span></span><br><span class="line">    <span class="comment">//4.得到size后，我们从链表的第一个开始遍历(size-index)个，就可以得到</span></span><br><span class="line">    <span class="comment">//5.如果找到了，就返回该节点，否则返回null</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HeroNode <span class="title">findLastIndexNode</span><span class="params">(HeroNode head,<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head.next==<span class="keyword">null</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;链表为空&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> size =getLength(head);</span><br><span class="line">        <span class="comment">//第二次遍历 size-index 位置</span></span><br><span class="line">        <span class="comment">//先做一个index校验</span></span><br><span class="line">        <span class="keyword">if</span>(index&lt;=<span class="number">0</span>||index&gt;size)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        HeroNode cur=head.next;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;size-index;i++)&#123;</span><br><span class="line">            cur=cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HeroNode <span class="title">getHead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取单链表中节点个数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> head</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getLength</span><span class="params">(HeroNode head)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head.next==<span class="keyword">null</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;链表为空&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> length=<span class="number">0</span>;</span><br><span class="line">        HeroNode cur=head.next;</span><br><span class="line">        <span class="keyword">while</span> (cur!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            length++;</span><br><span class="line">            cur=cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(HeroNode heroNode)</span></span>&#123;</span><br><span class="line">        HeroNode temp=head;</span><br><span class="line">        <span class="keyword">boolean</span> flag=<span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(temp.next==<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(temp.next.no&gt;heroNode.no)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (temp.next.no==heroNode.no)&#123;</span><br><span class="line">                flag=<span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            temp=temp.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">            System.out.printf(<span class="string">&quot;准备插入的英雄编号 %d 已经存在，不能添加\n&quot;</span>,heroNode.no);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            heroNode.next=temp.next;</span><br><span class="line">            temp.next=heroNode;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">List</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head.next==<span class="keyword">null</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;链表为空&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        HeroNode temp=head.next;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(temp==<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(temp);</span><br><span class="line">            temp=temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HeroNode</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> no;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> String nickname;</span><br><span class="line">    <span class="keyword">public</span> HeroNode next;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HeroNode</span><span class="params">(<span class="keyword">int</span> no,String name,String nickname)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.no=no;</span><br><span class="line">        <span class="keyword">this</span>.name=name;</span><br><span class="line">        <span class="keyword">this</span>.nickname=nickname;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;HeroNode&#123;no=&quot;</span> + no +<span class="string">&quot;, name=&quot;</span> + name  +<span class="string">&quot;, nickname=&quot;</span> + nickname + <span class="string">&quot;&#125;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="单链表的反转-腾讯面试题"><a class="markdownIt-Anchor" href="#单链表的反转-腾讯面试题">#</a> 单链表的反转 【腾讯面试题】</h3>
<p>思路分析</p>
<p><a href="https://imgtu.com/i/RwEYXq"><img src="https://z3.ax1x.com/2021/06/29/RwEYXq.png" alt="RwEYXq.png"></a></p>
<p><a href="https://imgtu.com/i/RwEgnx"><img src="https://z3.ax1x.com/2021/06/29/RwEgnx.png" alt="RwEgnx.png"></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.LinkedList04;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedListTestDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        HeroNode h1=<span class="keyword">new</span> HeroNode(<span class="number">1</span>,<span class="string">&quot;kono&quot;</span>,<span class="string">&quot;0ne&quot;</span>);</span><br><span class="line">        HeroNode h2=<span class="keyword">new</span> HeroNode(<span class="number">2</span>,<span class="string">&quot;alphonse&quot;</span>,<span class="string">&quot;two&quot;</span>);</span><br><span class="line">        HeroNode h3=<span class="keyword">new</span> HeroNode(<span class="number">3</span>,<span class="string">&quot;kino&quot;</span>,<span class="string">&quot;three&quot;</span>);</span><br><span class="line">        HeroNode h4=<span class="keyword">new</span> HeroNode(<span class="number">4</span>,<span class="string">&quot;mibius&quot;</span>,<span class="string">&quot;four&quot;</span>);</span><br><span class="line">        HeroNode h5=<span class="keyword">new</span> HeroNode(<span class="number">5</span>,<span class="string">&quot;Taro&quot;</span>,<span class="string">&quot;five&quot;</span>);</span><br><span class="line">        HeroNode h6=<span class="keyword">new</span> HeroNode(<span class="number">6</span>,<span class="string">&quot;Taiga&quot;</span>,<span class="string">&quot;six&quot;</span>);</span><br><span class="line">        LinkedList linkedList=<span class="keyword">new</span> LinkedList();</span><br><span class="line">        linkedList.add(h1);</span><br><span class="line">        linkedList.add(h2);</span><br><span class="line">        linkedList.add(h3);</span><br><span class="line">        linkedList.add(h4);</span><br><span class="line">        linkedList.add(h5);</span><br><span class="line">        linkedList.add(h6);</span><br><span class="line">        System.out.println(<span class="string">&quot;原链表&quot;</span>);</span><br><span class="line">        linkedList.List();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;反转后的链表&quot;</span>);</span><br><span class="line"></span><br><span class="line">        reversetList(linkedList.getHead());</span><br><span class="line"></span><br><span class="line">        linkedList.List();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将单链表反转 【腾讯面试题】</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reversetList</span><span class="params">(HeroNode head)</span></span>&#123;</span><br><span class="line">        <span class="comment">//1.如果当前链表为null，或者只有一个节点，则无需反转，直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (head.next==<span class="keyword">null</span> || head.next.next==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//定义一个辅助的指针(变量)，帮助我们遍历原来的链表</span></span><br><span class="line">        HeroNode cur=head.next;</span><br><span class="line">        HeroNode next=<span class="keyword">null</span>;<span class="comment">//指向当前节点【cur】的下一个节点</span></span><br><span class="line">        HeroNode reverseHead=<span class="keyword">new</span> HeroNode(<span class="number">0</span>,<span class="string">&quot;&quot;</span>,<span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="comment">//遍历原来的链表</span></span><br><span class="line">        <span class="comment">//每遍历一个节点，就将其取出，并放在新的链表reverseHead 的最前端</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">            next=cur.next;<span class="comment">//先暂时保存当前节点的下一个节点，因为后面需要使用</span></span><br><span class="line">            cur.next=reverseHead.next;<span class="comment">//将cur的下一个节点指向新的链表的最前端</span></span><br><span class="line">            reverseHead.next=cur;<span class="comment">//将cur 连接到新的链表上</span></span><br><span class="line">            cur=next;<span class="comment">//让cur后移</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将head.next 指向 reverseHead.next ，实现单链表的反转</span></span><br><span class="line">        head.next=reverseHead.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinkedList</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> HeroNode head=<span class="keyword">new</span> HeroNode(<span class="number">0</span>,<span class="string">&quot;&quot;</span>,<span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HeroNode <span class="title">getHead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(HeroNode heroNode)</span></span>&#123;</span><br><span class="line">        HeroNode temp=head;</span><br><span class="line">        <span class="keyword">boolean</span> flag=<span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(temp.next==<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(temp.next.no&gt;heroNode.no)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (temp.next.no==heroNode.no)&#123;</span><br><span class="line">                flag=<span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            temp=temp.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">            System.out.printf(<span class="string">&quot;准备插入的英雄编号 %d 已经存在，不能添加\n&quot;</span>,heroNode.no);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            heroNode.next=temp.next;</span><br><span class="line">            temp.next=heroNode;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">List</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head.next==<span class="keyword">null</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;链表为空&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        HeroNode temp=head.next;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(temp==<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(temp);</span><br><span class="line">            temp=temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HeroNode</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> no;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> String nickname;</span><br><span class="line">    <span class="keyword">public</span> HeroNode next;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HeroNode</span><span class="params">(<span class="keyword">int</span> no,String name,String nickname)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.no=no;</span><br><span class="line">        <span class="keyword">this</span>.name=name;</span><br><span class="line">        <span class="keyword">this</span>.nickname=nickname;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;HeroNode&#123;no=&quot;</span> + no +<span class="string">&quot;, name=&quot;</span> + name  +<span class="string">&quot;, nickname=&quot;</span> + nickname + <span class="string">&quot;&#125;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="从尾到头打印单链表百度面试题"><a class="markdownIt-Anchor" href="#从尾到头打印单链表百度面试题">#</a> 从尾到头打印单链表【百度面试题】</h3>
<p>思路</p>
<ul>
<li>方式一：先将单链表进行反转操作，然后再遍历即可，<strong>后果</strong>：会破坏原来单链表的结构，<strong>不建议</strong></li>
<li>方式二：可以利用栈这个数据结构，将各个节点压入到栈中，然后利用栈的<strong>先进后出</strong>的特点，就能实现逆序打印的效果（代码如下）</li>
</ul>
<p><a href="https://imgtu.com/i/RwEI9H"><img src="https://z3.ax1x.com/2021/06/29/RwEI9H.png" alt="RwEI9H.png"></a></p>
<p><a href="https://imgtu.com/i/RwEo3d"><img src="https://z3.ax1x.com/2021/06/29/RwEo3d.png" alt="RwEo3d.png"></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.LinkedList05;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedListTestDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        HeroNode h1=<span class="keyword">new</span> HeroNode(<span class="number">1</span>,<span class="string">&quot;kono&quot;</span>,<span class="string">&quot;0ne&quot;</span>);</span><br><span class="line">        HeroNode h2=<span class="keyword">new</span> HeroNode(<span class="number">2</span>,<span class="string">&quot;alphonse&quot;</span>,<span class="string">&quot;two&quot;</span>);</span><br><span class="line">        HeroNode h3=<span class="keyword">new</span> HeroNode(<span class="number">3</span>,<span class="string">&quot;kino&quot;</span>,<span class="string">&quot;three&quot;</span>);</span><br><span class="line">        HeroNode h4=<span class="keyword">new</span> HeroNode(<span class="number">4</span>,<span class="string">&quot;mibius&quot;</span>,<span class="string">&quot;four&quot;</span>);</span><br><span class="line">        HeroNode h5=<span class="keyword">new</span> HeroNode(<span class="number">5</span>,<span class="string">&quot;Taro&quot;</span>,<span class="string">&quot;five&quot;</span>);</span><br><span class="line">        HeroNode h6=<span class="keyword">new</span> HeroNode(<span class="number">6</span>,<span class="string">&quot;Taiga&quot;</span>,<span class="string">&quot;six&quot;</span>);</span><br><span class="line">        LinkedList linkedList=<span class="keyword">new</span> LinkedList();</span><br><span class="line">        linkedList.add(h1);</span><br><span class="line">        linkedList.add(h2);</span><br><span class="line">        linkedList.add(h3);</span><br><span class="line">        linkedList.add(h4);</span><br><span class="line">        linkedList.add(h5);</span><br><span class="line">        linkedList.add(h6);</span><br><span class="line">        System.out.println(<span class="string">&quot;原链表&quot;</span>);</span><br><span class="line">        linkedList.List();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;逆序打印，没有改变链表的结构&quot;</span>);</span><br><span class="line">        reversePrint(linkedList.getHead());</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;测试链表结构是否被破坏&quot;</span>);</span><br><span class="line">        linkedList.List();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//方式二：可以利用栈这个数据结构，将各个节点压入到栈中，然后利用栈的先进后出的特点，就能实现逆序打印的效果</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reversePrint</span><span class="params">(HeroNode head)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head.next==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;<span class="comment">//空链表，不能打印</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//创建要给一个栈，将各个节点压入栈</span></span><br><span class="line">        Stack&lt;HeroNode&gt; stack=<span class="keyword">new</span> Stack&lt;HeroNode&gt;();</span><br><span class="line">        HeroNode cur=head.next;</span><br><span class="line">        <span class="keyword">while</span> (cur!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            stack.push(cur);</span><br><span class="line">            cur=cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将链表的所有节点压入栈</span></span><br><span class="line">        <span class="keyword">while</span> (stack.size()&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//stack的特点是先进后出</span></span><br><span class="line">            System.out.println(stack.pop());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinkedList</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> HeroNode head=<span class="keyword">new</span> HeroNode(<span class="number">0</span>,<span class="string">&quot;&quot;</span>,<span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HeroNode <span class="title">getHead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(HeroNode heroNode)</span></span>&#123;</span><br><span class="line">        HeroNode temp=head;</span><br><span class="line">        <span class="keyword">boolean</span> flag=<span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(temp.next==<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(temp.next.no&gt;heroNode.no)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (temp.next.no==heroNode.no)&#123;</span><br><span class="line">                flag=<span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            temp=temp.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">            System.out.printf(<span class="string">&quot;准备插入的英雄编号 %d 已经存在，不能添加\n&quot;</span>,heroNode.no);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            heroNode.next=temp.next;</span><br><span class="line">            temp.next=heroNode;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">List</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head.next==<span class="keyword">null</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;链表为空&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        HeroNode temp=head.next;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(temp==<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(temp);</span><br><span class="line">            temp=temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HeroNode</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> no;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> String nickname;</span><br><span class="line">    <span class="keyword">public</span> HeroNode next;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HeroNode</span><span class="params">(<span class="keyword">int</span> no,String name,String nickname)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.no=no;</span><br><span class="line">        <span class="keyword">this</span>.name=name;</span><br><span class="line">        <span class="keyword">this</span>.nickname=nickname;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;HeroNode&#123;no=&quot;</span> + no +<span class="string">&quot;, name=&quot;</span> + name  +<span class="string">&quot;, nickname=&quot;</span> + nickname + <span class="string">&quot;&#125;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="双向链表"><a class="markdownIt-Anchor" href="#双向链表">#</a> 双向链表</h2>
<h3 id="思路分析"><a class="markdownIt-Anchor" href="#思路分析">#</a> 思路分析</h3>
<p><a href="https://imgtu.com/i/RweEp4"><img src="https://z3.ax1x.com/2021/06/29/RweEp4.png" alt="RweEp4.png"></a></p>
<p><a href="https://imgtu.com/i/RweikT"><img src="https://z3.ax1x.com/2021/06/29/RweikT.png" alt="RweikT.png"></a></p>
<p><a href="https://imgtu.com/i/Rweu0x"><img src="https://z3.ax1x.com/2021/06/29/Rweu0x.png" alt="Rweu0x.png"></a></p>
<p><a href="https://imgtu.com/i/Rwe89e"><img src="https://z3.ax1x.com/2021/06/29/Rwe89e.png" alt="Rwe89e.png"></a></p>
<p><a href="https://imgtu.com/i/RweG1H"><img src="https://z3.ax1x.com/2021/06/29/RweG1H.jpg" alt="RweG1H.jpg"></a></p>
<p>对上图的说明:</p>
<p>分析 双向链表的遍历，添加，修改，删除的操作思路 ===》代码实现</p>
<ul>
<li>
<p>遍历  和 单链表一样，只是可以向前，也可以向后查找</p>
</li>
<li>
<p>添加  (默认添加到双向链表的最后)</p>
</li>
</ul>
<p>(1)  先找到双向链表的最后这个节点</p>
<p>(2) temp.next = newHeroNode</p>
<p>(3) newHeroNode.pre = temp;</p>
<ul>
<li>
<p>修改  思路和 原来的单向链表一样.</p>
</li>
<li>
<p>删除</p>
</li>
</ul>
<p>(1)  因为是双向链表，因此，我们可以实现自我删除某个节点</p>
<p>(2)  直接找到要删除的这个节点，比如 temp</p>
<p>(3)  temp.pre.next = temp.next</p>
<p>(4) temp.next.pre = temp.pre;</p>
<h3 id="双向链表的代码实现"><a class="markdownIt-Anchor" href="#双向链表的代码实现">#</a> 双向链表的代码实现</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.DoubleLinkedList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DoubleLinkedListDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        HeroNode h1=<span class="keyword">new</span> HeroNode(<span class="number">1</span>,<span class="string">&quot;kino&quot;</span>,<span class="string">&quot;one&quot;</span>);</span><br><span class="line">        HeroNode h3=<span class="keyword">new</span> HeroNode(<span class="number">3</span>,<span class="string">&quot;kino&quot;</span>,<span class="string">&quot;three&quot;</span>);</span><br><span class="line">        HeroNode h4=<span class="keyword">new</span> HeroNode(<span class="number">4</span>,<span class="string">&quot;kino&quot;</span>,<span class="string">&quot;four&quot;</span>);</span><br><span class="line">        HeroNode h5=<span class="keyword">new</span> HeroNode(<span class="number">5</span>,<span class="string">&quot;kino&quot;</span>,<span class="string">&quot;five&quot;</span>);</span><br><span class="line">        HeroNode h7=<span class="keyword">new</span> HeroNode(<span class="number">7</span>,<span class="string">&quot;kino&quot;</span>,<span class="string">&quot;seven&quot;</span>);</span><br><span class="line"></span><br><span class="line">        DoubleLinkedList doubleLinkedList=<span class="keyword">new</span> DoubleLinkedList();</span><br><span class="line">        doubleLinkedList.add(h1);</span><br><span class="line">        doubleLinkedList.add(h4);</span><br><span class="line">        doubleLinkedList.add(h3);</span><br><span class="line">        doubleLinkedList.add(h5);</span><br><span class="line">        doubleLinkedList.add(h7);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;双向链表测试&quot;</span>);</span><br><span class="line"></span><br><span class="line">        doubleLinkedList.list();</span><br><span class="line">        System.out.println(<span class="string">&quot;=======================&quot;</span>);</span><br><span class="line"></span><br><span class="line">        HeroNode newHerNode=<span class="keyword">new</span> HeroNode(<span class="number">5</span>,<span class="string">&quot;kino00&quot;</span>,<span class="string">&quot;new&quot;</span>);</span><br><span class="line"></span><br><span class="line">        doubleLinkedList.update(newHerNode);</span><br><span class="line">        <span class="comment">//doubleLinkedList.list();</span></span><br><span class="line">        doubleLinkedList.del(<span class="number">7</span>);</span><br><span class="line">        doubleLinkedList.list();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DoubleLinkedList</span></span>&#123;</span><br><span class="line">    <span class="comment">//先初始化一个头节点，头节点不要动，不存放具体数据</span></span><br><span class="line">    <span class="keyword">private</span> HeroNode head=<span class="keyword">new</span> HeroNode(<span class="number">0</span>,<span class="string">&quot;&quot;</span>,<span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回头节点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HeroNode <span class="title">getHead</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历双链表</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">list</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//判断链表是否为null</span></span><br><span class="line">        <span class="keyword">if</span> (head.next==<span class="keyword">null</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;链表为null&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//因为头节点，不能动，因此我们需要一个辅助变量来遍历</span></span><br><span class="line">        HeroNode temp=head.next;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (temp==<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//输出节点信息</span></span><br><span class="line">            System.out.println(temp);</span><br><span class="line">            <span class="comment">//将temp后移，一定要小心</span></span><br><span class="line">            temp=temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加一个节点到双向链表的最后</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(HeroNode heroNode)</span></span>&#123;</span><br><span class="line">        <span class="comment">//因为头节点，不能动，因此我们需要一个辅助变量来遍历</span></span><br><span class="line">        HeroNode temp=head;</span><br><span class="line">        <span class="comment">//遍历链表，找到最后</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="comment">//找到链表最后</span></span><br><span class="line">            <span class="keyword">if</span>(temp.next==<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果没有找到最后，temp后移</span></span><br><span class="line">            temp=temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//当退出while循环时，temp就指向链表的最后</span></span><br><span class="line">        <span class="comment">//形成双向链表</span></span><br><span class="line">        temp.next=heroNode;</span><br><span class="line">        heroNode.pre=temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//修改一个节点的内容</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(HeroNode newHeroNode)</span></span>&#123;</span><br><span class="line">        <span class="comment">//因为头节点，不能动，因此我们需要一个辅助变量来遍历</span></span><br><span class="line">        HeroNode temp=head.next;</span><br><span class="line">        <span class="keyword">boolean</span> flag=<span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(temp==<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;<span class="comment">//已经遍历完链表</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(temp.no==newHeroNode.no)&#123;</span><br><span class="line">                flag=<span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            temp=temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">            temp.name=newHeroNode.name;</span><br><span class="line">            temp.nickname=newHeroNode.nickname;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.printf(<span class="string">&quot;没找到编号为%d的节点，不能修改\n&quot;</span>,newHeroNode);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从双向链表中删除一个节点</span></span><br><span class="line">    <span class="comment">//1.对于双向链表，可以直接找到删除节点</span></span><br><span class="line">    <span class="comment">//2.找到后直接删除即可</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> no)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断当前链表是否为空</span></span><br><span class="line">        <span class="keyword">if</span>(head.next==<span class="keyword">null</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;链表为null，无法删除&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//因为头节点，不能动，因此我们需要一个辅助变量来遍历</span></span><br><span class="line">        HeroNode temp=head.next;</span><br><span class="line">        <span class="keyword">boolean</span> flag=<span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(temp==<span class="keyword">null</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;链表为null&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(temp==<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;<span class="comment">//已经找到链表最后一个节点的下一个节点</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(temp.no==no)&#123;</span><br><span class="line">                flag=<span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            temp=temp.next;<span class="comment">//temo后移</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">            temp.pre.next=temp.next;</span><br><span class="line">            <span class="comment">//如果是最后一个节点，就不需要执行下面这句话，否则出现空指针异常</span></span><br><span class="line">            <span class="keyword">if</span>(temp.next!=<span class="keyword">null</span>) &#123;</span><br><span class="line">                temp.next.pre = temp.pre;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//双链表按照编号循序添加</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HeroNode</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> no;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> String nickname;</span><br><span class="line">    <span class="keyword">public</span> HeroNode next;<span class="comment">//指向下一个节点，默认为null</span></span><br><span class="line">    <span class="keyword">public</span> HeroNode pre;<span class="comment">//指向前一个节点，默认为null</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HeroNode</span><span class="params">(<span class="keyword">int</span> no, String name, String nickname)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.no = no;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.nickname = nickname;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//为了显示方便，我们重写toString</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;HeroNode&#123;no=&quot;</span> + no +<span class="string">&quot;, name=&quot;</span> + name +<span class="string">&quot;, nickname=&quot;</span> + nickname +<span class="string">&quot;&#125;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="单向环形链表"><a class="markdownIt-Anchor" href="#单向环形链表">#</a> 单向环形链表</h3>
<h4 id="单向环形链表介绍"><a class="markdownIt-Anchor" href="#单向环形链表介绍">#</a> 单向环形链表介绍</h4>
<p><a href="https://imgtu.com/i/RweJcd"><img src="https://z3.ax1x.com/2021/06/29/RweJcd.png" alt="RweJcd.png"></a></p>
<h4 id="josephu约瑟夫问题"><a class="markdownIt-Anchor" href="#josephu约瑟夫问题">#</a> Josephu (约瑟夫) 问题</h4>
<p>Ø<strong>Josephu</strong> <strong>问题</strong></p>
<p>Josephu 问题为：设编号为 1，2，… n 的 n 个人围坐一圈，约定编号为 k（1&lt;=k&lt;=n）的人从 1 开始报数，数到 m 的那个人出列，它的下一位又从 1 开始报数，数到 m 的那个人又出列，依次类推，直到所有人出列为止，由此产生一个出队编号的序列。</p>
<p>Ø<strong> 提示</strong></p>
<p>用一个不带头结点的循环链表来处理 Josephu 问题：先构成一个有 n 个结点的单循环链表，然后由 k 结点起从 1 开始计数，计到 m 时，对应结点从链表中删除，然后再从被删除结点的下一个结点又从 1 开始计数，直到最后一个结点从链表中删除算法结束。</p>
<p><a href="https://imgtu.com/i/RweUBt"><img src="https://z3.ax1x.com/2021/06/29/RweUBt.png" alt="RweUBt.png"></a></p>
<p><a href="https://imgtu.com/i/RwewAf"><img src="https://z3.ax1x.com/2021/06/29/RwewAf.png" alt="RwewAf.png"></a></p>
<p><a href="https://imgtu.com/i/Rwer9g"><img src="https://z3.ax1x.com/2021/06/29/Rwer9g.png" alt="Rwer9g.png"></a></p>
<h4 id="代码展示"><a class="markdownIt-Anchor" href="#代码展示">#</a> 代码展示</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.Josepfu;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Josepfu</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//测试一把，看是否构建环形链表 ，和是否能遍历</span></span><br><span class="line">        CircleSingleLinkedList circleSingleLinkedList = <span class="keyword">new</span> CircleSingleLinkedList();</span><br><span class="line">        circleSingleLinkedList.addBoy(<span class="number">5</span>);<span class="comment">//加入5个小孩节点</span></span><br><span class="line">        circleSingleLinkedList.showBoy();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//测试小孩出圈</span></span><br><span class="line">        circleSingleLinkedList.countBoy(<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个环形的单向链表</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CircleSingleLinkedList</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建一个first节点，当前没有编号</span></span><br><span class="line">    <span class="keyword">private</span> Boy first = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加小孩节点，构建一个环形的链表</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addBoy</span><span class="params">(<span class="keyword">int</span> nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//nums 做一个数据校验</span></span><br><span class="line">        <span class="keyword">if</span> (nums &lt; <span class="number">1</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;nums的值不正确&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//辅助节点，帮助构建环形链表</span></span><br><span class="line">        Boy curBoy = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//使用for来创建环形链表</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= nums; i++) &#123;</span><br><span class="line">            <span class="comment">//根据标号，创建小孩节点</span></span><br><span class="line">            Boy boy = <span class="keyword">new</span> Boy(i);</span><br><span class="line">            <span class="comment">//如果是第一个小孩</span></span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">1</span>) &#123;</span><br><span class="line">                first = boy;</span><br><span class="line">                first.setNext(first);<span class="comment">//构成环</span></span><br><span class="line">                curBoy = first;<span class="comment">//让curBoy指向第一个小孩</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                curBoy.setNext(boy);</span><br><span class="line">                boy.setNext(first);</span><br><span class="line">                curBoy = boy;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历当前的环形链表</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showBoy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//判断链表是否为null</span></span><br><span class="line">        <span class="keyword">if</span> (first == <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;链表为null&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//因为first不能动，使用一个辅助指针完成遍历</span></span><br><span class="line">        Boy curBoy = first;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            System.out.printf(<span class="string">&quot;小孩的编号%d \n&quot;</span>, curBoy.getNo());</span><br><span class="line">            <span class="keyword">if</span> (curBoy.getNext() == first) &#123;</span><br><span class="line">                <span class="comment">//说明已经遍历完毕</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            curBoy = curBoy.getNext();<span class="comment">//curBoy后移</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据用户的输入，计算出小孩出圈的顺序</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> startNo  表示第几个小孩开始数数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> countNum 表示数几下</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nums     表示最初有几个消灾在圈中</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">countBoy</span><span class="params">(<span class="keyword">int</span> startNo, <span class="keyword">int</span> countNum, <span class="keyword">int</span> nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//先对数据进行校验</span></span><br><span class="line">        <span class="keyword">if</span> (first == <span class="keyword">null</span> || startNo &lt; <span class="number">1</span> || startNo &gt; nums) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;参数输入有误，请重新输入&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//创建要给辅助指针，帮助完成小孩出圈</span></span><br><span class="line">        Boy helper = first;</span><br><span class="line">        <span class="comment">//要求创建一个辅助指针（helper），事先应该指向环形链表的最后这个节点</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (helper.getNext() == first) &#123;</span><br><span class="line">                <span class="comment">//说明helper指向最后小孩节点</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            helper = helper.getNext();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//小孩报数前，先让first 和 helper 移动 k-1 次（移动到k的身上）</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; startNo - <span class="number">1</span>; j++) &#123;</span><br><span class="line">            first = first.getNext();</span><br><span class="line">            helper = helper.getNext();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//当小孩报数时，让first 和 helper 指针同时的移动m-1次，然后出圈</span></span><br><span class="line">        <span class="comment">//这里是一个循环操作，直到圈中只有一个节点</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (helper == first) &#123;</span><br><span class="line">                <span class="comment">//说明圈中只有一个节点</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//让first 和helper 指针同时的移动countNum-1</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; countNum - <span class="number">1</span>; j++) &#123;</span><br><span class="line">                first = first.getNext();</span><br><span class="line">                helper = helper.getNext();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//此时first指向的节点，就是要出圈的小孩节点</span></span><br><span class="line">            System.out.printf(<span class="string">&quot;小孩%d出圈\n&quot;</span>, first.getNo());</span><br><span class="line">            <span class="comment">//这时将first指向的小孩节点出圈</span></span><br><span class="line">            first = first.getNext();</span><br><span class="line">            helper.setNext(first);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.printf(<span class="string">&quot;最后留在圈中的小孩编号%d\n&quot;</span>, first.getNo());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个Boy类，表示一个节点</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Boy</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> no;<span class="comment">//编号</span></span><br><span class="line">    <span class="keyword">private</span> Boy next;<span class="comment">//指向下一个节点，默认null</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Boy</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.no = no;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> no;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNo</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.no = no;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Boy <span class="title">getNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNext</span><span class="params">(Boy next)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>04.链表LinkedList</category>
      </categories>
      <tags>
        <tag>算法与数据结构</tag>
        <tag>单链表</tag>
        <tag>双链表</tag>
      </tags>
  </entry>
  <entry>
    <title>栈</title>
    <url>/2021/07/07/05.%E6%A0%88Stack/</url>
    <content><![CDATA[<h2 id="栈stack"><a class="markdownIt-Anchor" href="#栈stack">#</a> 栈 Stack</h2>
<h2 id="栈的简介"><a class="markdownIt-Anchor" href="#栈的简介">#</a> 栈的简介</h2>
<ol>
<li>
<p>栈的英文为 (stack)</p>
</li>
<li>
<p>栈是一个<strong>先入后出</strong> (FILO-First In Last Out) 的有序列表。</p>
</li>
<li>
<p>栈 (stack) 是限制线性表中元素的插入和删除<strong>只能在线性表的同一端</strong>进行的一种特殊线性表。允许插入和删除的一端，为变化的一端，称为<strong>栈顶</strong> (Top)，另一端为固定的一端，称为<strong>栈底</strong> (Bottom)。</p>
</li>
<li>
<p>根据栈的定义可知，最先放入栈中元素在栈底，最后放入的元素在栈顶，而删除元素刚好相反，最后放入的元素最先删除，最先放入的元素最后删除</p>
</li>
</ol>
<h2 id="出栈pop和入栈pus图显"><a class="markdownIt-Anchor" href="#出栈pop和入栈pus图显">#</a> 出栈 (pop) 和入栈 (pus)（图显）</h2>
<p><a href="https://imgtu.com/i/R7AXrQ"><img src="https://z3.ax1x.com/2021/07/06/R7AXrQ.png" alt="R7AXrQ.png"></a></p>
<p><a href="https://imgtu.com/i/R7E9P0"><img src="https://z3.ax1x.com/2021/07/06/R7E9P0.png" alt="R7E9P0.png"></a></p>
<h2 id="栈的应用场景"><a class="markdownIt-Anchor" href="#栈的应用场景">#</a> 栈的应用场景</h2>
<ol>
<li>子程序的调用：在跳往子程序前，会先将下个指令的地址存到堆栈中，直到子程序执行完后再将地址取出，以回到原来的程序中。</li>
<li>处理递归调用：和子程序的调用类似，只是除了储存下一个指令的地址外，也将参数、区域变量等数据存入堆栈中。</li>
<li>表达式的转换 [中缀表达式转后缀表达式] 与求值 (实际解决)。</li>
<li>二叉树的遍历。</li>
<li>图形的深度优先 (depth 一 first) 搜索法。</li>
</ol>
<h2 id="栈的快速入门"><a class="markdownIt-Anchor" href="#栈的快速入门">#</a> 栈的快速入门</h2>
<p><a href="https://imgtu.com/i/R7EkMF"><img src="https://z3.ax1x.com/2021/07/06/R7EkMF.png" alt="R7EkMF.png"></a></p>
<h3 id="代码展示数组模拟栈"><a class="markdownIt-Anchor" href="#代码展示数组模拟栈">#</a> 代码展示（数组模拟栈）</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> demo01;</span><br><span class="line"><span class="comment">//测试ArrayStack是否正确</span></span><br><span class="line">        <span class="comment">//创建一个ArrayStack对象表示  栈</span></span><br><span class="line">        ArrayStack stack = <span class="keyword">new</span> ArrayStack(<span class="number">4</span>);</span><br><span class="line">        String key=<span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">boolean</span> loop=<span class="keyword">true</span>;<span class="comment">//控制是否退出菜单</span></span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">while</span> (loop)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;show：表示显示栈&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;exit：表示显示栈&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;push：表示添加数据到栈（入栈）&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;pop：表示从栈中取出数据（出栈）&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;请输出你的选择&quot;</span>);</span><br><span class="line">            key=scanner.next();</span><br><span class="line">            <span class="keyword">switch</span> (key)&#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;show&quot;</span>:</span><br><span class="line">                    stack.list();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;exit&quot;</span>:</span><br><span class="line">                    scanner.close();</span><br><span class="line">                    loop=<span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;push&quot;</span>:</span><br><span class="line">                    System.out.println(<span class="string">&quot;请输入一个数&quot;</span>);</span><br><span class="line">                    <span class="keyword">int</span> value=scanner.nextInt();</span><br><span class="line">                    stack.push(value);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;pop&quot;</span>:</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">int</span> res=stack.pop();</span><br><span class="line">                        System.out.printf(<span class="string">&quot;出栈的数据是%d\n&quot;</span>,res);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        System.out.println(e.getMessage());</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                       <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;程序退出&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个ArrayStack 表示栈</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArrayStack</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxSize;<span class="comment">//栈的大小</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] stack;<span class="comment">//数组、数组模拟栈，数据就放在该数组里</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> top=-<span class="number">1</span>;<span class="comment">//top表示栈顶，初始值为-1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayStack</span><span class="params">(<span class="keyword">int</span> maxSize)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.maxSize = maxSize;</span><br><span class="line">        stack=<span class="keyword">new</span> <span class="keyword">int</span> [<span class="keyword">this</span>.maxSize];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//栈满</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFull</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> top==maxSize-<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//栈空</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> top==-<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//入栈-push</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">        <span class="comment">//先判断是否栈满</span></span><br><span class="line">        <span class="keyword">if</span>(isFull())&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;栈满&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        top++;</span><br><span class="line">        stack[top]=value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//出栈-pop,将栈顶的数据返回</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//先判断是否null</span></span><br><span class="line">        <span class="keyword">if</span>(isEmpty())&#123;</span><br><span class="line">            <span class="keyword">new</span> RuntimeException(<span class="string">&quot;栈空&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> value=stack[top];</span><br><span class="line">        top--;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//显示栈（遍历栈）</span></span><br><span class="line">    <span class="comment">//遍历是，需要从栈顶开始显示</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">list</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//判断是否栈空</span></span><br><span class="line">        <span class="keyword">if</span>(isEmpty())&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;栈空&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=top;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            System.out.printf(<span class="string">&quot;stack[%d]=%d\n&quot;</span>,i,stack[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="代码展示链表模拟栈练习"><a class="markdownIt-Anchor" href="#代码展示链表模拟栈练习">#</a> 代码展示（链表模拟栈）练习</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="栈实现综合计算器中缀表达式"><a class="markdownIt-Anchor" href="#栈实现综合计算器中缀表达式">#</a> 栈实现综合计算器 (中缀表达式)</h3>
<h4 id="思路分析图解"><a class="markdownIt-Anchor" href="#思路分析图解">#</a> 思路分析 (图解)</h4>
<p><a href="https://imgtu.com/i/R7EMRK"><img src="https://z3.ax1x.com/2021/07/06/R7EMRK.png" alt="R7EMRK.png"></a></p>
<h4 id="代码实现"><a class="markdownIt-Anchor" href="#代码实现">#</a> 代码实现</h4>
<p>先实现一位数运算，后实现多位数运算</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> demo02;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Calculator</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//完成表达式的运算</span></span><br><span class="line">        String expression=<span class="string">&quot;300+2*6-2&quot;</span>;</span><br><span class="line">        <span class="comment">//创建两个栈，数栈，符号栈</span></span><br><span class="line">        ArrayStack numStack=<span class="keyword">new</span> ArrayStack(<span class="number">10</span>);</span><br><span class="line">        ArrayStack operStack=<span class="keyword">new</span> ArrayStack(<span class="number">10</span>);</span><br><span class="line">        <span class="comment">//定义相关变量</span></span><br><span class="line">        <span class="keyword">int</span> index=<span class="number">0</span>;<span class="comment">//用于扫描</span></span><br><span class="line">        <span class="keyword">int</span> num1=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> num2=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> oper=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">char</span> ch=<span class="string">&#x27; &#x27;</span>;<span class="comment">//将每次扫描得到的char保存到ch中</span></span><br><span class="line">        String keepNum=<span class="string">&quot;&quot;</span>;<span class="comment">//用于拼接多位数</span></span><br><span class="line">        <span class="comment">//开始while循环的扫描expression</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="comment">//依次得到expression 的每一个字符</span></span><br><span class="line">            ch=expression.substring(index,index+<span class="number">1</span>).charAt(<span class="number">0</span>);</span><br><span class="line">            <span class="comment">//判断ch是什么，然后做相应的处理</span></span><br><span class="line">            <span class="comment">//如果是运算符</span></span><br><span class="line">            <span class="keyword">if</span>(operStack.isOper(ch))&#123;</span><br><span class="line">                <span class="comment">//如果是运算符；判断当前的符号栈是否为null</span></span><br><span class="line">                <span class="keyword">if</span>(!operStack.isEmpty())&#123;</span><br><span class="line">                    <span class="comment">//如果符号栈有操作符，就进行比较,如果当前的操作符的优先级小于或者等于栈中的操作符，</span></span><br><span class="line">                    <span class="comment">// 就需要从数栈中pop出两个数,在从符号栈中pop出一个符号，进行运算，将得到结果，入数栈，然后将当前的操作符入符号栈</span></span><br><span class="line">                    <span class="keyword">if</span>(operStack.priority(ch)&lt;=operStack.priority(operStack.peek()))&#123;</span><br><span class="line">                        num1=numStack.pop();</span><br><span class="line">                        num2=numStack.pop();</span><br><span class="line">                        oper=operStack.pop();</span><br><span class="line">                        res=numStack.cal(num1,num2,oper);</span><br><span class="line">                        <span class="comment">//把运算符的结果入数栈</span></span><br><span class="line">                        numStack.push(res);</span><br><span class="line">                        <span class="comment">//然后将当前的操作符入符号栈</span></span><br><span class="line">                        operStack.push(ch);</span><br><span class="line">                    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">//如果当前的操作符的优先级大于栈中的操作符</span></span><br><span class="line">                        operStack.push(ch);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//如果为null，直接入栈</span></span><br><span class="line">                    operStack.push(ch);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;<span class="comment">//如果是数字，则直接入数栈</span></span><br><span class="line">                <span class="comment">//numStack.push(ch-48);//? &quot;1+3&quot; &#x27;1&#x27; != 1</span></span><br><span class="line">                <span class="comment">//分析思路</span></span><br><span class="line">                <span class="comment">//1.当处理多位数时，不能发现是一个数就立即入栈，因为他可能是多位数</span></span><br><span class="line">                <span class="comment">//2.在处理数时，需要向expression的表达式的index，后看一位，如果是数就进行扫描，如果是符号才入栈</span></span><br><span class="line">                <span class="comment">//3.因此需要定义一个变量（字符串），用于拼接</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">//处理多位数</span></span><br><span class="line">                keepNum +=ch;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//如果ch已经是expression的最后一位，就直接入栈</span></span><br><span class="line">                <span class="keyword">if</span>(index==expression.length()-<span class="number">1</span>)&#123;</span><br><span class="line">                    numStack.push(Integer.parseInt(keepNum));</span><br><span class="line"></span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//判断下一个字符是不是数字，如果是数字，就继续扫描，如果是运算符，则入栈</span></span><br><span class="line">                    <span class="comment">//注意是看后一位，不是index++</span></span><br><span class="line">                    <span class="keyword">if</span>(operStack.isOper(expression.substring(index+<span class="number">1</span>,index+<span class="number">2</span>).charAt(<span class="number">0</span>)))&#123;</span><br><span class="line">                        <span class="comment">//如果后一位是运算符，则入栈keepNum=&quot;1&quot;或者&quot;123&quot;</span></span><br><span class="line">                        numStack.push(Integer.parseInt(keepNum));</span><br><span class="line">                        <span class="comment">//重要的！！！ ,清空keepNUm</span></span><br><span class="line">                        keepNum=<span class="string">&quot;&quot;</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//让index+1，并判断是否扫描到expression最后</span></span><br><span class="line">            index++;</span><br><span class="line">            <span class="keyword">if</span>(index&gt;=expression.length())&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//当表达式扫描完毕，按顺序的从 数栈和符号栈中pop出相应的数和符号，并运行</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(operStack.isEmpty())&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            num1=numStack.pop();</span><br><span class="line">            num2=numStack.pop();</span><br><span class="line">            oper=operStack.pop();</span><br><span class="line">            res=numStack.cal(num1,num2,oper);</span><br><span class="line">            <span class="comment">//把运算符的结果入数栈</span></span><br><span class="line">            numStack.push(res);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将数栈的最后数，pop出，就是结果</span></span><br><span class="line">        <span class="keyword">int</span> res2=numStack.pop();</span><br><span class="line">        System.out.printf(<span class="string">&quot;表达式%s=%d&quot;</span>,expression,res2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//先创建一个栈，直接使用前面创建好的</span></span><br><span class="line"><span class="comment">//定义一个ArrayStack 表示栈,需要扩展功能</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArrayStack</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxSize;<span class="comment">//栈的大小</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] stack;<span class="comment">//数组、数组模拟栈，数据就放在该数组里</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> top=-<span class="number">1</span>;<span class="comment">//top表示栈顶，初始值为-1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayStack</span><span class="params">(<span class="keyword">int</span> maxSize)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.maxSize = maxSize;</span><br><span class="line">        stack=<span class="keyword">new</span> <span class="keyword">int</span> [<span class="keyword">this</span>.maxSize];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//增加一个方法，可以返回当前栈顶的值，但是不是真正的pop</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">peek</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stack[top];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//栈满</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFull</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> top==maxSize-<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//栈空</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> top==-<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//入栈-push</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">        <span class="comment">//先判断是否栈满</span></span><br><span class="line">        <span class="keyword">if</span>(isFull())&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;栈满&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        top++;</span><br><span class="line">        stack[top]=value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//出栈-pop,将栈顶的数据返回</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//先判断是否null</span></span><br><span class="line">        <span class="keyword">if</span>(isEmpty())&#123;</span><br><span class="line">            <span class="keyword">new</span> RuntimeException(<span class="string">&quot;栈空&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> value=stack[top];</span><br><span class="line">        top--;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//显示栈（遍历栈）</span></span><br><span class="line">    <span class="comment">//遍历是，需要从栈顶开始显示数据</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">list</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//判断是否栈空</span></span><br><span class="line">        <span class="keyword">if</span>(isEmpty())&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;栈空&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=top;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            System.out.printf(<span class="string">&quot;stack[%d]=%d\n&quot;</span>,i,stack[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回运算符的优先级，优先级是程序员未确定，优先级用数字表示</span></span><br><span class="line">    <span class="comment">//数字越大，则优先级越高</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">priority</span><span class="params">(<span class="keyword">int</span> oper)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(oper == <span class="string">&#x27;*&#x27;</span>|| oper==<span class="string">&#x27;/&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(oper == <span class="string">&#x27;+&#x27;</span>|| oper==<span class="string">&#x27;-&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;<span class="comment">//假定目前的表达式只有+、-、*、/</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断是不是一个运算符</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isOper</span><span class="params">(<span class="keyword">char</span> val)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> val==<span class="string">&#x27;+&#x27;</span>||val==<span class="string">&#x27;-&#x27;</span>||val==<span class="string">&#x27;*&#x27;</span>||val==<span class="string">&#x27;/&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//计算方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">cal</span><span class="params">(<span class="keyword">int</span> num1,<span class="keyword">int</span> num2,<span class="keyword">int</span> oper)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;<span class="comment">//res 用于存放计算的结果</span></span><br><span class="line">        <span class="keyword">switch</span> (oper)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">                res=num1+num2;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">                res=num2-num1;<span class="comment">//注意顺序</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">                res=num1*num2;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>:</span><br><span class="line">                res=num2/num1;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="栈的三种表达式"><a class="markdownIt-Anchor" href="#栈的三种表达式">#</a> 栈的三种表达式</h2>
<ul>
<li>前缀表达式（波兰表达式）</li>
<li>中缀表达式</li>
<li>后缀表达式（逆波兰表达式）</li>
</ul>
<h3 id="前缀表达式"><a class="markdownIt-Anchor" href="#前缀表达式">#</a> 前缀表达式</h3>
<ul>
<li>前缀表达式又称为波兰式</li>
<li>前缀表达式的运算符位于操作数之前</li>
</ul>
<p>例如：(3+4)*5-6   对应的前缀表达式是：- * + 3 4 5 6</p>
<h4 id="前缀表达式的计算机求值"><a class="markdownIt-Anchor" href="#前缀表达式的计算机求值">#</a> 前缀表达式的计算机求值</h4>
<p>从右至左扫描表达式，遇到数字时，将数字压入堆栈，遇到运算符时，弹出栈顶的两个数，用运算符对它们做相应的计算（栈顶元素 和 次顶元素），并将结果入栈；重复上述过程直到表达式最左端，最后运算得出的值即为表达式的结果</p>
<p>例如: (3+4)×5-6 对应的前缀表达式就是 <strong>- × + 3 4 5 6 ,</strong> <strong>针对前缀表达式求值步骤如下:</strong></p>
<p>1) 从<strong>右至左扫描</strong>，将 6、5、4、3 压入堆栈</p>
<p>2) 遇到 + 运算符，因此弹出 3 和 4（3 为栈顶元素，4 为次顶元素），计算出 3+4 的值，得 7，再将 7 入栈</p>
<p>3) 接下来是 × 运算符，因此弹出 7 和 5，计算出 7×5=35，将 35 入栈</p>
<p>最后是 - 运算符，计算出 35-6 的值，即 29，由此得出最终结果</p>
<h3 id="中缀表达式"><a class="markdownIt-Anchor" href="#中缀表达式">#</a> 中缀表达式</h3>
<p>1) 中缀表达式就是<strong>常见的运算表达式</strong>，如 (3+4)×5-6</p>
<p>2) 中缀表达式的求值是我们人最熟悉的，但是对计算机来说却不好操作，因此，在计算结果时，往往会将中缀表达式转成其它表达式来操作 (一般转成后缀表达式.)</p>
<h3 id="后缀表达式"><a class="markdownIt-Anchor" href="#后缀表达式">#</a> 后缀表达式</h3>
<p>1) 后缀表达式又称<strong>逆波兰表达式</strong>，与前缀表达式相似，只是运算符位于操作数之后</p>
<p>2) 中举例说明： (3+4)×5-6 对应的后缀表达式就是 <strong>3 4 + 5 × 6 –</strong></p>
<p>例如：</p>
<p><a href="https://imgtu.com/i/R7E8qH"><img src="https://z3.ax1x.com/2021/07/06/R7E8qH.png" alt="R7E8qH.png"></a></p>
<h4 id="后缀表达式的计算机求值"><a class="markdownIt-Anchor" href="#后缀表达式的计算机求值">#</a> 后缀表达式的计算机求值</h4>
<p><strong>从左至右</strong>扫描表达式，遇到数字时，将数字压入堆栈，遇到运算符时，弹出栈顶的两个数，用运算符对它们做相应的计算（次顶元素 和 栈顶元素），并将结果入栈；重复上述过程直到表达式最右端，最后运算得出的值即为表达式的结果</p>
<p>例如: (3+4)×5-6 对应的后缀表达式就是 <strong>3 4 + 5 × 6 - ,</strong> <strong>针对后缀表达式求值步骤如下:</strong></p>
<p>1) 从左至右扫描，将 3 和 4 压入堆栈；</p>
<p>2) 遇到 + 运算符，因此弹出 4 和 3（4 为栈顶元素，3 为次顶元素），计算出 3+4 的值，得 7，再将 7 入栈；</p>
<p>3) 将 5 入栈；</p>
<p>4) 接下来是 × 运算符，因此弹出 5 和 7，计算出 7×5=35，将 35 入栈；</p>
<p>5) 将 6 入栈；</p>
<p>最后是 - 运算符，计算出 35-6 的值，即 29，由此得出最终结果</p>
<p><strong>我们完成一个逆波兰计算器，要求完成如下任务</strong>:</p>
<p>1)<strong> 输入一个逆波兰表达式</strong> (后缀表达式)<strong>，使用栈</strong> (Stack), <strong>计算其结果</strong></p>
<p>2)<strong> 支持小括号和多位数整数，因为这里我们主要讲的是数据结构，因此计算器进行简化，只支持对整数的计算。</strong></p>
<h4 id="代码实现-2"><a class="markdownIt-Anchor" href="#代码实现-2">#</a> 代码实现</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> demo3;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PolandNotation</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//先定义给逆波兰表达式</span></span><br><span class="line">        <span class="comment">//(30+4)*5-6 =&gt; 3 4 + 5 * 6 -</span></span><br><span class="line">        <span class="comment">//说明为了方便，逆波兰表达式的数字和符号使用空格隔开</span></span><br><span class="line">        String suffixExpression = <span class="string">&quot;30 4 + 5 * 6 -&quot;</span>;</span><br><span class="line">        <span class="comment">//思路</span></span><br><span class="line">        <span class="comment">//1.先将&quot;3 4 + 5 * 6 -&quot; =&gt; 放到ArrayList中</span></span><br><span class="line">        <span class="comment">//2.将ArrayList传递给一个方法，遍历ArrayList 配合栈完成计算</span></span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; list = getListString(suffixExpression);</span><br><span class="line">        System.out.println(<span class="string">&quot;list：&quot;</span>+list);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> res=calculate(list);</span><br><span class="line">        System.out.println(<span class="string">&quot;计算的结果是:&quot;</span>+res);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将一个逆波兰表达式，依次将数据和运算符放入到ArrayList中</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">getListString</span><span class="params">(String suffixExpression)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//将suffixExpression分割</span></span><br><span class="line">        String[] split = suffixExpression.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String ele : split) &#123;</span><br><span class="line">            list.add(ele);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//完成对逆波兰表达式的运算</span></span><br><span class="line">    <span class="comment">/*  (3+4)×5-6 对应的后缀表达式就是 3 4 + 5 × 6 - , 针对后缀表达式求值步骤如下:</span></span><br><span class="line"><span class="comment">        1.从左至右扫描，将3和4压入堆栈；</span></span><br><span class="line"><span class="comment">        2.遇到+运算符，因此弹出4和3（4为栈顶元素，3为次顶元素），计算出3+4的值，得7，再将7入栈；</span></span><br><span class="line"><span class="comment">        3.将5入栈；</span></span><br><span class="line"><span class="comment">        4.接下来是×运算符，因此弹出5和7，计算出7×5=35，将35入栈；</span></span><br><span class="line"><span class="comment">        5.将6入栈；</span></span><br><span class="line"><span class="comment">        6.最后是-运算符，计算出35-6的值，即29，由此得出最终结果</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">calculate</span><span class="params">(List&lt;String&gt; ls)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建给栈，只需一个栈即可</span></span><br><span class="line">        Stack&lt;String&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="comment">//遍历 ls</span></span><br><span class="line">        <span class="keyword">for</span> (String item : ls) &#123;</span><br><span class="line">            <span class="comment">//这里使用正则表达式来取出数</span></span><br><span class="line">            <span class="keyword">if</span> (item.matches(<span class="string">&quot;\\d+&quot;</span>)) &#123;<span class="comment">//匹配的是多位数</span></span><br><span class="line">                <span class="comment">//入栈</span></span><br><span class="line">                stack.push(item);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//pop出两个数，并运算，再入栈</span></span><br><span class="line">                <span class="keyword">int</span> num2 = Integer.parseInt(stack.pop());</span><br><span class="line">                <span class="keyword">int</span> num1 = Integer.parseInt(stack.pop());</span><br><span class="line">                <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (item.equals(<span class="string">&quot;+&quot;</span>)) &#123;</span><br><span class="line">                    res = num1 + num2;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (item.equals(<span class="string">&quot;-&quot;</span>)) &#123;</span><br><span class="line">                    res = num1 - num2;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (item.equals(<span class="string">&quot;*&quot;</span>)) &#123;</span><br><span class="line">                    res = num1 * num2;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (item.equals(<span class="string">&quot;/&quot;</span>)) &#123;</span><br><span class="line">                    res = num1 / num2;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span>  RuntimeException(<span class="string">&quot;运算符有误&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//把res 入栈</span></span><br><span class="line">                stack.push(res+<span class="string">&quot;&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//最后留在stack中的数便是运算结果</span></span><br><span class="line">        <span class="keyword">return</span> Integer.parseInt(stack.pop());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="中缀表达式转为后缀表达式"><a class="markdownIt-Anchor" href="#中缀表达式转为后缀表达式">#</a> 中缀表达式转为后缀表达式</h3>
<h4 id="思路分析"><a class="markdownIt-Anchor" href="#思路分析">#</a> 思路分析</h4>
<p><a href="https://imgtu.com/i/R7EDsg"><img src="https://z3.ax1x.com/2021/07/06/R7EDsg.png" alt="R7EDsg.png"></a></p>
<h4 id="代码实现-3"><a class="markdownIt-Anchor" href="#代码实现-3">#</a> 代码实现</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> demo04;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PolandNotation</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//完成将一个中缀表达式转成后缀表达式的功能</span></span><br><span class="line">        <span class="comment">//说明</span></span><br><span class="line">        <span class="comment">//1. 1+((2+3)*4)-5 =&gt; 转成1 2 3 + 4 * + 5 -</span></span><br><span class="line">        <span class="comment">//2. 因为直接对str进行操作，不方便，因此先将 &quot;1+((2+3)*4)-5&quot; =》中缀表达式对应的List</span></span><br><span class="line">        <span class="comment">//   即1+((2+3)*4)-5 =&gt; ArrayList[1,+,(,(,2,+,3,),*,4,),-,5]</span></span><br><span class="line">        <span class="comment">//3. 将得到的中缀表达式对应的List =&gt; 后缀表达式对应的List</span></span><br><span class="line">        <span class="comment">//  即 ArrayList[1,+,(,(,2,+,3,),*,4,),-,5]  =&gt; ArrayList[1,2,3,+,4,*,+,5,-]</span></span><br><span class="line"></span><br><span class="line">        String expression =<span class="string">&quot;1+((2+3)*4)-5&quot;</span>;</span><br><span class="line">        List&lt;String&gt; infixExpressionList = toInfixExpressionList(expression);</span><br><span class="line">        System.out.println(infixExpressionList); <span class="comment">//[1, +, (, (, 2, +, 3, ), *, 4, ), -, 5]</span></span><br><span class="line">        List&lt;String&gt; parseSuffixExpressionList = parseSuffixExpressionList(infixExpressionList);</span><br><span class="line">        System.out.println(parseSuffixExpressionList);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;++++++++++++++++++++++++++++++&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> calculate = calculate(parseSuffixExpressionList);</span><br><span class="line">        System.out.println(calculate);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        //先定义给逆波兰表达式</span></span><br><span class="line"><span class="comment">        //(30+4)*5-6 =&gt; 30 4 + 5 * 6 -</span></span><br><span class="line"><span class="comment">        //说明为了方便，逆波兰表达式的数字和符号使用空格隔开</span></span><br><span class="line"><span class="comment">        String suffixExpression = &quot;30 4 + 5 * 6 -&quot;;</span></span><br><span class="line"><span class="comment">        //思路</span></span><br><span class="line"><span class="comment">        //1.先将&quot;3 4 + 5 * 6 -&quot; =&gt; 放到ArrayList中</span></span><br><span class="line"><span class="comment">        //2.将ArrayList传递给一个方法，遍历ArrayList 配合栈完成计算</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        List&lt;String&gt; list = getListString(suffixExpression);</span></span><br><span class="line"><span class="comment">        System.out.println(&quot;list：&quot;+list);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        int res=calculate(list);</span></span><br><span class="line"><span class="comment">        System.out.println(&quot;计算的结果是:&quot;+res);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//将得到的中缀表达式对应的List =&gt; 后缀表达式对应的List</span></span><br><span class="line">    <span class="comment">//  即 ArrayList[1,+,(,(,2,+,3,),*,4,),-,5]  =&gt; ArrayList[1,2,3,+,4,*,+,5,-]</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">parseSuffixExpressionList</span><span class="params">(List&lt;String&gt; ls)</span></span>&#123;</span><br><span class="line">        <span class="comment">//定义两个栈</span></span><br><span class="line">        Stack&lt;String&gt; s1=<span class="keyword">new</span> Stack&lt;&gt;();<span class="comment">//符号栈</span></span><br><span class="line">        <span class="comment">//因为s2这个栈，在整个转换过程中，没有pop操作，而且后面还需要逆序输出</span></span><br><span class="line">        <span class="comment">//因此比较麻烦，所以就不用Stack&lt;String&gt; 直接使用List&lt;String&gt; s2</span></span><br><span class="line">        <span class="comment">//Stack&lt;String&gt; s2=new Stack&lt;&gt;();//存放中间结果的栈</span></span><br><span class="line">        List&lt;String&gt; s2= <span class="keyword">new</span> ArrayList&lt;&gt;();<span class="comment">//存放中间结果的List</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历ls</span></span><br><span class="line">        <span class="keyword">for</span>(String item:ls)&#123;</span><br><span class="line">            <span class="comment">//如果是一个数，就入s2</span></span><br><span class="line">            <span class="keyword">if</span>(item.matches(<span class="string">&quot;\\d+&quot;</span>))&#123;</span><br><span class="line">                s2.add(item);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(item.equals(<span class="string">&quot;(&quot;</span>))&#123;</span><br><span class="line">                s1.push(item);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(item.equals(<span class="string">&quot;)&quot;</span>))&#123;</span><br><span class="line">                <span class="comment">//) 如果是右括号“)”，则依次弹出s1栈顶的运算符，并压入s2，直到遇到左括号为止，此时将这一对括号丢弃</span></span><br><span class="line">                <span class="keyword">while</span> (!s1.peek().equals(<span class="string">&quot;(&quot;</span>))&#123;</span><br><span class="line">                    s2.add(s1.pop());</span><br><span class="line">                &#125;</span><br><span class="line">                s1.pop();<span class="comment">//!!!!将 &quot;(&quot; 弹出s1栈，消除小括号</span></span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//当item的优先级小于等于s1栈顶的运算符，将s1栈顶的运算符弹出并加入到s2中，再次转到（4.1）与s1中新的栈顶运算符相比较</span></span><br><span class="line">                <span class="comment">//缺少一个比较运算符优先级高低的方法</span></span><br><span class="line">                <span class="keyword">while</span> (s1.size()!=<span class="number">0</span> &amp;&amp; Operation.getValue(s1.peek())&gt;=Operation.getValue(item))&#123;</span><br><span class="line">                    s2.add(s1.pop());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//最后需要将item压入栈中</span></span><br><span class="line">                s1.push(item);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将s1中剩余的运算符依次弹出并加入s2</span></span><br><span class="line">        <span class="keyword">while</span> (s1.size()!=<span class="number">0</span>)&#123;</span><br><span class="line">            s2.add(s1.pop());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s2;<span class="comment">//注意因为是存放到List，因此按循序输出就是后缀表达式对应的list</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//将中缀表达式转换成对应的list</span></span><br><span class="line">    <span class="comment">//   即1+((2+3)*4)-5 =&gt; ArrayList[1,+,(,(,2,+,3,),*,4,),-,5]</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">toInfixExpressionList</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">        <span class="comment">//定义一个list，存放中缀表达式对应的内容</span></span><br><span class="line">        List&lt;String&gt; ls=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;<span class="comment">//这是一个指针，用于遍历 中缀表达式字符串</span></span><br><span class="line">        String str;<span class="comment">//对多位数的拼接</span></span><br><span class="line">        <span class="keyword">char</span> c;<span class="comment">//每遍历一个字符，就放入c</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="comment">//如果 c 是一个非数字，需要加入到ls</span></span><br><span class="line">            <span class="keyword">if</span>((c=s.charAt(i))&lt;<span class="number">48</span>||(c=s.charAt(i))&gt;<span class="number">57</span>)&#123;</span><br><span class="line">                ls.add(<span class="string">&quot;&quot;</span>+c);</span><br><span class="line">                i++;<span class="comment">//i需要后移</span></span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//如果是一个数，需要考虑多位数问题</span></span><br><span class="line">                str=<span class="string">&quot;&quot;</span>;<span class="comment">//先将str 置成 &quot;&quot; &#x27;0&#x27;[48] -&gt; &#x27;9&#x27;[57]</span></span><br><span class="line">                <span class="keyword">while</span> (i&lt;s.length() &amp;&amp; (c=s.charAt(i))&gt;=<span class="number">48</span> &amp;&amp; (c=s.charAt(i))&lt;=<span class="number">57</span>)&#123;</span><br><span class="line">                    str+=c;<span class="comment">//拼接</span></span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">                ls.add(str);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">while</span> (i&lt;s.length());</span><br><span class="line">        <span class="keyword">return</span> ls;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将一个逆波兰表达式，依次将数据和运算符放入到ArrayList中</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">getListString</span><span class="params">(String suffixExpression)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//将suffixExpression分割</span></span><br><span class="line">        String[] split = suffixExpression.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String ele : split) &#123;</span><br><span class="line">            list.add(ele);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//完成对逆波兰表达式的运算</span></span><br><span class="line">    <span class="comment">/*  (3+4)×5-6 对应的后缀表达式就是 3 4 + 5 × 6 - , 针对后缀表达式求值步骤如下:</span></span><br><span class="line"><span class="comment">        1.从左至右扫描，将3和4压入堆栈；</span></span><br><span class="line"><span class="comment">        2.遇到+运算符，因此弹出4和3（4为栈顶元素，3为次顶元素），计算出3+4的值，得7，再将7入栈；</span></span><br><span class="line"><span class="comment">        3.将5入栈；</span></span><br><span class="line"><span class="comment">        4.接下来是×运算符，因此弹出5和7，计算出7×5=35，将35入栈；</span></span><br><span class="line"><span class="comment">        5.将6入栈；</span></span><br><span class="line"><span class="comment">        6.最后是-运算符，计算出35-6的值，即29，由此得出最终结果</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">calculate</span><span class="params">(List&lt;String&gt; ls)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建给栈，只需一个栈即可</span></span><br><span class="line">        Stack&lt;String&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="comment">//遍历 ls</span></span><br><span class="line">        <span class="keyword">for</span> (String item : ls) &#123;</span><br><span class="line">            <span class="comment">//这里使用正则表达式来取出数</span></span><br><span class="line">            <span class="keyword">if</span> (item.matches(<span class="string">&quot;\\d+&quot;</span>)) &#123;<span class="comment">//匹配的是多位数</span></span><br><span class="line">                <span class="comment">//入栈</span></span><br><span class="line">                stack.push(item);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//pop出两个数，并运算，再入栈</span></span><br><span class="line">                <span class="keyword">int</span> num2 = Integer.parseInt(stack.pop());</span><br><span class="line">                <span class="keyword">int</span> num1 = Integer.parseInt(stack.pop());</span><br><span class="line">                <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (item.equals(<span class="string">&quot;+&quot;</span>)) &#123;</span><br><span class="line">                    res = num1 + num2;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (item.equals(<span class="string">&quot;-&quot;</span>)) &#123;</span><br><span class="line">                    res = num1 - num2;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (item.equals(<span class="string">&quot;*&quot;</span>)) &#123;</span><br><span class="line">                    res = num1 * num2;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (item.equals(<span class="string">&quot;/&quot;</span>)) &#123;</span><br><span class="line">                    res = num1 / num2;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span>  RuntimeException(<span class="string">&quot;运算符有误&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//把res 入栈</span></span><br><span class="line">                stack.push(res+<span class="string">&quot;&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//最后留在stack中的数便是运算结果</span></span><br><span class="line">        <span class="keyword">return</span> Integer.parseInt(stack.pop());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//编写一个类Operation 可以返回一个运算符，对应的优先级</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Operation</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> ADD = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> SUB = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> MUL = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> DIV = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//写一个方法，返回对应的优先级数字</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getValue</span><span class="params">(String operation)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result =<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">switch</span> (operation)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;+&quot;</span>:</span><br><span class="line">                result=ADD;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;-&quot;</span>:</span><br><span class="line">                result=SUB;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;*&quot;</span>:</span><br><span class="line">                result=MUL;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;/&quot;</span>:</span><br><span class="line">                result=DIV;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;不存在该运算符&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="完整代码实现包含小数点"><a class="markdownIt-Anchor" href="#完整代码实现包含小数点">#</a> 完整代码实现，包含小数点</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.reversepolishcal;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"><span class="keyword">import</span> java.util.regex.Pattern;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReversePolishMultiCalc</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	 <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 匹配 + - * / ( ) 运算符</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String SYMBOL = <span class="string">&quot;\\+|-|\\*|/|\\(|\\)&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String LEFT = <span class="string">&quot;(&quot;</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String RIGHT = <span class="string">&quot;)&quot;</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String ADD = <span class="string">&quot;+&quot;</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String MINUS= <span class="string">&quot;-&quot;</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String TIMES = <span class="string">&quot;*&quot;</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String DIVISION = <span class="string">&quot;/&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 加減 + -</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> LEVEL_01 = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 乘除 * /</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> LEVEL_02 = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 括号</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> LEVEL_HIGH = Integer.MAX_VALUE;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> Stack&lt;String&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="keyword">static</span> List&lt;String&gt; data = Collections.synchronizedList(<span class="keyword">new</span> ArrayList&lt;String&gt;());</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 去除所有空白符</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">replaceAllBlank</span><span class="params">(String s )</span></span>&#123;</span><br><span class="line">        <span class="comment">// \\s+ 匹配任何空白字符，包括空格、制表符、换页符等等, 等价于[ \f\n\r\t\v]</span></span><br><span class="line">        <span class="keyword">return</span> s.replaceAll(<span class="string">&quot;\\s+&quot;</span>,<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断是不是数字 int double long float</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isNumber</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">        Pattern pattern = Pattern.compile(<span class="string">&quot;^[-\\+]?[.\\d]*$&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> pattern.matcher(s).matches();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断是不是运算符</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isSymbol</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s.matches(SYMBOL);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 匹配运算等级</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">calcLevel</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">&quot;+&quot;</span>.equals(s) || <span class="string">&quot;-&quot;</span>.equals(s))&#123;</span><br><span class="line">            <span class="keyword">return</span> LEVEL_01;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">&quot;*&quot;</span>.equals(s) || <span class="string">&quot;/&quot;</span>.equals(s))&#123;</span><br><span class="line">            <span class="keyword">return</span> LEVEL_02;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> LEVEL_HIGH;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 匹配</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">doMatch</span> <span class="params">(String s)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s == <span class="keyword">null</span> || <span class="string">&quot;&quot;</span>.equals(s.trim())) <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;data is empty&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(!isNumber(s.charAt(<span class="number">0</span>)+<span class="string">&quot;&quot;</span>)) <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;data illeagle,start not with a number&quot;</span>);</span><br><span class="line"></span><br><span class="line">        s = replaceAllBlank(s);</span><br><span class="line"></span><br><span class="line">        String each;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(isSymbol(s.charAt(i)+<span class="string">&quot;&quot;</span>))&#123;</span><br><span class="line">                each = s.charAt(i)+<span class="string">&quot;&quot;</span>;</span><br><span class="line">                <span class="comment">//栈为空，(操作符，或者 操作符优先级大于栈顶优先级 &amp;&amp; 操作符优先级不是( )的优先级 及是 ) 不能直接入栈</span></span><br><span class="line">                <span class="keyword">if</span>(stack.isEmpty() || LEFT.equals(each)</span><br><span class="line">                        || ((calcLevel(each) &gt; calcLevel(stack.peek())) &amp;&amp; calcLevel(each) &lt; LEVEL_HIGH))&#123;</span><br><span class="line">                    stack.push(each);</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>( !stack.isEmpty() &amp;&amp; calcLevel(each) &lt;= calcLevel(stack.peek()))&#123;</span><br><span class="line">                    <span class="comment">//栈非空，操作符优先级小于等于栈顶优先级时出栈入列，直到栈为空，或者遇到了(，最后操作符入栈</span></span><br><span class="line">                    <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; calcLevel(each) &lt;= calcLevel(stack.peek()) )&#123;</span><br><span class="line">                        <span class="keyword">if</span>(calcLevel(stack.peek()) == LEVEL_HIGH)&#123;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        data.add(stack.pop());</span><br><span class="line">                    &#125;</span><br><span class="line">                    stack.push(each);</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(RIGHT.equals(each))&#123;</span><br><span class="line">                    <span class="comment">// ) 操作符，依次出栈入列直到空栈或者遇到了第一个)操作符，此时)出栈</span></span><br><span class="line">                    <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; LEVEL_HIGH &gt;= calcLevel(stack.peek()))&#123;</span><br><span class="line">                        <span class="keyword">if</span>(LEVEL_HIGH == calcLevel(stack.peek()))&#123;</span><br><span class="line">                            stack.pop();</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        data.add(stack.pop());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                start = i ;    <span class="comment">//前一个运算符的位置</span></span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>( i == s.length()-<span class="number">1</span> || isSymbol(s.charAt(i+<span class="number">1</span>)+<span class="string">&quot;&quot;</span>) )&#123;</span><br><span class="line">                each = start == <span class="number">0</span> ? s.substring(start,i+<span class="number">1</span>) : s.substring(start+<span class="number">1</span>,i+<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span>(isNumber(each)) &#123;</span><br><span class="line">                    data.add(each);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;data not match number&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果栈里还有元素，此时元素需要依次出栈入列，可以想象栈里剩下栈顶为/，栈底为+，应该依次出栈入列，可以直接翻转整个stack 添加到队列</span></span><br><span class="line">        Collections.reverse(stack);</span><br><span class="line">        data.addAll(<span class="keyword">new</span> ArrayList&lt;&gt;(stack));</span><br><span class="line"></span><br><span class="line">        System.out.println(data);</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 算出结果</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> list</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Double <span class="title">doCalc</span><span class="params">(List&lt;String&gt; list)</span></span>&#123;</span><br><span class="line">        Double d = <span class="number">0d</span>;</span><br><span class="line">        <span class="keyword">if</span>(list == <span class="keyword">null</span> || list.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (list.size() == <span class="number">1</span>)&#123;</span><br><span class="line">            System.out.println(list);</span><br><span class="line">            d = Double.valueOf(list.get(<span class="number">0</span>));</span><br><span class="line">            <span class="keyword">return</span> d;</span><br><span class="line">        &#125;</span><br><span class="line">        ArrayList&lt;String&gt; list1 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">            list1.add(list.get(i));</span><br><span class="line">            <span class="keyword">if</span>(isSymbol(list.get(i)))&#123;</span><br><span class="line">                Double d1 = doTheMath(list.get(i - <span class="number">2</span>), list.get(i - <span class="number">1</span>), list.get(i));</span><br><span class="line">                list1.remove(i);</span><br><span class="line">                list1.remove(i-<span class="number">1</span>);</span><br><span class="line">                list1.set(i-<span class="number">2</span>,d1+<span class="string">&quot;&quot;</span>);</span><br><span class="line">                list1.addAll(list.subList(i+<span class="number">1</span>,list.size()));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        doCalc(list1);</span><br><span class="line">        <span class="keyword">return</span> d;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 运算</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s1</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s2</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> symbol</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Double <span class="title">doTheMath</span><span class="params">(String s1,String s2,String symbol)</span></span>&#123;</span><br><span class="line">        Double result ;</span><br><span class="line">        <span class="keyword">switch</span> (symbol)&#123;</span><br><span class="line">            <span class="keyword">case</span> ADD : result = Double.valueOf(s1) + Double.valueOf(s2); <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> MINUS : result = Double.valueOf(s1) - Double.valueOf(s2); <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> TIMES : result = Double.valueOf(s1) * Double.valueOf(s2); <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> DIVISION : result = Double.valueOf(s1) / Double.valueOf(s2); <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span> : result = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//String math = &quot;9+(3-1)*3+10/2&quot;;</span></span><br><span class="line">        String math = <span class="string">&quot;12.8 + (2 - 3.55)*4+10/5.0&quot;</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            doCalc(doMatch(math));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>05.栈</category>
      </categories>
      <tags>
        <tag>算法与数据结构</tag>
        <tag>栈</tag>
        <tag>(后缀表达式)逆波兰表达式</tag>
      </tags>
  </entry>
  <entry>
    <title>排序算法</title>
    <url>/2021/07/07/07.%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h2 id="排序算法"><a class="markdownIt-Anchor" href="#排序算法">#</a> 排序算法</h2>
<h3 id="概念"><a class="markdownIt-Anchor" href="#概念">#</a> 概念</h3>
<p>排序也称排序算法 (Sort Algorithm)，排序是将一组数据，依指定的顺序进行排列的过程。</p>
<h3 id="排序的分类"><a class="markdownIt-Anchor" href="#排序的分类">#</a> 排序的分类</h3>
<h4 id="内部排序"><a class="markdownIt-Anchor" href="#内部排序">#</a> 内部排序</h4>
<p>指将需要处理的所有数据都加载到 ** 内部存储器 (内存)** 中进行排序。</p>
<h4 id="外部排序法"><a class="markdownIt-Anchor" href="#外部排序法">#</a> 外部排序法</h4>
<p>数据量过大，无法全部加载到内存中，需要借助 ** 外部存储 (文件等)** 进行排序。</p>
<p><a href="https://imgtu.com/i/R7VESf"><img src="https://z3.ax1x.com/2021/07/06/R7VESf.png" alt="R7VESf.png"></a></p>
<h3 id="算法的时间复杂度"><a class="markdownIt-Anchor" href="#算法的时间复杂度">#</a> 算法的时间复杂度</h3>
<h4 id="度量一个程序算法执行时间的两种方法"><a class="markdownIt-Anchor" href="#度量一个程序算法执行时间的两种方法">#</a> 度量一个程序 (算法) 执行时间的两种方法</h4>
<ol>
<li>
<p>事后统计的方法</p>
<ul>
<li>这种方法可行，但是有两个问题 ：</li>
<li>一是要想对设计的算法的运行性能进行评测，需要实际运行该程序；</li>
<li>二是所得时间的统计量依赖于计算机的硬件、软件等环境因素，<strong>这种方式，要在同一台计算机的相同状态下运行，才能比较那个算法速度更快</strong>。</li>
</ul>
</li>
<li>
<p>事前估算的方法</p>
<ul>
<li>通过分析某个算法的<strong>时间复杂度</strong>来判断哪个算法更优.</li>
</ul>
</li>
</ol>
<h4 id="时间频度"><a class="markdownIt-Anchor" href="#时间频度">#</a> 时间频度</h4>
<p>一个算法花费的时间与算法中语句的执行次数成正比例，哪个算法中语句执行次数多，它花费时间就多。<strong>一个算法中的语句执行次数称为语句频度或时间频度</strong>。记为 T (n)。</p>
<h5 id="1忽略常数项"><a class="markdownIt-Anchor" href="#1忽略常数项">#</a> &lt;1&gt; 忽略常数项</h5>
<p><a href="https://imgtu.com/i/R7Vuwj"><img src="https://z3.ax1x.com/2021/07/06/R7Vuwj.png" alt="R7Vuwj.png"></a></p>
<h5 id="2忽略低次项"><a class="markdownIt-Anchor" href="#2忽略低次项">#</a> &lt;2&gt; 忽略低次项</h5>
<p><a href="https://imgtu.com/i/R7VQkn"><img src="https://z3.ax1x.com/2021/07/06/R7VQkn.png" alt="R7VQkn.png"></a></p>
<h5 id="3忽略系数"><a class="markdownIt-Anchor" href="#3忽略系数">#</a> &lt;3&gt; 忽略系数</h5>
<p><a href="https://imgtu.com/i/R7VlYq"><img src="https://z3.ax1x.com/2021/07/06/R7VlYq.png" alt="R7VlYq.png"></a></p>
<h3 id="时间复杂度"><a class="markdownIt-Anchor" href="#时间复杂度">#</a> 时间复杂度</h3>
<h4 id="概念-2"><a class="markdownIt-Anchor" href="#概念-2">#</a> 概念</h4>
<ol>
<li>
<p>一般情况下，算法中的基本操作语句的重复执行次数是问题规模 n 的某个函数，用 T (n) 表示，若有某个辅助函数 f (n)，使得当 n 趋近于无穷大时，T (n) /f (n) 的极限值为不等于零的常数，则称 f (n) 是 T (n) 的同数量级函数。记作 T (n)=Ｏ( f (n) )，称Ｏ( f (n) ) 为算法的渐进时间复杂度，简称时间复杂度。</p>
</li>
<li>
<p>T (n) 不同，但时间复杂度可能相同。 如：T (n)=n²+7n+6 与 T (n)=3n²+2n+2 它们的 T (n) 不同，但时间复杂度相同，都为 O (n²)。</p>
</li>
</ol>
<h4 id="计算时间复杂度的方法"><a class="markdownIt-Anchor" href="#计算时间复杂度的方法">#</a> 计算时间复杂度的方法：</h4>
<ol>
<li>
<p>用常数 1 代替运行时间中的所有加法常数 T (n)=n²+7n+6 =&gt; T (n)=n²+7n+1</p>
</li>
<li>
<p>修改后的运行次数函数中，只保留最高阶项 T (n)=n²+7n+1 =&gt; T (n) = n²</p>
</li>
<li>
<p>去除最高阶项的系数 T (n) = n² =&gt;  T (n) = n² =&gt; O (n²)</p>
</li>
</ol>
<h4 id="常见的时间复杂度"><a class="markdownIt-Anchor" href="#常见的时间复杂度">#</a> 常见的时间复杂度</h4>
<p><a href="https://imgtu.com/i/R7VGlT"><img src="https://z3.ax1x.com/2021/07/06/R7VGlT.png" alt="R7VGlT.png"></a></p>
<h4 id="平均时间复杂度和最坏时间复杂度"><a class="markdownIt-Anchor" href="#平均时间复杂度和最坏时间复杂度">#</a> 平均时间复杂度和最坏时间复杂度</h4>
<ol>
<li>
<p>平均时间复杂度是指所有可能的输入实例均以等概率出现的情况下，该算法的运行时间。</p>
</li>
<li>
<p>最坏情况下的时间复杂度称最坏时间复杂度。一般讨论的时间复杂度均是最坏情况下的时间复杂度。 这样做的原因是：最坏情况下的时间复杂度是算法在任何输入实例上运行时间的界限，这就保证了算法的运行时间不会比最坏情况更长。</p>
</li>
<li>
<p>平均时间复杂度和最坏时间复杂度是否一致，和算法有关</p>
</li>
</ol>
<p><a href="https://imgtu.com/i/R7Vgne"><img src="https://z3.ax1x.com/2021/07/06/R7Vgne.png" alt="R7Vgne.png"></a></p>
<h3 id="空间复杂度"><a class="markdownIt-Anchor" href="#空间复杂度">#</a> 空间复杂度</h3>
<h4 id="简单介绍"><a class="markdownIt-Anchor" href="#简单介绍">#</a> 简单介绍</h4>
<ul>
<li>类似于时间复杂度的讨论，一个算法的空间复杂度 (Space Complexity) 定义为该算法所耗费的存储空间，它也是问题规模 n 的函数。</li>
<li>空间复杂度 (Space Complexity) 是对一个算法在运行过程中临时占用存储空间大小的量度。有的算法需要占用的临时工作单元数与解决问题的规模 n 有关，它随着 n 的增大而增大，当 n 较大时，将占用较多的存储单元，例如快速排序和归并排序算法就属于这种情况</li>
<li>在做算法分析时，<strong>主要讨论的是时间复杂度</strong>。从用户使用体验上看，更看重的程序执行的速度。一些缓存产品 (redis, memcache) 和算法 (基数排序) 本质就是<strong>用空间换时间</strong>.</li>
</ul>
<h1 id="八种基本排序算法"><a class="markdownIt-Anchor" href="#八种基本排序算法">#</a> 八种基本排序算法</h1>
<h2 id="1-冒泡排序"><a class="markdownIt-Anchor" href="#1-冒泡排序">#</a> 1、冒泡排序</h2>
<h3 id="思路分析"><a class="markdownIt-Anchor" href="#思路分析">#</a> 思路分析</h3>
<p><a href="https://imgtu.com/i/R7VfAA"><img src="https://z3.ax1x.com/2021/07/06/R7VfAA.png" alt="R7VfAA.png"></a></p>
<h3 id="代码实现"><a class="markdownIt-Anchor" href="#代码实现">#</a> 代码实现</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> demo1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BubbleSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//int[] arr = &#123;3, 9, -1, 10, 9&#125;;</span></span><br><span class="line">        <span class="comment">//System.out.println(&quot;排序前&quot;);</span></span><br><span class="line">        <span class="comment">//System.out.println(Arrays.toString(arr));</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] arr=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">80000</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">80000</span>; i++) &#123;</span><br><span class="line">            arr[i]=(<span class="keyword">int</span>)(Math.random() * <span class="number">80000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Date date=<span class="keyword">new</span> Date();</span><br><span class="line">        SimpleDateFormat simpleDateFormat = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">        String format = simpleDateFormat.format(date);</span><br><span class="line">        System.out.println(<span class="string">&quot;排序前时间：&quot;</span>+format);</span><br><span class="line"></span><br><span class="line">        bubbleSort(arr);</span><br><span class="line">        Date date1=<span class="keyword">new</span> Date();</span><br><span class="line">        String format1 = simpleDateFormat.format(date1);</span><br><span class="line">        System.out.println(<span class="string">&quot;排序后时间：&quot;</span>+format1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//System.out.println(&quot;排序后&quot;);</span></span><br><span class="line">        <span class="comment">//System.out.println(Arrays.toString(arr));</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        //为了容易理解，我们把冒泡排序的演变过程，展示出来</span></span><br><span class="line"><span class="comment">        //第一趟排序，就是将最大的数排在最后</span></span><br><span class="line"><span class="comment">        int temp=0;//临时变量</span></span><br><span class="line"><span class="comment">        for (int i = 0; i &lt; arr.length-1; i++) &#123;</span></span><br><span class="line"><span class="comment">            //如果前面的数比后面的数大，则交换</span></span><br><span class="line"><span class="comment">            if(arr[i]&gt;arr[i+1])&#123;</span></span><br><span class="line"><span class="comment">                temp=arr[i];</span></span><br><span class="line"><span class="comment">                arr[i]=arr[i+1];</span></span><br><span class="line"><span class="comment">                arr[i+1]=temp;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        System.out.println(&quot;第一次排序后的数组&quot;);</span></span><br><span class="line"><span class="comment">        System.out.println(Arrays.toString(arr));</span></span><br><span class="line"><span class="comment">        //第二趟排序，就是将第二大的数排在倒数第二位</span></span><br><span class="line"><span class="comment">        for (int i = 0; i &lt; arr.length-2; i++) &#123;</span></span><br><span class="line"><span class="comment">            //如果前面的数比后面的数大，则交换</span></span><br><span class="line"><span class="comment">            if(arr[i]&gt;arr[i+1])&#123;</span></span><br><span class="line"><span class="comment">                temp=arr[i];</span></span><br><span class="line"><span class="comment">                arr[i]=arr[i+1];</span></span><br><span class="line"><span class="comment">                arr[i+1]=temp;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        System.out.println(&quot;第二次排序后的数组&quot;);</span></span><br><span class="line"><span class="comment">        System.out.println(Arrays.toString(arr));</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        //第三趟排序，就是将第三大的数排在倒数第三位</span></span><br><span class="line"><span class="comment">        for (int i = 0; i &lt; arr.length-3; i++) &#123;</span></span><br><span class="line"><span class="comment">            //如果前面的数比后面的数大，则交换</span></span><br><span class="line"><span class="comment">            if(arr[i]&gt;arr[i+1])&#123;</span></span><br><span class="line"><span class="comment">                temp=arr[i];</span></span><br><span class="line"><span class="comment">                arr[i]=arr[i+1];</span></span><br><span class="line"><span class="comment">                arr[i+1]=temp;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        System.out.println(&quot;第三次排序后的数组&quot;);</span></span><br><span class="line"><span class="comment">        System.out.println(Arrays.toString(arr));</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        //第四趟排序，就是将第四大的数排在倒数第四位</span></span><br><span class="line"><span class="comment">        for (int i = 0; i &lt; arr.length-4; i++) &#123;</span></span><br><span class="line"><span class="comment">            //如果前面的数比后面的数大，则交换</span></span><br><span class="line"><span class="comment">            if(arr[i]&gt;arr[i+1])&#123;</span></span><br><span class="line"><span class="comment">                temp=arr[i];</span></span><br><span class="line"><span class="comment">                arr[i]=arr[i+1];</span></span><br><span class="line"><span class="comment">                arr[i+1]=temp;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        System.out.println(&quot;第四次排序后的数组&quot;);</span></span><br><span class="line"><span class="comment">        System.out.println(Arrays.toString(arr));</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">        <span class="comment">//冒泡排序的时间复杂度O(n^2)</span></span><br><span class="line">        <span class="keyword">int</span> temp = <span class="number">0</span>;<span class="comment">//临时变量</span></span><br><span class="line">        <span class="keyword">boolean</span> flag=<span class="keyword">false</span>;<span class="comment">//标识变量，标识是否进行交换</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; arr.length - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">                <span class="comment">//如果前面的数比后面的数大，则交换</span></span><br><span class="line">                <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                    flag=<span class="keyword">true</span>;</span><br><span class="line">                    temp = arr[j];</span><br><span class="line">                    arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">                    arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//System.out.println(&quot;第&quot;+(i+1)+&quot;次排序后的数组&quot;);</span></span><br><span class="line">            <span class="comment">//System.out.println(Arrays.toString(arr));</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(!flag)&#123;  <span class="comment">//在一趟排序中，一次交换都没有发生过</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                flag=<span class="keyword">false</span>;<span class="comment">//重置flag，进行下次判断</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="2-选择排序"><a class="markdownIt-Anchor" href="#2-选择排序">#</a> 2、选择排序</h2>
<h3 id="思路分析-2"><a class="markdownIt-Anchor" href="#思路分析-2">#</a> 思路分析</h3>
<p>选择排序（select sorting）也是一种简单的排序方法。</p>
<p>它的<strong>基本思想</strong>是：</p>
<p>第一次从 arr [0]~arr [n-1] 中选取最小值，与 arr [0] 交换，</p>
<p>第二次从 arr [1]~arr [n-1] 中选取最小值，与 arr [1] 交换，</p>
<p>第三次从 arr [2]~arr [n-1] 中选取最小值，与 arr [2] 交换，…，</p>
<p>第 i 次从 arr [i-1]~arr [n-1] 中选取最小值，与 arr [i-1] 交换，…,</p>
<p>第 n-1 次从 arr [n-2]~arr [n-1] 中选取最小值，与 arr [n-2] 交换，</p>
<p>总共通过 n-1 次，得到一个按排序码从小到大排列的有序序列。</p>
<p><a href="https://imgtu.com/i/R7VTc8"><img src="https://z3.ax1x.com/2021/07/06/R7VTc8.png" alt="R7VTc8.png"></a></p>
<p><a href="https://imgtu.com/i/R7VXAs"><img src="https://z3.ax1x.com/2021/07/06/R7VXAs.png" alt="R7VXAs.png"></a></p>
<h3 id="代码实现-2"><a class="markdownIt-Anchor" href="#代码实现-2">#</a> 代码实现</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> demo2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SelectSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] arr=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">80000</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">80000</span>; i++) &#123;</span><br><span class="line">            arr[i]=(<span class="keyword">int</span>)(Math.random() * <span class="number">80000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Date date=<span class="keyword">new</span> Date();</span><br><span class="line">        SimpleDateFormat simpleDateFormat = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">        String format = simpleDateFormat.format(date);</span><br><span class="line">        System.out.println(<span class="string">&quot;排序前时间：&quot;</span>+format);</span><br><span class="line"></span><br><span class="line">        slelctSort(arr);</span><br><span class="line">        Date date1=<span class="keyword">new</span> Date();</span><br><span class="line">        String format1 = simpleDateFormat.format(date1);</span><br><span class="line">        System.out.println(<span class="string">&quot;排序后时间：&quot;</span>+format1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//选择排序</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">slelctSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">        <span class="comment">//选择排序的时间复杂度O(n^2)</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length-<span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> minIndex = i;</span><br><span class="line">            <span class="keyword">int</span> min=arr[i];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; arr.length ; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(min&gt;arr[j])&#123;<span class="comment">//说明假定的最小值，并不是最小</span></span><br><span class="line">                    min=arr[j];<span class="comment">//重置min</span></span><br><span class="line">                    minIndex=j;<span class="comment">//重置minIndex</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (minIndex!=i)&#123;</span><br><span class="line">                arr[minIndex]=arr[i];</span><br><span class="line">                arr[i]=min;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        //使用逐步推导的方式来，讲解选择排序</span></span><br><span class="line"><span class="comment">        //第一轮</span></span><br><span class="line"><span class="comment">        //原始数组：101,34,119,1</span></span><br><span class="line"><span class="comment">        //第一轮排序：1,34,119,101</span></span><br><span class="line"><span class="comment">        //算法，先简单 --&gt;再复杂，就是可以把一个复杂的算法，拆分成简单的问题 --&gt;逐步解决</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        //第一轮</span></span><br><span class="line"><span class="comment">        int minIndex = 0;</span></span><br><span class="line"><span class="comment">        int min=arr[0];</span></span><br><span class="line"><span class="comment">        for(int j = 0+1;j&lt;arr.length;j++)&#123;</span></span><br><span class="line"><span class="comment">            if(min&gt;arr[j])&#123;//说明假定的最小值，并不是最小</span></span><br><span class="line"><span class="comment">                min=arr[j];//重置min</span></span><br><span class="line"><span class="comment">                minIndex=j;//重置minIndex</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        //将最小值，放在arr[0],即交换</span></span><br><span class="line"><span class="comment">        if(minIndex!=0)&#123;</span></span><br><span class="line"><span class="comment">            arr[minIndex]=arr[0];</span></span><br><span class="line"><span class="comment">            arr[0]=min;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        System.out.println(&quot;第一轮后···&quot;);</span></span><br><span class="line"><span class="comment">        System.out.println(Arrays.toString(arr));</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        //第二轮</span></span><br><span class="line"><span class="comment">        minIndex = 1;</span></span><br><span class="line"><span class="comment">        min=arr[1];</span></span><br><span class="line"><span class="comment">        for(int j = 1+1;j&lt;arr.length;j++)&#123;</span></span><br><span class="line"><span class="comment">            if(min&gt;arr[j])&#123;//说明假定的最小值，并不是最小</span></span><br><span class="line"><span class="comment">                min=arr[j];//重置min</span></span><br><span class="line"><span class="comment">                minIndex=j;//重置minIndex</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        //将最小值，放在arr[1],即交换</span></span><br><span class="line"><span class="comment">        if (minIndex != 1) &#123;</span></span><br><span class="line"><span class="comment">            arr[minIndex]=arr[1];</span></span><br><span class="line"><span class="comment">            arr[1]=min;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        System.out.println(&quot;第二轮后···&quot;);</span></span><br><span class="line"><span class="comment">        System.out.println(Arrays.toString(arr));</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        //第三轮</span></span><br><span class="line"><span class="comment">        minIndex = 2;</span></span><br><span class="line"><span class="comment">        min=arr[2];</span></span><br><span class="line"><span class="comment">        for(int j = 2+1;j&lt;arr.length;j++)&#123;</span></span><br><span class="line"><span class="comment">            if(min&gt;arr[j])&#123;//说明假定的最小值，并不是最小</span></span><br><span class="line"><span class="comment">                min=arr[j];//重置min</span></span><br><span class="line"><span class="comment">                minIndex=j;//重置minIndex</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        //将最小值，放在arr[2],即交换</span></span><br><span class="line"><span class="comment">        if (minIndex != 2) &#123;</span></span><br><span class="line"><span class="comment">            arr[minIndex]=arr[2];</span></span><br><span class="line"><span class="comment">            arr[2]=min;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        System.out.println(&quot;第三轮后···&quot;);</span></span><br><span class="line"><span class="comment">        System.out.println(Arrays.toString(arr));</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-插入排序"><a class="markdownIt-Anchor" href="#3-插入排序">#</a> 3、插入排序</h2>
<h3 id="思路分析-3"><a class="markdownIt-Anchor" href="#思路分析-3">#</a> 思路分析</h3>
<p>插入排序（Insertion Sorting）的<strong>基本思想</strong>是：</p>
<p>把 n 个待排序的元素看成为一个有序表和一个无序表，</p>
<p>开始时有序表中只包含一个元素，无序表中包含有 n-1 个元素，</p>
<p>排序过程中每次从无序表中取出第一个元素，</p>
<p>把它的排序码依次与有序表元素的排序码进行比较，将它插入到有序表中的适当位置，</p>
<p>使之成为新的有序表。</p>
<h3 id="r7vjnnpng"><a class="markdownIt-Anchor" href="#r7vjnnpng">#</a> <a href="https://imgtu.com/i/R7VjNn"><img src="https://z3.ax1x.com/2021/07/06/R7VjNn.png" alt="R7VjNn.png"></a> 代码实现</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> demo3;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InsertSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//        int[] arr = &#123;101, 34, 119, 1, -1, 88&#125;;</span></span><br><span class="line"><span class="comment">//        insertSort(arr);</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] arr=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">80000</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">80000</span>; i++) &#123;</span><br><span class="line">            arr[i]=(<span class="keyword">int</span>)(Math.random() * <span class="number">80000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Date date=<span class="keyword">new</span> Date();</span><br><span class="line">        SimpleDateFormat simpleDateFormat = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">        String format = simpleDateFormat.format(date);</span><br><span class="line">        System.out.println(<span class="string">&quot;排序前时间：&quot;</span>+format);</span><br><span class="line"></span><br><span class="line">        insertSort(arr);</span><br><span class="line"></span><br><span class="line">        Date date1=<span class="keyword">new</span> Date();</span><br><span class="line">        String format1 = simpleDateFormat.format(date1);</span><br><span class="line">        System.out.println(<span class="string">&quot;排序后时间：&quot;</span>+format1);</span><br><span class="line"></span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//插入排序</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> insertVal = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> insertIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//使用for循环简化代码</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//定义待插入的数</span></span><br><span class="line">            insertVal = arr[i];</span><br><span class="line">            insertIndex = i - <span class="number">1</span>;<span class="comment">//即arr[1]的前面这个数的下标</span></span><br><span class="line">            <span class="comment">//给insertVal找到插入队伍</span></span><br><span class="line">            <span class="comment">//说明</span></span><br><span class="line">            <span class="comment">//1.insertIndex &gt;= 0 保证在给insertVal找插入位置，不越界</span></span><br><span class="line">            <span class="comment">//2.insertVal &lt; arr[insertIndex] 待插入的数，还没找到插入的位置</span></span><br><span class="line">            <span class="comment">//3.就需要将arr[insertIndex] 后移</span></span><br><span class="line">            <span class="keyword">while</span> (insertIndex &gt;= <span class="number">0</span> &amp;&amp; insertVal &lt; arr[insertIndex]) &#123;</span><br><span class="line">                arr[insertIndex + <span class="number">1</span>] = arr[insertIndex];</span><br><span class="line">                insertIndex--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//当退出while循环时,说明插入的位置找到，insertIndex+1</span></span><br><span class="line">            <span class="comment">//这里判断是否需要赋值</span></span><br><span class="line">            <span class="keyword">if</span>(insertIndex+<span class="number">1</span>!=i)&#123;</span><br><span class="line">                arr[insertIndex + <span class="number">1</span>] = insertVal;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//System.out.printf(&quot;第%d轮插入&quot;,i);</span></span><br><span class="line">            <span class="comment">//System.out.println(Arrays.toString(arr));</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        //使用逐步推导的方式来讲解，便于理解</span></span><br><span class="line"><span class="comment">        //第一轮&#123;101,34,119,1&#125; =》&#123;34,101,119,1&#125;</span></span><br><span class="line"><span class="comment">        //定义待插入的数</span></span><br><span class="line"><span class="comment">        int insertVal = arr[1];</span></span><br><span class="line"><span class="comment">        int insertIndex = 1 - 1;//即arr[1]的前面这个数的下标</span></span><br><span class="line"><span class="comment">        //给insertVal找到插入队伍</span></span><br><span class="line"><span class="comment">        //说明</span></span><br><span class="line"><span class="comment">        //1.insertIndex &gt;= 0 保证在给insertVal找插入位置，不越界</span></span><br><span class="line"><span class="comment">        //2.insertVal &lt; arr[insertIndex] 待插入的数，还没找到插入的位置</span></span><br><span class="line"><span class="comment">        //3.就需要将arr[insertIndex] 后移</span></span><br><span class="line"><span class="comment">        while (insertIndex &gt;= 0 &amp;&amp; insertVal &lt; arr[insertIndex]) &#123;</span></span><br><span class="line"><span class="comment">            arr[insertIndex + 1] = arr[insertIndex];</span></span><br><span class="line"><span class="comment">            insertIndex--;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        //当退出while循环时,说明插入的位置找到，insertIndex+1</span></span><br><span class="line"><span class="comment">        arr[insertIndex + 1] = insertVal;</span></span><br><span class="line"><span class="comment">        System.out.printf(&quot;第1轮插入&quot;);</span></span><br><span class="line"><span class="comment">        System.out.println(Arrays.toString(arr));</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        //第2轮</span></span><br><span class="line"><span class="comment">        insertVal = arr[2];</span></span><br><span class="line"><span class="comment">        insertIndex = 2 - 1;</span></span><br><span class="line"><span class="comment">        while (insertIndex &gt;= 0 &amp;&amp; insertVal &lt; arr[insertIndex]) &#123;</span></span><br><span class="line"><span class="comment">            arr[insertIndex + 1] = arr[insertIndex];</span></span><br><span class="line"><span class="comment">            insertIndex--;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        arr[insertIndex + 1] = insertVal;</span></span><br><span class="line"><span class="comment">        System.out.printf(&quot;第2轮插入&quot;);</span></span><br><span class="line"><span class="comment">        System.out.println(Arrays.toString(arr));</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        //第3轮</span></span><br><span class="line"><span class="comment">        insertVal = arr[3];</span></span><br><span class="line"><span class="comment">        insertIndex = 3 - 1;</span></span><br><span class="line"><span class="comment">        while (insertIndex &gt;= 0 &amp;&amp; insertVal &lt; arr[insertIndex]) &#123;</span></span><br><span class="line"><span class="comment">            arr[insertIndex + 1] = arr[insertIndex];</span></span><br><span class="line"><span class="comment">            insertIndex--;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        arr[insertIndex + 1] = insertVal;</span></span><br><span class="line"><span class="comment">        System.out.printf(&quot;第3轮插入&quot;);</span></span><br><span class="line"><span class="comment">        System.out.println(Arrays.toString(arr));</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="4-希尔排序"><a class="markdownIt-Anchor" href="#4-希尔排序">#</a> 4、希尔排序</h2>
<h3 id="希尔排序法介绍"><a class="markdownIt-Anchor" href="#希尔排序法介绍">#</a> 希尔排序法介绍</h3>
<p>希尔排序是希尔（Donald Shell）于 1959 年提出的一种排序算法。希尔排序也是一种<strong>插入排序</strong>，它是简单插入排序经过改进之后的一个<strong>更高效的版本</strong>，也称为<strong>缩小增量排序</strong>。</p>
<h3 id="思路分析-4"><a class="markdownIt-Anchor" href="#思路分析-4">#</a> 思路分析</h3>
<p><strong>希尔排序法基本思想</strong></p>
<p>希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至 1 时，整个文件恰被分成一组，算法便终止</p>
<p><a href="https://imgtu.com/i/R7ZpcT"><img src="https://z3.ax1x.com/2021/07/06/R7ZpcT.png" alt="R7ZpcT.png"></a></p>
<p><a href="https://imgtu.com/i/R7Vz90"><img src="https://z3.ax1x.com/2021/07/06/R7Vz90.png" alt="R7Vz90.png"></a></p>
<h3 id="代码实现两种方法"><a class="markdownIt-Anchor" href="#代码实现两种方法">#</a> 代码实现 (两种方法)</h3>
<h4 id="交换法"><a class="markdownIt-Anchor" href="#交换法">#</a> 交换法</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> demo4;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShellSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//int[] arr = &#123;8, 9, 1, 7, 2, 3, 5, 4, 6, 0&#125;;</span></span><br><span class="line">        <span class="comment">//shellSort(arr);</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] arr=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">80000</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">80000</span>; i++) &#123;</span><br><span class="line">            arr[i]=(<span class="keyword">int</span>)(Math.random() * <span class="number">80000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Date date=<span class="keyword">new</span> Date();</span><br><span class="line">        SimpleDateFormat simpleDateFormat = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">        String format = simpleDateFormat.format(date);</span><br><span class="line">        System.out.println(<span class="string">&quot;排序前时间：&quot;</span>+format);</span><br><span class="line"></span><br><span class="line">        shellSort(arr);</span><br><span class="line"></span><br><span class="line">        Date date1=<span class="keyword">new</span> Date();</span><br><span class="line">        String format1 = simpleDateFormat.format(date1);</span><br><span class="line">        System.out.println(<span class="string">&quot;排序后时间：&quot;</span>+format1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//System.out.println(Arrays.toString(arr));</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shellSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//循环处理</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> gap = arr.length / <span class="number">2</span>; gap &gt; <span class="number">0</span>; gap /= <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = gap; i &lt; arr.length; i++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = i - gap; j &gt;= <span class="number">0</span>; j -= gap) &#123;</span><br><span class="line">                    <span class="comment">//如果当前元素大于加上步长后的那个元素，说明交换</span></span><br><span class="line">                    <span class="keyword">if</span> (arr[j] &gt; arr[j + gap]) &#123;</span><br><span class="line">                        temp = arr[j];</span><br><span class="line">                        arr[j] = arr[j + gap];</span><br><span class="line">                        arr[j + gap] = temp;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//System.out.println(&quot;第&quot; + (++count) + &quot;轮后&quot; + Arrays.toString(arr));</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        //使用逐步推导的方式逐步说明</span></span><br><span class="line"><span class="comment">        int temp = 0;</span></span><br><span class="line"><span class="comment">        //第一轮</span></span><br><span class="line"><span class="comment">        //因为第一轮排序是将10个数据分成了5组</span></span><br><span class="line"><span class="comment">        for (int i = 5; i &lt; arr.length; i++) &#123;</span></span><br><span class="line"><span class="comment">            //遍历各组中所有的元素（共5组，每组两个元素）</span></span><br><span class="line"><span class="comment">            for (int j = i - 5; j &gt;= 0; j -= 5) &#123;</span></span><br><span class="line"><span class="comment">                //如果当前元素大于加上步长后的那个元素，说明交换</span></span><br><span class="line"><span class="comment">                if (arr[j] &gt; arr[j + 5]) &#123;</span></span><br><span class="line"><span class="comment">                    temp = arr[j];</span></span><br><span class="line"><span class="comment">                    arr[j] = arr[j + 5];</span></span><br><span class="line"><span class="comment">                    arr[j + 5] = temp;</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        System.out.println(&quot;第1轮后&quot;+ Arrays.toString(arr));</span></span><br><span class="line"><span class="comment">        //第二轮排序</span></span><br><span class="line"><span class="comment">        //因为第二轮排序是将10个数据分成了2组</span></span><br><span class="line"><span class="comment">        for (int i = 2; i &lt; arr.length; i++) &#123;</span></span><br><span class="line"><span class="comment">            //遍历各组中所有的元素（共5组，每组两个元素）</span></span><br><span class="line"><span class="comment">            for (int j = i - 2; j &gt;= 0; j -= 2) &#123;</span></span><br><span class="line"><span class="comment">                //如果当前元素大于加上步长后的那个元素，说明交换</span></span><br><span class="line"><span class="comment">                if (arr[j] &gt; arr[j + 2]) &#123;</span></span><br><span class="line"><span class="comment">                    temp = arr[j];</span></span><br><span class="line"><span class="comment">                    arr[j] = arr[j + 2];</span></span><br><span class="line"><span class="comment">                    arr[j + 2] = temp;</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        System.out.println(&quot;第2轮后&quot;+ Arrays.toString(arr));</span></span><br><span class="line"><span class="comment">        //第三轮排序</span></span><br><span class="line"><span class="comment">        //因为第三轮排序是将10个数据分成了2/2=1组</span></span><br><span class="line"><span class="comment">        for (int i = 1; i &lt; arr.length; i++) &#123;</span></span><br><span class="line"><span class="comment">            //遍历各组中所有的元素（共5组，每组两个元素）</span></span><br><span class="line"><span class="comment">            for (int j = i - 1; j &gt;= 0; j -= 1) &#123;</span></span><br><span class="line"><span class="comment">                //如果当前元素大于加上步长后的那个元素，说明交换</span></span><br><span class="line"><span class="comment">                if (arr[j] &gt; arr[j + 1]) &#123;</span></span><br><span class="line"><span class="comment">                    temp = arr[j];</span></span><br><span class="line"><span class="comment">                    arr[j] = arr[j + 1];</span></span><br><span class="line"><span class="comment">                    arr[j + 1] = temp;</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        System.out.println(&quot;第3轮后&quot;+ Arrays.toString(arr));</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="移位法"><a class="markdownIt-Anchor" href="#移位法">#</a> 移位法</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> demo4;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShellSort1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//int[] arr = &#123;8, 9, 1, 7, 2, 3, 5, 4, 6, 0&#125;;</span></span><br><span class="line">        <span class="comment">//shellSort(arr);</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] arr=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">80000</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">80000</span>; i++) &#123;</span><br><span class="line">            arr[i]=(<span class="keyword">int</span>)(Math.random() * <span class="number">80000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Date date=<span class="keyword">new</span> Date();</span><br><span class="line">        SimpleDateFormat simpleDateFormat = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">        String format = simpleDateFormat.format(date);</span><br><span class="line">        System.out.println(<span class="string">&quot;排序前时间：&quot;</span>+format);</span><br><span class="line"></span><br><span class="line">        shellSort(arr);</span><br><span class="line"></span><br><span class="line">        Date date1=<span class="keyword">new</span> Date();</span><br><span class="line">        String format1 = simpleDateFormat.format(date1);</span><br><span class="line">        System.out.println(<span class="string">&quot;排序后时间：&quot;</span>+format1);</span><br><span class="line"></span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//对交换式的希尔排序进行优化 -&gt; 移位法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shellSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//常量gap，并逐渐的缩小常量</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> gap = arr.length / <span class="number">2</span>; gap &gt; <span class="number">0</span>; gap /= <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="comment">//从第gap个元素，逐个对其所在的组进行直接插入排序</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = gap; i &lt; arr.length; i++) &#123;</span><br><span class="line">                <span class="keyword">int</span> j=i;</span><br><span class="line">                <span class="keyword">int</span> temp =arr[j];</span><br><span class="line">                <span class="keyword">if</span>(arr[j]&lt;arr[j-gap])&#123;</span><br><span class="line">                    <span class="keyword">while</span> (j-gap&gt;=<span class="number">0</span>&amp;&amp;temp&lt;arr[j-gap])&#123;</span><br><span class="line">                        <span class="comment">//移动</span></span><br><span class="line">                        arr[j]=arr[j-gap];</span><br><span class="line">                        j-=gap;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//当退出while后，就给temp找到插入的位置</span></span><br><span class="line">                    arr[j]=temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="5-快速排序"><a class="markdownIt-Anchor" href="#5-快速排序">#</a> 5、快速排序</h2>
<h3 id="思路分析-5"><a class="markdownIt-Anchor" href="#思路分析-5">#</a> 思路分析</h3>
<p>** 快速排序（Quicksort）是对冒泡排序的一种改进。** 基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列</p>
<p><a href="https://imgtu.com/i/R7Zt8P"><img src="https://z3.ax1x.com/2021/07/06/R7Zt8P.jpg" alt="R7Zt8P.jpg"></a></p>
<h3 id="代码实现-3"><a class="markdownIt-Anchor" href="#代码实现-3">#</a> 代码实现</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> demo5;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuickSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//        int[] arr = &#123;-9, 78, 0, 23, -567, 70,-5,54,899,-155&#125;;</span></span><br><span class="line"><span class="comment">//        quickSort(arr, 0, arr.length - 1);</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;arr=&quot; + Arrays.toString(arr));</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] arr=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">80000</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">80000</span>; i++) &#123;</span><br><span class="line">            arr[i]=(<span class="keyword">int</span>)(Math.random() * <span class="number">80000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Date date=<span class="keyword">new</span> Date();</span><br><span class="line">        SimpleDateFormat simpleDateFormat = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">        String format = simpleDateFormat.format(date);</span><br><span class="line">        System.out.println(<span class="string">&quot;排序前时间：&quot;</span>+format);</span><br><span class="line"></span><br><span class="line">        quickSort(arr,<span class="number">0</span>,arr.length-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        Date date1=<span class="keyword">new</span> Date();</span><br><span class="line">        String format1 = simpleDateFormat.format(date1);</span><br><span class="line">        System.out.println(<span class="string">&quot;排序后时间：&quot;</span>+format1);</span><br><span class="line"></span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = left;   <span class="comment">//左小标</span></span><br><span class="line">        <span class="keyword">int</span> r = right;  <span class="comment">//右下标</span></span><br><span class="line">        <span class="comment">//pivot 中轴值</span></span><br><span class="line">        <span class="keyword">int</span> pivot = arr[(left + right) / <span class="number">2</span>];</span><br><span class="line">        <span class="keyword">int</span> temp = <span class="number">0</span>;<span class="comment">//临时变量，交换时使用</span></span><br><span class="line">        <span class="comment">//while循环的目的是让比pivot值小的放到左边</span></span><br><span class="line">        <span class="comment">//比pivot大的值放到右边</span></span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="comment">//在pivot的左边一直找，找到大于等于pivot值，才退出</span></span><br><span class="line">            <span class="keyword">while</span> (arr[l] &lt; pivot) &#123;</span><br><span class="line">                l += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//在pivot的右边一直找，找到小于等于pivot值，才退出</span></span><br><span class="line">            <span class="keyword">while</span> (arr[r] &gt; pivot) &#123;</span><br><span class="line">                r -= <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果 l &gt;= r 说明pivot 的左右两边的值，已经按照左边全部是小于等于pivot的值，右边全部是大于等于pivot的值</span></span><br><span class="line">            <span class="keyword">if</span> (l &gt;= r) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//交换</span></span><br><span class="line">            temp = arr[l];</span><br><span class="line">            arr[l] = arr[r];</span><br><span class="line">            arr[r] = temp;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//如果交换完后，发现这个arr[l]==pivot 值，相当于 r--，前移</span></span><br><span class="line">            <span class="keyword">if</span> (arr[l] == pivot) &#123;</span><br><span class="line">                r -= <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果交换完后，发现这个arr[r]==pivot 值，相当于 l++，前移</span></span><br><span class="line">            <span class="keyword">if</span> (arr[r] == pivot) &#123;</span><br><span class="line">                l += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果l==r,必须l++,r--,否则出现栈溢出</span></span><br><span class="line">        <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">            l += <span class="number">1</span>;</span><br><span class="line">            r -= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//向左递归</span></span><br><span class="line">        <span class="keyword">if</span> (left &lt; r) &#123;</span><br><span class="line">            quickSort(arr, left, r);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//向右递归</span></span><br><span class="line">        <span class="keyword">if</span> (right &gt; l) &#123;</span><br><span class="line">            quickSort(arr, l, right);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="6-归并排序"><a class="markdownIt-Anchor" href="#6-归并排序">#</a> 6、归并排序</h2>
<h3 id="思路分析-6"><a class="markdownIt-Anchor" href="#思路分析-6">#</a> 思路分析</h3>
<p><strong>归并排序思想示意图 1:</strong></p>
<p>归并排序（MERGE-SORT）是利用归并的思想实现的排序方法，该算法采用经典的分治（divide-and-conquer）策略（分治法将问题分 (divide) 成一些小的问题然后递归求解，而治 (conquer) 的阶段则将分的阶段得到的各答案 &quot;修补&quot; 在一起，即分而治之)。</p>
<p><a href="https://imgtu.com/i/R7ZdKS"><img src="https://z3.ax1x.com/2021/07/06/R7ZdKS.png" alt="R7ZdKS.png"></a></p>
<p><strong>可以看到这种结构很像一棵完全二叉树，本文的归并排序我们采用递归去实现（也可采用迭代的方式去实现）。分阶段可以理解为就是递归拆分子序列的过程。</strong></p>
<p><strong>归并排序思想示意图 2:</strong></p>
<p><strong>再来看看治阶段，我们需要将两个已经有序的子序列合并成一个有序序列，比如上图中的最后一次合并，要将 [4,5,7,8] 和 [1,2,3,6] 两个已经有序的子序列，合并为最终序列 [1,2,3,4,5,6,7,8]，来看下实现步骤</strong></p>
<p><a href="https://imgtu.com/i/R7Z6Cq"><img src="https://z3.ax1x.com/2021/07/06/R7Z6Cq.png" alt="R7Z6Cq.png"></a></p>
<p><a href="https://imgtu.com/i/R7ZWKU"><img src="https://z3.ax1x.com/2021/07/06/R7ZWKU.png" alt="R7ZWKU.png"></a></p>
<h3 id="代码实现-4"><a class="markdownIt-Anchor" href="#代码实现-4">#</a> 代码实现</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> demo6;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MergetSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//int[] arr = &#123;8, 4, 5, 7, 1, 3, 6, 2&#125;;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] arr=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">80000</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">80000</span>; i++) &#123;</span><br><span class="line">            arr[i]=(<span class="keyword">int</span>)(Math.random() * <span class="number">80000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Date date=<span class="keyword">new</span> Date();</span><br><span class="line">        SimpleDateFormat simpleDateFormat = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">        String format = simpleDateFormat.format(date);</span><br><span class="line">        System.out.println(<span class="string">&quot;排序前时间：&quot;</span>+format);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] temp=<span class="keyword">new</span> <span class="keyword">int</span>[arr.length];<span class="comment">//归并排序需要一个额外空间</span></span><br><span class="line">        mergeSort(arr,<span class="number">0</span>,arr.length-<span class="number">1</span>,temp);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Date date1=<span class="keyword">new</span> Date();</span><br><span class="line">        String format1 = simpleDateFormat.format(date1);</span><br><span class="line">        System.out.println(<span class="string">&quot;排序后时间：&quot;</span>+format1);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;归并排序后=&quot;</span>+ Arrays.toString(arr));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//分+合方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span>[] temp)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;<span class="comment">//中间索引</span></span><br><span class="line">            <span class="comment">//向左递归进行分解</span></span><br><span class="line">            mergeSort(arr, left, mid, temp);</span><br><span class="line">            <span class="comment">//向右递归进行分际</span></span><br><span class="line">            mergeSort(arr, mid+<span class="number">1</span>, right, temp);</span><br><span class="line">            <span class="comment">//合并</span></span><br><span class="line">            merge(arr,left,mid,right,temp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 合并的方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr   排序的原始数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> left  左边有序序列的初始索引</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> mid   中间索引</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> right 右边有序序列的初始索引</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> temp  做中转的数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> mid, <span class="keyword">int</span> right, <span class="keyword">int</span>[] temp)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//System.out.println(&quot;=========================&quot;);</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> i = left;<span class="comment">//初始化 i,左边有序序列的初始索引</span></span><br><span class="line">        <span class="keyword">int</span> j = mid + <span class="number">1</span>;<span class="comment">//初始化 j,右边有序序列的初始索引</span></span><br><span class="line">        <span class="keyword">int</span> t = <span class="number">0</span>; <span class="comment">//指向temp数组的当前索引</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//（一）</span></span><br><span class="line">        <span class="comment">//先把左右两边（有序）的数据按照规则填充到temp数组</span></span><br><span class="line">        <span class="comment">//直到左右两边的有序序列，有一边处理完毕</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= right) &#123;<span class="comment">//继续</span></span><br><span class="line">            <span class="comment">//如果左边的有序序列的当前元素，小于等于右边有序序列的当前元素</span></span><br><span class="line">            <span class="comment">//即将左边的当前元素，填充到temp数组</span></span><br><span class="line">            <span class="keyword">if</span> (arr[i] &lt;= arr[j]) &#123;</span><br><span class="line">                temp[t] = arr[i];</span><br><span class="line">                t += <span class="number">1</span>;</span><br><span class="line">                i += <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;<span class="comment">//反之，将右边有序序列的当前元素，填充到temp数组中</span></span><br><span class="line">                temp[t] = arr[j];</span><br><span class="line">                t += <span class="number">1</span>;</span><br><span class="line">                j += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//（二）</span></span><br><span class="line">        <span class="comment">//把有剩余数据的一边的数据依次全部填充到temp</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt;= mid) &#123;<span class="comment">//左边的有序序列还有剩余的元素，就全部填充到temp</span></span><br><span class="line">            temp[t] = arr[i];</span><br><span class="line">            t += <span class="number">1</span>;</span><br><span class="line">            i += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (j &lt;= right) &#123;<span class="comment">//右边的有序序列还有剩余的元素，就全部填充到temp</span></span><br><span class="line">            temp[t] = arr[j];</span><br><span class="line">            t += <span class="number">1</span>;</span><br><span class="line">            j += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//（三）</span></span><br><span class="line">        <span class="comment">//将temp数组的元素拷贝到arr</span></span><br><span class="line">        <span class="comment">//注意：并不是每次都拷贝数组中所有的元素</span></span><br><span class="line">        t = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> templeft = left;</span><br><span class="line">        <span class="comment">//第一次合并 templeft = 0，right = 1；</span></span><br><span class="line">        <span class="comment">//第二次合并 templeft = 2，right = 3；</span></span><br><span class="line">        <span class="comment">//第三次合并 templeft = 0，right = 3；</span></span><br><span class="line">        <span class="comment">// . . .</span></span><br><span class="line">        <span class="comment">//最后一次合并 templeft = 0，right = 7；</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//System.out.println(&quot;templeft=&quot;+templeft+&quot;,right&quot;+right);</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (templeft &lt;= right) &#123;</span><br><span class="line"></span><br><span class="line">            arr[templeft] = temp[t];</span><br><span class="line">            t += <span class="number">1</span>;</span><br><span class="line">            templeft += <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="7-基数排序桶排序的扩展"><a class="markdownIt-Anchor" href="#7-基数排序桶排序的扩展">#</a> 7、基数排序 (桶排序的扩展)</h2>
<h3 id="思路分析-7"><a class="markdownIt-Anchor" href="#思路分析-7">#</a> 思路分析</h3>
<ol>
<li>
<p><strong>基数排序</strong>（radix sort）属于 “分配式排序”（distribution sort），又称 “桶子法”（bucket sort）或 bin sort，顾名思义，它是通过键值的各个位的值，将要排序的<strong>元素分配</strong>至某些 “桶” 中，达到排序的作用</p>
</li>
<li>
<p>基数排序法是属于稳定性的排序，基数排序法的是效率高的稳定性排序法</p>
</li>
<li>
<p>基数排序 (Radix Sort) 是<strong>桶排序</strong>的扩展</p>
</li>
<li>
<p>基数排序是 1887 年赫尔曼・何乐礼发明的。它是这样实现的：将整数按位数切割成不同的数字，然后按每个位数分别比较。</p>
</li>
</ol>
<p><strong>基本思想</strong></p>
<ul>
<li>将所有待比较数值统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序，这样从最低位排序一直到最高位排序完成以后，数列就变成一个有序序列</li>
</ul>
<p><strong>图文解释</strong></p>
<p><a href="https://imgtu.com/i/R7ZIa9"><img src="https://z3.ax1x.com/2021/07/06/R7ZIa9.png" alt="R7ZIa9.png"></a></p>
<p><strong>基数排序的说明</strong></p>
<ol>
<li>
<p>基数排序是对传统桶排序的扩展，速度很快.</p>
</li>
<li>
<p>基数排序是经典的空间换时间的方式，占用内存很大，当对海量数据排序时，容易造成 OutOfMemoryError 。</p>
</li>
<li>
<p>基数排序时稳定的。[注：假定在待排序的记录序列中，存在多个具有相同的关键字的记录，若经过排序，这些记录的相对次序保持不变，即在原序列中，r [i]=r [j]，且 r [i] 在 r [j] 之前，而在排序后的序列中，r [i] 仍在 r [j] 之前，<strong>则称这种排序算法是稳定的；否则称为不稳定的</strong>]</p>
</li>
<li>
<p><strong>有负数的数组，我们不用基数排序来进行排序</strong> **,** <strong>如果要支持负数，参考</strong> **😗* <strong><a href="https://code.i-harness.com/zh-CN/q/e98fa9">https://code.i-harness.com/zh-CN/q/e98fa9</a></strong></p>
</li>
</ol>
<h3 id="代码实现-5"><a class="markdownIt-Anchor" href="#代码实现-5">#</a> 代码实现</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> demo7;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RadixSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//int[] arr = &#123;53, 3, 542, 748, 14, 214&#125;;</span></span><br><span class="line">        <span class="comment">//radixSort(arr);</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//80000 * 11 *4</span></span><br><span class="line">        <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">80000</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">80000</span>; i++) &#123;</span><br><span class="line">            arr[i] = (<span class="keyword">int</span>) (Math.random() * <span class="number">80000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Date date = <span class="keyword">new</span> Date();</span><br><span class="line">        SimpleDateFormat simpleDateFormat = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">        String format = simpleDateFormat.format(date);</span><br><span class="line">        System.out.println(<span class="string">&quot;排序前时间：&quot;</span> + format);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        radixSort(arr);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Date date1 = <span class="keyword">new</span> Date();</span><br><span class="line">        String format1 = simpleDateFormat.format(date1);</span><br><span class="line">        System.out.println(<span class="string">&quot;排序后时间：&quot;</span> + format1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//System.out.println(&quot;arr=&quot;+Arrays.toString(arr));</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//基数排序方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">radixSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//根据前面的推导过程，我们可以得到最终的基数排序代码</span></span><br><span class="line">        <span class="comment">//1.得到数组中最大的数的位数</span></span><br><span class="line">        <span class="keyword">int</span> max = arr[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] &gt; arr[<span class="number">0</span>]) &#123;</span><br><span class="line">                max = arr[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//得到最大数是几位数</span></span><br><span class="line">        <span class="keyword">int</span> maxLength = (max + <span class="string">&quot;&quot;</span>).length();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//定义一个二维数组，表示10个桶，每个桶都是一个一维数组</span></span><br><span class="line">        <span class="comment">//说明</span></span><br><span class="line">        <span class="comment">//1. 二维数组包含10个一维数组</span></span><br><span class="line">        <span class="comment">//2. 为了防止在放入数的时候，数据溢出，则每一个一维数组（桶），大小定为arr.length</span></span><br><span class="line">        <span class="comment">//3.明确，基数排序是使用空间换时间的经典算法</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[][] bucket = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>][arr.length];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//为了记录每个桶中，实际存放了多少个数据，我们定义一个一维数组来记录各个桶的每次放入的数据个数</span></span><br><span class="line">        <span class="comment">//可以这样理解</span></span><br><span class="line">        <span class="comment">//比如：buckerElementCounts[0]，记录的就是 bucket[0] 桶的放入数据个数</span></span><br><span class="line">        <span class="keyword">int</span>[] buckerElementCounts = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, n = <span class="number">1</span>; i &lt; maxLength; i++, n *= <span class="number">10</span>) &#123;</span><br><span class="line">            <span class="comment">//（针对每个元素对应的位进行排序处理），第一次是个位，第二次是十位，第三次是百位 依次类推</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">                <span class="comment">//取出每个元素对应位数的值</span></span><br><span class="line">                <span class="keyword">int</span> digitOfElement = arr[j] / n % <span class="number">10</span>;</span><br><span class="line">                <span class="comment">//放入到对应的桶中</span></span><br><span class="line">                bucket[digitOfElement][buckerElementCounts[digitOfElement]] = arr[j];</span><br><span class="line">                buckerElementCounts[digitOfElement]++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//按照这个桶的顺序（一维数组的下标依次取出数据，放回原来数组）</span></span><br><span class="line">            <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">//遍历每一个桶，并将桶中的数据，放回原来的数组中</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; buckerElementCounts.length; k++) &#123;</span><br><span class="line">                <span class="comment">//如果桶中，有数据，我们才放入到原数组中</span></span><br><span class="line">                <span class="keyword">if</span> (buckerElementCounts[k] != <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">//循环该桶即第k个桶（即第看个一维数组），放入</span></span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">0</span>; l &lt; buckerElementCounts[k]; l++) &#123;</span><br><span class="line">                        <span class="comment">//取出元素放入到arr</span></span><br><span class="line">                        arr[index++] = bucket[k][l];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//第 i+1 轮处理后需要将每个buckerElementCounts[k] 置零</span></span><br><span class="line">                buckerElementCounts[k] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//System.out.println(&quot;第&quot;+(i+1)+&quot;轮，对个位的排序处理arr = &quot; + Arrays.toString(arr));</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        //第一轮排序（针对每个元素的个位进行排序处理）</span></span><br><span class="line"><span class="comment">        //定义一个二维数组，表示10个桶，每个桶都是一个一维数组</span></span><br><span class="line"><span class="comment">        //说明</span></span><br><span class="line"><span class="comment">        //1. 二维数组包含10个一维数组</span></span><br><span class="line"><span class="comment">        //2. 为了防止在放入数的时候，数据溢出，则每一个一维数组（桶），大小定为arr.length</span></span><br><span class="line"><span class="comment">        //3.明确，基数排序是使用空间换时间的经典算法</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        int[][] bucket = new int[10][arr.length];</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        //为了记录每个桶中，实际存放了多少个数据，我们定义一个一维数组来记录各个桶的每次放入的数据个数</span></span><br><span class="line"><span class="comment">        //可以这样理解</span></span><br><span class="line"><span class="comment">        //比如：buckerElementCounts[0]，记录的就是 bucket[0] 桶的放入数据个数</span></span><br><span class="line"><span class="comment">        int[] buckerElementCounts = new int[10];</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        //第一轮（针对每个元素的个位进行排序处理）</span></span><br><span class="line"><span class="comment">        for (int j = 0; j &lt; arr.length; j++) &#123;</span></span><br><span class="line"><span class="comment">            //取出每个元素的个位的值</span></span><br><span class="line"><span class="comment">            int digitOfElement = arr[j] / 1 % 10;</span></span><br><span class="line"><span class="comment">            //放入到对应的桶中</span></span><br><span class="line"><span class="comment">            bucket[digitOfElement][buckerElementCounts[digitOfElement]] = arr[j];</span></span><br><span class="line"><span class="comment">            buckerElementCounts[digitOfElement]++;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        //按照这个桶的顺序（一维数组的下标依次取出数据，放回原来数组）</span></span><br><span class="line"><span class="comment">        int index = 0;</span></span><br><span class="line"><span class="comment">        //遍历每一个桶，并将桶中的数据，放回原来的数组中</span></span><br><span class="line"><span class="comment">        for (int k = 0; k &lt; buckerElementCounts.length; k++) &#123;</span></span><br><span class="line"><span class="comment">            //如果桶中，有数据，我们才放入到原数组中</span></span><br><span class="line"><span class="comment">            if (buckerElementCounts[k] != 0) &#123;</span></span><br><span class="line"><span class="comment">                //循环该桶即第k个桶（即第看个一维数组），放入</span></span><br><span class="line"><span class="comment">                for (int l = 0; l &lt; buckerElementCounts[k]; l++) &#123;</span></span><br><span class="line"><span class="comment">                    //取出元素放入到arr</span></span><br><span class="line"><span class="comment">                    arr[index++] = bucket[k][l];</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">            //第一轮处理后需要将每个buckerElementCounts[k] 置零</span></span><br><span class="line"><span class="comment">            buckerElementCounts[k] = 0;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        System.out.println(&quot;第一轮，对个位的排序处理arr = &quot; + Arrays.toString(arr));</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        //---------------------------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        //第二轮（针对每个元素的十位进行排序处理）</span></span><br><span class="line"><span class="comment">        for (int j = 0; j &lt; arr.length; j++) &#123;</span></span><br><span class="line"><span class="comment">            //取出每个元素的十位的值</span></span><br><span class="line"><span class="comment">            int digitOfElement = arr[j] / 10 % 10;</span></span><br><span class="line"><span class="comment">            //放入到对应的桶中</span></span><br><span class="line"><span class="comment">            bucket[digitOfElement][buckerElementCounts[digitOfElement]] = arr[j];</span></span><br><span class="line"><span class="comment">            buckerElementCounts[digitOfElement]++;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        //按照这个桶的顺序（一维数组的下标依次取出数据，放回原来数组）</span></span><br><span class="line"><span class="comment">        index = 0;</span></span><br><span class="line"><span class="comment">        //遍历每一个桶，并将桶中的数据，放回原来的数组中</span></span><br><span class="line"><span class="comment">        for (int k = 0; k &lt; buckerElementCounts.length; k++) &#123;</span></span><br><span class="line"><span class="comment">            //如果桶中，有数据，我们才放入到原数组中</span></span><br><span class="line"><span class="comment">            if (buckerElementCounts[k] != 0) &#123;</span></span><br><span class="line"><span class="comment">                //循环该桶即第k个桶（即第看个一维数组），放入</span></span><br><span class="line"><span class="comment">                for (int l = 0; l &lt; buckerElementCounts[k]; l++) &#123;</span></span><br><span class="line"><span class="comment">                    //取出元素放入到arr</span></span><br><span class="line"><span class="comment">                    arr[index++] = bucket[k][l];</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">            //第二轮处理后需要将每个buckerElementCounts[k] 置零</span></span><br><span class="line"><span class="comment">            buckerElementCounts[k] = 0;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        System.out.println(&quot;第二轮，对十位的排序处理arr = &quot; + Arrays.toString(arr));</span></span><br><span class="line"><span class="comment">        //---------------------------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        //第三轮（针对每个元素的百位进行排序处理）</span></span><br><span class="line"><span class="comment">        for (int j = 0; j &lt; arr.length; j++) &#123;</span></span><br><span class="line"><span class="comment">            //取出每个元素的百位的值</span></span><br><span class="line"><span class="comment">            int digitOfElement = arr[j] / 100 % 10;</span></span><br><span class="line"><span class="comment">            //放入到对应的桶中</span></span><br><span class="line"><span class="comment">            bucket[digitOfElement][buckerElementCounts[digitOfElement]] = arr[j];</span></span><br><span class="line"><span class="comment">            buckerElementCounts[digitOfElement]++;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        //按照这个桶的顺序（一维数组的下标依次取出数据，放回原来数组）</span></span><br><span class="line"><span class="comment">        index = 0;</span></span><br><span class="line"><span class="comment">        //遍历每一个桶，并将桶中的数据，放回原来的数组中</span></span><br><span class="line"><span class="comment">        for (int k = 0; k &lt; buckerElementCounts.length; k++) &#123;</span></span><br><span class="line"><span class="comment">            //如果桶中，有数据，我们才放入到原数组中</span></span><br><span class="line"><span class="comment">            if (buckerElementCounts[k] != 0) &#123;</span></span><br><span class="line"><span class="comment">                //循环该桶即第k个桶（即第看个一维数组），放入</span></span><br><span class="line"><span class="comment">                for (int l = 0; l &lt; buckerElementCounts[k]; l++) &#123;</span></span><br><span class="line"><span class="comment">                    //取出元素放入到arr</span></span><br><span class="line"><span class="comment">                    arr[index++] = bucket[k][l];</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">            //第三轮处理后需要将每个buckerElementCounts[k] 置零</span></span><br><span class="line"><span class="comment">            buckerElementCounts[k] = 0;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        System.out.println(&quot;第三轮，对百个位的排序处理arr = &quot; + Arrays.toString(arr));</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="8-堆排序未讲解"><a class="markdownIt-Anchor" href="#8-堆排序未讲解">#</a> 8、堆排序（未讲解）</h2>
<h3 id="思路分析-8"><a class="markdownIt-Anchor" href="#思路分析-8">#</a> 思路分析</h3>
<h3 id="代码实现-6"><a class="markdownIt-Anchor" href="#代码实现-6">#</a> 代码实现</h3>
<h2 id="基本排序算法的比较"><a class="markdownIt-Anchor" href="#基本排序算法的比较">#</a> 基本排序算法的比较</h2>
<ol>
<li><a href="https://imgtu.com/i/R7Zzad"><img src="https://z3.ax1x.com/2021/07/06/R7Zzad.png" alt="R7Zzad.png"></a><strong> 稳定</strong>：如果 a 原本在 b 前面，而 a=b，排序之后 a 仍然在 b 的前面；</li>
<li><strong>不稳定</strong>：如果 a 原本在 b 的前面，而 a=b，排序之后 a 可能会出现在 b 的后面；</li>
<li><strong>内排序</strong>：所有排序操作都在内存中完成；</li>
<li><strong>外排序</strong>：由于数据太大，因此把数据放在磁盘中，而排序通过磁盘和内存的数据传输才能进行；</li>
<li><strong>时间复杂度：</strong> 一个算法执行所耗费的时间。</li>
<li><strong>空间复杂度</strong>：运行完一个程序所需内存的大小。</li>
<li><strong>n:</strong> 数据规模</li>
<li><strong>k:</strong> “桶” 的个数</li>
<li><strong>In-place:</strong>  不占用额外内存</li>
<li><strong>Out-place:</strong> 占用额外内存</li>
</ol>
]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>07.排序算法</category>
      </categories>
      <tags>
        <tag>算法与数据结构</tag>
        <tag>排序算法</tag>
        <tag>冒泡排序</tag>
        <tag>时间复杂度</tag>
        <tag>选择排序</tag>
        <tag>插入排序</tag>
        <tag>希尔排序</tag>
        <tag>快速排序</tag>
        <tag>归并排序</tag>
        <tag>基数排序</tag>
        <tag>堆排序</tag>
      </tags>
  </entry>
  <entry>
    <title>树结构基础部分</title>
    <url>/2021/07/08/10.%E6%A0%91%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86/</url>
    <content><![CDATA[<h1 id="树"><a class="markdownIt-Anchor" href="#树">#</a> 树</h1>
<h2 id="三种存储方式的比较"><a class="markdownIt-Anchor" href="#三种存储方式的比较">#</a> 三种存储方式的比较</h2>
<ul>
<li>数组存储方式分析
<ul>
<li>优点：通过下标方式访问元素，速度快。<strong>对于有序数组</strong>，还可使用二分查找提高检索速度。</li>
<li>缺点：如果要检索具体某个值，或者插入值 (按一定顺序)<strong> 会整体移动</strong>，效率较低</li>
</ul>
</li>
<li>链表存储方式分析
<ul>
<li>优点：在一定程度上对数组存储方式有优化 (比如：插入一个数值节点，只需要将插入节点，链接到链表中即可， 删除效率也很好)</li>
<li>缺点：在进行检索时，效率仍然较低，比如 (检索某个值，需要从头节点开始遍历)</li>
</ul>
</li>
<li>树的存储方式分析
<ul>
<li>能提高数据<strong>存储，读取</strong>的效率，比如利用 <strong>二叉排序树</strong> (Binary Sort Tree)，既可以保证数据的检索速度，同时也可以保证数据的插入，删除，修改的速度。</li>
</ul>
</li>
</ul>
<p><a href="https://imgtu.com/i/R7mZ6K"><img src="https://z3.ax1x.com/2021/07/06/R7mZ6K.png" alt="R7mZ6K.png"></a></p>
<h2 id="树的示意图"><a class="markdownIt-Anchor" href="#树的示意图">#</a> 树的示意图</h2>
<p><a href="https://imgtu.com/i/R7mu0e"><img src="https://z3.ax1x.com/2021/07/06/R7mu0e.png" alt="R7mu0e.png"></a></p>
<h2 id="树的常用术语"><a class="markdownIt-Anchor" href="#树的常用术语">#</a> 树的常用术语</h2>
<ol>
<li>节点</li>
<li>根节点（root 节点）</li>
<li>父节点</li>
<li>子节点</li>
<li>叶子节点（没有子节点的节点）</li>
<li>节点的权（节点值）</li>
<li>路径（从 root 节点找到该节点的路线）</li>
<li>层</li>
<li>子树</li>
<li>树的高度（最大层数）</li>
<li>森林：多棵子树构成森林</li>
</ol>
<h1 id="二叉树"><a class="markdownIt-Anchor" href="#二叉树">#</a> 二叉树</h1>
<h2 id="二叉树的概念"><a class="markdownIt-Anchor" href="#二叉树的概念">#</a> 二叉树的概念</h2>
<ol>
<li>树的种类有很多，每个节点<strong>最多只能有两个子节点</strong>的<strong>一种</strong>形式称为<strong>二叉树</strong></li>
<li>二叉树的子节点分为左节点和右节点</li>
<li>如果该二叉树的所有叶子节点都在最后一层，并且结点总数 = 2^n -1 , n 为层数，则我们称为满二叉树。</li>
<li><a href="https://imgtu.com/i/R7mQkd"><img src="https://z3.ax1x.com/2021/07/06/R7mQkd.png" alt="R7mQkd.png"></a></li>
<li>如果该二叉树的所有叶子节点都在最后一层或者倒数第二层，而且最后一层的叶子节点在左边连续，倒数第二层的叶子节点在右边连续，我们成为完全二叉树</li>
<li><a href="https://imgtu.com/i/R7m1fI"><img src="https://z3.ax1x.com/2021/07/06/R7m1fI.png" alt="R7m1fI.png"></a></li>
</ol>
<h2 id="二叉树的遍历"><a class="markdownIt-Anchor" href="#二叉树的遍历">#</a> 二叉树的遍历</h2>
<ul>
<li>
<p>前序遍历：先输出父节点，再遍历左子树和右子树</p>
</li>
<li>
<p>中序遍历：先遍历左子树，再输出父节点，再遍历右子树</p>
</li>
<li>
<p>后序遍历：先遍历左子树，再遍历右子树，最后输出父节点</p>
</li>
<li>
<p>小结：看输出父节点的顺序，就确定是前序，中序还是后序</p>
</li>
</ul>
<p><a href="https://imgtu.com/i/R7mJ6f"><img src="https://z3.ax1x.com/2021/07/06/R7mJ6f.png" alt="R7mJ6f.png"></a></p>
<h3 id="代码展示"><a class="markdownIt-Anchor" href="#代码展示">#</a> 代码展示</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> demo01;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinaryTreeDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//先创建一棵二叉树</span></span><br><span class="line">        BinaryTree binaryTree=<span class="keyword">new</span> BinaryTree();</span><br><span class="line">        <span class="comment">//创建需要的节点</span></span><br><span class="line">        HeroNode root=<span class="keyword">new</span> HeroNode(<span class="number">1</span>,<span class="string">&quot;zoffy&quot;</span>);</span><br><span class="line">        HeroNode node2=<span class="keyword">new</span> HeroNode(<span class="number">2</span>,<span class="string">&quot;man&quot;</span>);</span><br><span class="line">        HeroNode node3=<span class="keyword">new</span> HeroNode(<span class="number">3</span>,<span class="string">&quot;taro&quot;</span>);</span><br><span class="line">        HeroNode node4=<span class="keyword">new</span> HeroNode(<span class="number">4</span>,<span class="string">&quot;taiga&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//先手动创建该二叉树，后面学习递归方式创建二叉树</span></span><br><span class="line">        root.setLeft(node2);</span><br><span class="line">        root.setRight(node3);</span><br><span class="line">        node3.setRight(node4);</span><br><span class="line">        binaryTree.setRoot(root);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//测试</span></span><br><span class="line">        System.out.println(<span class="string">&quot;前序遍历&quot;</span>);</span><br><span class="line">        binaryTree.preOrder();</span><br><span class="line">        System.out.println(<span class="string">&quot;中序遍历&quot;</span>);</span><br><span class="line">        binaryTree.infixOrder();</span><br><span class="line">        System.out.println(<span class="string">&quot;后序遍历&quot;</span>);</span><br><span class="line">        binaryTree.postOrder();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义BinaryTree 二叉树</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinaryTree</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> HeroNode root;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRoot</span><span class="params">(HeroNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.root=root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//前序遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.root!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">this</span>.root.preOrder();</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;二叉树为null，无法遍历&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//中序遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">infixOrder</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.root!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">this</span>.root.infixOrder();</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;二叉树为null，无法遍历&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//后序遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postOrder</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.root!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">this</span>.root.postOrder();</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;二叉树为null，无法遍历&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建HeroNode 节点</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HeroNode</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> no;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> HeroNode left;  <span class="comment">//默认为null</span></span><br><span class="line">    <span class="keyword">private</span> HeroNode right; <span class="comment">//默认为null</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HeroNode</span><span class="params">(<span class="keyword">int</span> no, String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.no = no;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> no;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNo</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.no = no;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HeroNode <span class="title">getLeft</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLeft</span><span class="params">(HeroNode left)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.left = left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HeroNode <span class="title">getRight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRight</span><span class="params">(HeroNode right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;HeroNode &#123; no=&quot;</span> + no + <span class="string">&quot;, name=&quot;</span> + name + <span class="string">&quot;&#125;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//编写前序遍历的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">this</span>);<span class="comment">//先输出根节点</span></span><br><span class="line">        <span class="comment">//递归向左子树前序遍历</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">this</span>.left.preOrder();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//递归向右子树前序遍历</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">this</span>.right.preOrder();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//中序遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">infixOrder</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//先递归向左子树中序遍历</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">this</span>.left.infixOrder();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//然后输出根节点</span></span><br><span class="line">        System.out.println(<span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">//递归向右子树中序遍历</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">this</span>.right.infixOrder();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//后序遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postOrder</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//先递归向左子树中序遍历</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">this</span>.left.postOrder();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//然后递归向右子树中序遍历</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">this</span>.right.postOrder();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//最后输出根节点</span></span><br><span class="line">        System.out.println(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="二叉树的查找"><a class="markdownIt-Anchor" href="#二叉树的查找">#</a> 二叉树的查找</h2>
<p><a href="https://imgtu.com/i/R7m0ts"><img src="https://z3.ax1x.com/2021/07/06/R7m0ts.png" alt="R7m0ts.png"></a></p>
<h3 id="代码展示-2"><a class="markdownIt-Anchor" href="#代码展示-2">#</a> 代码展示</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> demo02;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinaryTreeDemoSearch</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//先创建一棵二叉树</span></span><br><span class="line">        BinaryTree binaryTree=<span class="keyword">new</span> BinaryTree();</span><br><span class="line">        <span class="comment">//创建需要的节点</span></span><br><span class="line">        HeroNode root=<span class="keyword">new</span> HeroNode(<span class="number">1</span>,<span class="string">&quot;zoffy&quot;</span>);</span><br><span class="line">        HeroNode node2=<span class="keyword">new</span> HeroNode(<span class="number">2</span>,<span class="string">&quot;man&quot;</span>);</span><br><span class="line">        HeroNode node3=<span class="keyword">new</span> HeroNode(<span class="number">3</span>,<span class="string">&quot;taro&quot;</span>);</span><br><span class="line">        HeroNode node4=<span class="keyword">new</span> HeroNode(<span class="number">4</span>,<span class="string">&quot;taiga&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//先手动创建该二叉树，后面学习递归方式创建二叉树</span></span><br><span class="line">        root.setLeft(node2);</span><br><span class="line">        root.setRight(node3);</span><br><span class="line">        node3.setRight(node4);</span><br><span class="line">        binaryTree.setRoot(root);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//查找</span></span><br><span class="line">        System.out.println(<span class="string">&quot;前序查找&quot;</span>);</span><br><span class="line">        HeroNode node = binaryTree.preOrderSearch(<span class="number">3</span>);</span><br><span class="line">        <span class="keyword">if</span> (node!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            System.out.printf(<span class="string">&quot;找到了，信息为no=%d,name=%s&quot;</span>,node.getNo(), node.getName());</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;没找到&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义BinaryTree 二叉树</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinaryTree</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> HeroNode root;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRoot</span><span class="params">(HeroNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.root=root;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//前序查找</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HeroNode <span class="title">preOrderSearch</span><span class="params">(<span class="keyword">int</span> no)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> root.preOrderSearch(no);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//中序查找</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HeroNode <span class="title">infixOrderSearch</span><span class="params">(<span class="keyword">int</span> no)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> root.infixOrderSearch(no);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//后序查找</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HeroNode <span class="title">postOrderSearch</span><span class="params">(<span class="keyword">int</span> no)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> root.postOrderSearch(no);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建HeroNode 节点</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HeroNode</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> no;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> HeroNode left;  <span class="comment">//默认为null</span></span><br><span class="line">    <span class="keyword">private</span> HeroNode right; <span class="comment">//默认为null</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HeroNode</span><span class="params">(<span class="keyword">int</span> no, String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.no = no;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> no;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNo</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.no = no;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HeroNode <span class="title">getLeft</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLeft</span><span class="params">(HeroNode left)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.left = left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HeroNode <span class="title">getRight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRight</span><span class="params">(HeroNode right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;HeroNode &#123; no=&quot;</span> + no + <span class="string">&quot;, name=&quot;</span> + name + <span class="string">&quot;&#125;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//前序遍历查找</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> no    查找no</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>      如果找到就返回该Node，如果没有找到就返回 null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HeroNode <span class="title">preOrderSearch</span><span class="params">(<span class="keyword">int</span> no)</span></span>&#123;</span><br><span class="line">        <span class="comment">//比较当前节点是不是要查找的节点</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.no==no)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//1.判断当前节点的左子节点是否为 null，如果不为 null，则递归前序查找</span></span><br><span class="line">        <span class="comment">//2.如果左递归前序查找，找到节点，则返回</span></span><br><span class="line">        HeroNode resNode = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            resNode=<span class="keyword">this</span>.left.preOrderSearch(no);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (resNode!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">//说明找到了</span></span><br><span class="line">            <span class="keyword">return</span> resNode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//1.左递归前序查找，找到节点，则返回，否则继续判断</span></span><br><span class="line">        <span class="comment">//2.当前的节点的右子节点是否为null，如果不为 null，则继续向右递归前序查找</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            resNode=<span class="keyword">this</span>.right.preOrderSearch(no);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> resNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//中序遍历查找</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HeroNode <span class="title">infixOrderSearch</span><span class="params">(<span class="keyword">int</span> no)</span></span>&#123;</span><br><span class="line">        HeroNode resNode = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//判断当前节点的左子节点是否为null，如果不为null，则递归中序查找</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            resNode=<span class="keyword">this</span>.left.infixOrderSearch(no);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (resNode!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">//说明找到了</span></span><br><span class="line">            <span class="keyword">return</span> resNode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果找到，就返回，如果没找到就和当前节点比较，如果是则返回当前节点</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.no==no)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//否则继续进行右递归的中序查找</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            resNode=<span class="keyword">this</span>.right.infixOrderSearch(no);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> resNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//后序遍历查找</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HeroNode <span class="title">postOrderSearch</span><span class="params">(<span class="keyword">int</span> no)</span></span>&#123;</span><br><span class="line">        HeroNode resNode = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//判断当前节点的左子节点是否为null，如果不为null，则递归后序查找</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            resNode=<span class="keyword">this</span>.left.postOrderSearch(no);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (resNode!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">//说明在左子树找到</span></span><br><span class="line">            <span class="keyword">return</span> resNode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果左子树没有找到，就向右递归进行后序遍历查找</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            resNode=<span class="keyword">this</span>.right.postOrderSearch(no);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果左右子树都没有找到，就比较当前节点是不是</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.no==no)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> resNode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="二叉树的删除"><a class="markdownIt-Anchor" href="#二叉树的删除">#</a> 二叉树的删除</h2>
<p><a href="https://imgtu.com/i/R7ms10"><img src="https://z3.ax1x.com/2021/07/06/R7ms10.png" alt="R7ms10.png"></a></p>
<h3 id="代码展示-3"><a class="markdownIt-Anchor" href="#代码展示-3">#</a> 代码展示</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> demo03;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinaryTreeDemoDelete</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//先创建一棵二叉树</span></span><br><span class="line">        BinaryTree binaryTree = <span class="keyword">new</span> BinaryTree();</span><br><span class="line">        <span class="comment">//创建需要的节点</span></span><br><span class="line">        HeroNode root = <span class="keyword">new</span> HeroNode(<span class="number">1</span>, <span class="string">&quot;zoffy&quot;</span>);</span><br><span class="line">        HeroNode node2 = <span class="keyword">new</span> HeroNode(<span class="number">2</span>, <span class="string">&quot;man&quot;</span>);</span><br><span class="line">        HeroNode node3 = <span class="keyword">new</span> HeroNode(<span class="number">3</span>, <span class="string">&quot;taro&quot;</span>);</span><br><span class="line">        HeroNode node4 = <span class="keyword">new</span> HeroNode(<span class="number">4</span>, <span class="string">&quot;taiga&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//先手动创建该二叉树，后面学习递归方式创建二叉树</span></span><br><span class="line">        root.setLeft(node2);</span><br><span class="line">        root.setRight(node3);</span><br><span class="line">        node3.setRight(node4);</span><br><span class="line">        binaryTree.setRoot(root);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//测试删除</span></span><br><span class="line">        binaryTree.delNode(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义BinaryTree 二叉树</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinaryTree</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> HeroNode root;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRoot</span><span class="params">(HeroNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.root = root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delNode</span><span class="params">(<span class="keyword">int</span> no)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">//如果只有一个root节点，这里立即判断root是不是就是要删除的节点</span></span><br><span class="line">            <span class="keyword">if</span> (root.getNo()==no)&#123;</span><br><span class="line">                root=<span class="keyword">null</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                root.delNode(no);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;这个树是空树，不能删除~~~&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建HeroNode 节点</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HeroNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> no;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> HeroNode left;  <span class="comment">//默认为null</span></span><br><span class="line">    <span class="keyword">private</span> HeroNode right; <span class="comment">//默认为null</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HeroNode</span><span class="params">(<span class="keyword">int</span> no, String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.no = no;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> no;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNo</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.no = no;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HeroNode <span class="title">getLeft</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLeft</span><span class="params">(HeroNode left)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.left = left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HeroNode <span class="title">getRight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRight</span><span class="params">(HeroNode right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;HeroNode &#123; no=&quot;</span> + no + <span class="string">&quot;, name=&quot;</span> + name + <span class="string">&quot;&#125;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//递归删除节点</span></span><br><span class="line">    <span class="comment">//1.如果删除的节点是叶子节点，则删除该节点</span></span><br><span class="line">    <span class="comment">//2.如归删除的节点是非叶子节点，则删除该子树</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delNode</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 思路：</span></span><br><span class="line"><span class="comment">         * 1.因为我们的二叉树是单向的，所以我们是判断当前节点的子节点是否需要删除节点，而不能去判断当前这个节点是不是需要删除节点</span></span><br><span class="line"><span class="comment">         * 2.如果当前节点的左子节点不为空，而且左子节点就是要删除节点，就将this.left = null；并且就返回（结束递归删除）</span></span><br><span class="line"><span class="comment">         * 3.如果当前节点的右子节点不为空，并且右子节点就是要删除节点，就将this.right= null；并且就返回（结束递归删除）</span></span><br><span class="line"><span class="comment">         * 4.如果第2步和第3步没有删除节点，那么我们就需要向左子树进行递归删除</span></span><br><span class="line"><span class="comment">         * 5.如果第4步也没有删除节点应当向右子树进行递归删除</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">//2.如果当前节点的左子节点不为空，而且左子节点就是要删除节点，就将this.left = null；并且就返回（结束递归删除）</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.left != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.left.no == no) &#123;</span><br><span class="line">            <span class="keyword">this</span>.left = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3.如果当前节点的右子节点不为空，并且右子节点就是要删除节点，就将this.right= null；并且就返回（结束递归删除）</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.right != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.right.no == no) &#123;</span><br><span class="line">            <span class="keyword">this</span>.right = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//4.向左子树进行递归删除</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">this</span>.left.delNode(no);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//5.向右子树进行递归删除</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">this</span>.right.delNode(no);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="顺序存储二叉树"><a class="markdownIt-Anchor" href="#顺序存储二叉树">#</a> 顺序存储二叉树</h1>
<h2 id="基本介绍"><a class="markdownIt-Anchor" href="#基本介绍">#</a> 基本介绍</h2>
<p>从数据存储来看，<strong>数组存储方式</strong>和<strong>树</strong>的存储方式可以相互转换，即数组可以转换成树，树也可以转换成数组，如下面所示。</p>
<p><a href="https://imgtu.com/i/R7m2BF"><img src="https://z3.ax1x.com/2021/07/06/R7m2BF.png" alt="R7m2BF.png"></a></p>
<ul>
<li>
<p>顺序二叉树通常只考虑完全二叉树</p>
</li>
<li>
<p>第 n 个元素的左子节点为 2 * n + 1</p>
</li>
<li>
<p>第 n 个元素的右子节点为 2 * n + 2</p>
</li>
<li>
<p>第 n 个元素的父节点为 (n-1) / 2</p>
</li>
<li>
<p>n : 表示二叉树中的第几个元素 (按 0 开始编号 如上图所示)</p>
</li>
</ul>
<h2 id="代码展示-4"><a class="markdownIt-Anchor" href="#代码展示-4">#</a> 代码展示</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> demo04;</span><br><span class="line"><span class="comment">//顺序存储二叉树的前、中、后序遍历</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayBinaryTreeDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;;</span><br><span class="line">        <span class="comment">//创建一个ArrBinaryTree</span></span><br><span class="line">        ArrayBinaryTree binaryTree=<span class="keyword">new</span> ArrayBinaryTree(arr);</span><br><span class="line">        System.out.println(<span class="string">&quot;前序遍历&quot;</span>);</span><br><span class="line">        binaryTree.preOrder();</span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println(<span class="string">&quot;中序遍历&quot;</span>);</span><br><span class="line">        binaryTree.infixOrder();</span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println(<span class="string">&quot;后序遍历&quot;</span>);</span><br><span class="line">        binaryTree.postOrder();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//编写一个ArrayBinaryTree，实现顺序存储二叉树遍历</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArrayBinaryTree</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] arr;<span class="comment">//存储数据节点的数组</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayBinaryTree</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.arr = arr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//重载 preOrder</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.preOrder(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重载 infixOrder</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">infixOrder</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.infixOrder(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重载 postOrder</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postOrder</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.postOrder(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//编写一个方法，完成顺序存储二叉树的前序遍历</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index 数组下标</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//如果数组为空，或者 arr.length == 0;</span></span><br><span class="line">        <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length == <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;数组为空，无法进行二叉树的前序遍历&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//输出当前这个元素</span></span><br><span class="line">        System.out.print(arr[index]);</span><br><span class="line">        <span class="comment">//向左遍历递归</span></span><br><span class="line">        <span class="keyword">if</span> (index * <span class="number">2</span> + <span class="number">1</span> &lt; arr.length) &#123;</span><br><span class="line">            preOrder(<span class="number">2</span> * index + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//向右遍历递归</span></span><br><span class="line">        <span class="keyword">if</span> (index * <span class="number">2</span> + <span class="number">2</span> &lt; arr.length) &#123;</span><br><span class="line">            preOrder(<span class="number">2</span> * index + <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//编写一个方法，完成顺序存储二叉树的中序遍历</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index 数组下标</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">infixOrder</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//如果数组为空，或者 arr.length == 0;</span></span><br><span class="line">        <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length == <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;数组为空，无法进行二叉树的中序遍历&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//向左遍历递归</span></span><br><span class="line">        <span class="keyword">if</span> (index * <span class="number">2</span> + <span class="number">1</span> &lt; arr.length) &#123;</span><br><span class="line">            infixOrder(<span class="number">2</span> * index + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//输出当前这个元素</span></span><br><span class="line">        System.out.print(arr[index]);</span><br><span class="line">        <span class="comment">//向右遍历递归</span></span><br><span class="line">        <span class="keyword">if</span> (index * <span class="number">2</span> + <span class="number">2</span> &lt; arr.length) &#123;</span><br><span class="line">            infixOrder(<span class="number">2</span> * index + <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//编写一个方法，完成顺序存储二叉树的后序遍历</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index 数组下标</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postOrder</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//如果数组为空，或者 arr.length == 0;</span></span><br><span class="line">        <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length == <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;数组为空，无法进行二叉树的后序遍历&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//向左遍历递归</span></span><br><span class="line">        <span class="keyword">if</span> (index * <span class="number">2</span> + <span class="number">1</span> &lt; arr.length) &#123;</span><br><span class="line">            postOrder(<span class="number">2</span> * index + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//向右遍历递归</span></span><br><span class="line">        <span class="keyword">if</span> (index * <span class="number">2</span> + <span class="number">2</span> &lt; arr.length) &#123;</span><br><span class="line">            postOrder(<span class="number">2</span> * index + <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//输出当前这个元素</span></span><br><span class="line">        System.out.print(arr[index]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;	</span><br></pre></td></tr></table></figure>
<h1 id="线索化二叉树"><a class="markdownIt-Anchor" href="#线索化二叉树">#</a> 线索化二叉树</h1>
<h2 id="基本介绍-2"><a class="markdownIt-Anchor" href="#基本介绍-2">#</a> 基本介绍</h2>
<ul>
<li>
<p>n 个结点的二叉链表中含有 n+1 【公式 2n-(n-1)=n+1】 个空指针域。利用二叉链表中的空指针域，存放指向<strong>该</strong><a href="">结点</a>) 在<strong>某种遍历次序</strong>下的前驱和后继结点的指针（这种附加的指针称为 &quot;线索&quot;）</p>
</li>
<li>
<p>这种加上了线索的二叉链表 称为<strong>线索链表</strong>，相应的二叉树称为<strong>线索二叉树 (Threaded BinaryTree)</strong>。根据线索性质的不同，线索二叉树可分为<strong>前序线索二叉树、中序线索二叉树和后序线索二叉树</strong>三种</p>
</li>
<li>
<p>一个结点的前一个结点，称为<strong>前驱</strong>结点</p>
</li>
<li>
<p>一个结点的后一个结点，称为<strong>后继</strong>结点</p>
</li>
</ul>
<p><a href="https://imgtu.com/i/R7m4hR"><img src="https://z3.ax1x.com/2021/07/06/R7m4hR.png" alt="R7m4hR.png"></a></p>
<ul>
<li>说明：当线索化二叉树，Node 节点的属性 left 和 right，有以下两种情况：(根据上图分析)
<ol>
<li>left 指向的是左子树，也可能是指向的前驱节点，比如 1 号 节点 left 指向的左子树，而 10 号 节点的 left 指向的就是前驱节点</li>
<li>right 指向的是右子树，也可能是指向后继节点， 比如 1 号 节点 right 指向的右子树，而 10 号 节点的 right 指向的是后继节点</li>
</ol>
</li>
</ul>
<h2 id="代码展示-5"><a class="markdownIt-Anchor" href="#代码展示-5">#</a> 代码展示</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> demo05;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadedBinaryTreeDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建需要的节点</span></span><br><span class="line">        HeroNode root = <span class="keyword">new</span> HeroNode(<span class="number">1</span>, <span class="string">&quot;zoffy&quot;</span>);</span><br><span class="line">        HeroNode node2 = <span class="keyword">new</span> HeroNode(<span class="number">3</span>, <span class="string">&quot;man&quot;</span>);</span><br><span class="line">        HeroNode node3 = <span class="keyword">new</span> HeroNode(<span class="number">6</span>, <span class="string">&quot;taro&quot;</span>);</span><br><span class="line">        HeroNode node4 = <span class="keyword">new</span> HeroNode(<span class="number">8</span>, <span class="string">&quot;taiga&quot;</span>);</span><br><span class="line">        HeroNode node5 = <span class="keyword">new</span> HeroNode(<span class="number">10</span>, <span class="string">&quot;mebius&quot;</span>);</span><br><span class="line">        HeroNode node6 = <span class="keyword">new</span> HeroNode(<span class="number">14</span>, <span class="string">&quot;zero&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//二叉树，后面我们递归创建，现在简单处理使用手动创建</span></span><br><span class="line">        root.setLeft(node2);</span><br><span class="line">        root.setRight(node3);</span><br><span class="line">        node2.setLeft(node4);</span><br><span class="line">        node2.setRight(node5);</span><br><span class="line">        node3.setLeft(node6);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//测试线索化</span></span><br><span class="line">        ThreadedBinaryTree threadedBinaryTree = <span class="keyword">new</span> ThreadedBinaryTree();</span><br><span class="line">        threadedBinaryTree.setRoot(root);</span><br><span class="line">        threadedBinaryTree.threadedNodes();</span><br><span class="line"></span><br><span class="line">        HeroNode left = node5.getLeft();</span><br><span class="line">        System.out.println(left);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//当线索化二叉树后，不能再使用原来的方法遍历</span></span><br><span class="line">        System.out.println(<span class="string">&quot;使用线索化的方式遍历线索化二叉树&quot;</span>);</span><br><span class="line">        threadedBinaryTree.threadedList();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义ThreadedBinaryTree 实现了线索化功能的二叉树</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadedBinaryTree</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> HeroNode root;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//为了实现线索化，需要创建要给指向当前节点的前驱节点的指针</span></span><br><span class="line">    <span class="comment">//在递归进行线索化时，pre 总是保留前一个节点</span></span><br><span class="line">    <span class="keyword">private</span> HeroNode pre = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRoot</span><span class="params">(HeroNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.root = root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重载threadedNodes方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">threadedNodes</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.threadedNodes(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历线索化二叉树的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">threadedList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//定义一个变量，存储当前遍历的节点，从root开始</span></span><br><span class="line">        HeroNode node = root;</span><br><span class="line">        <span class="keyword">while</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//循环的找到leftType==1的节点，第一个找到的是8节点</span></span><br><span class="line">            <span class="comment">//后面随着遍历而变化，因为当leftType==1时，说明该节点是按照线索化处理后的有效节点</span></span><br><span class="line">            <span class="keyword">while</span> (node.getLeftType() == <span class="number">0</span>) &#123;</span><br><span class="line">                node = node.getLeft();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//打印这个节点</span></span><br><span class="line">            System.out.println(node);</span><br><span class="line">            <span class="comment">//如果当前节点的右指针指向的是后继节点，就一直输出</span></span><br><span class="line">            <span class="keyword">while</span> (node.getRightType() == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">//获取到当前节点的后继节点</span></span><br><span class="line">                node = node.getRight();</span><br><span class="line">                System.out.println(node);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//替换这个遍历的节点</span></span><br><span class="line">            node = node.getRight();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//编写对二叉树进行中序线索化的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">threadedNodes</span><span class="params">(HeroNode node)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//如果node==null 不能线索化</span></span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//第一步 先线索化左子树</span></span><br><span class="line">        threadedNodes(node.getLeft());</span><br><span class="line">        <span class="comment">//第二步 线索化当前节点</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//处理当前节点的前驱节点</span></span><br><span class="line">        <span class="keyword">if</span> (node.getLeft() == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//让当前节点的左指针指向前驱节点</span></span><br><span class="line">            node.setLeft(pre);</span><br><span class="line">            <span class="comment">//修改当前节点的左指针的类型，指向前驱节点</span></span><br><span class="line">            node.setLeftType(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//处理后继节点</span></span><br><span class="line">        <span class="keyword">if</span> (pre != <span class="keyword">null</span> &amp;&amp; pre.getRight() == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//让前驱节点的右指针指向当前节点</span></span><br><span class="line">            pre.setRight(node);</span><br><span class="line">            <span class="comment">//修改前驱节点的右指针类型</span></span><br><span class="line">            pre.setRightType(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//！！！！！！！！每处理一个节点后，让当前节点是下一个节点的前驱节点</span></span><br><span class="line">        pre = node;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//第三步 再线索化右子树</span></span><br><span class="line">        threadedNodes(node.getRight());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建HeroNode 节点</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HeroNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> no;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> HeroNode left;  <span class="comment">//默认为null</span></span><br><span class="line">    <span class="keyword">private</span> HeroNode right; <span class="comment">//默认为null</span></span><br><span class="line">    <span class="comment">//说明：</span></span><br><span class="line">    <span class="comment">//1.如果leftType == 0 表示指向的是左子树，如果leftType == 1 则表示指向前驱节点</span></span><br><span class="line">    <span class="comment">//2.如果rightType ==0 表示指向的是右子树，如果rightType == 1 表示指向后继节点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> leftType;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> rightType;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HeroNode</span><span class="params">(<span class="keyword">int</span> no, String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.no = no;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> no;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNo</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.no = no;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HeroNode <span class="title">getLeft</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLeft</span><span class="params">(HeroNode left)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.left = left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HeroNode <span class="title">getRight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRight</span><span class="params">(HeroNode right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getLeftType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> leftType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLeftType</span><span class="params">(<span class="keyword">int</span> leftType)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.leftType = leftType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getRightType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> rightType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRightType</span><span class="params">(<span class="keyword">int</span> rightType)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.rightType = rightType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;HeroNode &#123; no=&quot;</span> + no + <span class="string">&quot;, name=&quot;</span> + name + <span class="string">&quot;&#125;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>10.树结构基础部分</category>
      </categories>
      <tags>
        <tag>算法与数据结构</tag>
        <tag>二叉树</tag>
        <tag>顺序存储二叉树</tag>
        <tag>线索化二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>树结构实际应用</title>
    <url>/2021/07/08/11.%E6%A0%91%E7%BB%93%E6%9E%84%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<h2 id="堆排序"><a class="markdownIt-Anchor" href="#堆排序">#</a> 堆排序</h2>
<h3 id="基本介绍"><a class="markdownIt-Anchor" href="#基本介绍">#</a> 基本介绍</h3>
<ol>
<li>
<p>堆排序是利用<strong>堆</strong>这种数据结构而设计的一种排序算法，堆排序是一种 ** 选择排序，** 它的最坏，最好，平均时间复杂度均为 O (nlogn)，它也是不稳定排序。</p>
</li>
<li>
<p>堆是具有以下性质的完全二叉树：每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆，<strong>注意</strong>：没有要求结点的左孩子的值和右孩子的值的大小关系。</p>
</li>
<li>
<p>每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆</p>
</li>
<li>
<p><strong>大顶堆</strong></p>
<p><a href="https://imgtu.com/i/R7nrUH"><img src="https://z3.ax1x.com/2021/07/06/R7nrUH.png" alt="R7nrUH.png"></a></p>
<p><a href="https://imgtu.com/i/R7Rm7V"><img src="https://z3.ax1x.com/2021/07/07/R7Rm7V.png" alt="R7Rm7V.png"></a></p>
<p><strong>大顶堆特点： arr [i]&gt;=arr [2 * i+1] &amp;&amp; arr [i] &gt;= arr [2 * i+2] //i 对应几个节点，i 从 0 开始编号</strong></p>
</li>
<li>
<p><strong>小顶堆</strong></p>
<p><a href="https://imgtu.com/i/R7RMhF"><img src="https://z3.ax1x.com/2021/07/07/R7RMhF.png" alt="R7RMhF.png"></a></p>
<p><strong>小顶堆特点： arr [i] &lt;= arr [2 * i+1] &amp;&amp; arr [i] &lt;= arr [2 * i+2] //i 对应几个节点，i 从 0 开始编号</strong></p>
</li>
<li>
<p><strong>一般升序采用大顶堆，降序采用小顶堆</strong></p>
</li>
</ol>
<ul>
<li>
<p>堆排序的基本思想是：</p>
<ul>
<li>
<p>将待排序序列构造成一个大顶堆</p>
</li>
<li>
<p>此时，整个序列的最大值就是堆顶的根节点。</p>
</li>
<li>
<p>将其与末尾元素进行交换，此时末尾就为最大值。</p>
</li>
<li>
<p>然后将剩余 n-1 个元素重新构造成一个堆，这样会得到 n 个元素的次小值。如此反复执行，便能得到一个有序序列了。</p>
</li>
</ul>
</li>
</ul>
<h3 id="思路分析"><a class="markdownIt-Anchor" href="#思路分析">#</a> 思路分析</h3>
<p><strong>步骤一 构造初始堆。将给定无序序列构造成一个大顶堆（一般升序采用大顶堆，降序采用小顶堆)。</strong></p>
<ol>
<li>. 假设给定无序序列结构如下</li>
</ol>
<p><a href="https://imgtu.com/i/R7RatO"><img src="https://z3.ax1x.com/2021/07/07/R7RatO.gif" alt="R7RatO.gif"></a></p>
<ol start="2">
<li>. 此时我们从最后一个非叶子结点开始（叶结点自然不用调整，第一个非叶子结点 arr.length/2-1=5/2-1=1，也就是下面的 6 结点），从左至右，从下至上进行调整。</li>
</ol>
<p><a href="https://imgtu.com/i/R7RdhD"><img src="https://z3.ax1x.com/2021/07/07/R7RdhD.gif" alt="R7RdhD.gif"></a></p>
<ol start="3">
<li>. 找到第二个非叶节点 4，由于 [4,9,8] 中 9 元素最大，4 和 9 交换。</li>
</ol>
<p><a href="https://imgtu.com/i/R7R09e"><img src="https://z3.ax1x.com/2021/07/07/R7R09e.gif" alt="R7R09e.gif"></a></p>
<ol start="4">
<li>这时，交换导致了子根 [4,5,6] 结构混乱，继续调整，[4,5,6] 中 6 最大，交换 4 和 6。</li>
</ol>
<p><a href="https://imgtu.com/i/R7RB1H"><img src="https://z3.ax1x.com/2021/07/07/R7RB1H.gif" alt="R7RB1H.gif"></a></p>
<p>此时，我们就将一个无序序列构造成了一个大顶堆。</p>
<p><strong>步骤二 将堆顶元素与末尾元素进行交换，使末尾元素最大。然后继续调整堆，再将堆顶元素与末尾元素交换，得到第二大元素。如此反复进行交换、重建、交换。</strong></p>
<ol>
<li>. 将堆顶元素 9 和末尾元素 4 进行交换</li>
</ol>
<p><a href="https://imgtu.com/i/R7R6Bt"><img src="https://z3.ax1x.com/2021/07/07/R7R6Bt.gif" alt="R7R6Bt.gif"></a></p>
<ol start="2">
<li>. 重新调整结构，使其继续满足堆定义</li>
</ol>
<p><a href="https://imgtu.com/i/R7R2Af"><img src="https://z3.ax1x.com/2021/07/07/R7R2Af.gif" alt="R7R2Af.gif"></a></p>
<ol start="3">
<li>. 再将堆顶元素 8 与末尾元素 5 进行交换，得到第二大元素 8.</li>
</ol>
<p><a href="https://imgtu.com/i/R7RRN8"><img src="https://z3.ax1x.com/2021/07/07/R7RRN8.gif" alt="R7RRN8.gif"></a>4) 后续过程，继续进行调整，交换，如此反复进行，最终使得整个序列有序</p>
<p><a href="https://imgtu.com/i/R7R43Q"><img src="https://z3.ax1x.com/2021/07/07/R7R43Q.gif" alt="R7R43Q.gif"></a></p>
<p><strong>再简单总结下堆排序的基本思路：</strong></p>
<p><strong>1). 将无序序列构建成一个堆，根据升序降序需求选择大顶堆或小顶堆；</strong></p>
<p><strong>2). 将堆顶元素与末尾元素交换，将最大元素 &quot;沉&quot; 到数组末端；</strong></p>
<p><strong>3). 重新调整结构，使其满足堆定义，然后继续交换堆顶元素与当前末尾元素，反复执行调整 + 交换步骤，直到整个序列有序。</strong></p>
<h3 id="代码展示"><a class="markdownIt-Anchor" href="#代码展示">#</a> 代码展示</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> demo06;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeapSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//要求将数组升序排序</span></span><br><span class="line">        <span class="keyword">int</span> arr[] = &#123;<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">5</span>,<span class="number">9</span>,-<span class="number">1</span>,<span class="number">44</span>,<span class="number">2</span>,<span class="number">7</span>&#125;;</span><br><span class="line"></span><br><span class="line">        heapSort(arr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//编写一个堆排序的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp=<span class="number">0</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;堆排序！！！&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//        分步完成</span></span><br><span class="line"><span class="comment">//        adjustHeap(arr,1,arr.length);</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;第一次&quot;+ Arrays.toString(arr));</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        adjustHeap(arr,0,arr.length);</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;第二次&quot;+ Arrays.toString(arr));</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//完成最终代码</span></span><br><span class="line">        <span class="comment">//1.将无序序列构建成一个堆，根据升序降序需求选择大顶堆或小顶堆</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = arr.length / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            adjustHeap(arr, i, arr.length);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.将堆顶元素与末尾交换，将最大元素 “沉” 到数组末端</span></span><br><span class="line">        <span class="comment">//3.重新调整结构，使其满足堆定义，然后继续交换堆顶元素与当前末尾元素，反复执行 2和3 两个步骤，直到整个序列有序</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = arr.length - <span class="number">1</span>; j &gt; <span class="number">0</span>; j--) &#123;</span><br><span class="line">            <span class="comment">//交换</span></span><br><span class="line">            temp=arr[j];</span><br><span class="line">            arr[j]=arr[<span class="number">0</span>];</span><br><span class="line">            arr[<span class="number">0</span>]=temp;</span><br><span class="line">            adjustHeap(arr,<span class="number">0</span>,j);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;数组=&quot;</span> + Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将一个数组（二叉树），调整成一个大顶堆</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 功能：完成 将以 i 指向的 i 对应的非叶子节点的树调整成大顶堆</span></span><br><span class="line"><span class="comment">     * 举例：int[] arr=&#123;4,6,8,5,9&#125; =&gt; i=1 =&gt; adjustHeap =&gt; 得到&#123;4,9,8,5,6&#125;</span></span><br><span class="line"><span class="comment">     * 如果我们再次调整 adjustHeap 传入的是 i=0 =&gt; 使 &#123;4,9,8,5,6&#125; =&gt; &#123;9,6,8,5,4 &#125;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr    待调整的数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i      表示非叶子节点在数组中的索引</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> length 表示对多少个元素进行调整，length 在逐渐的减小</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">adjustHeap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = arr[i];<span class="comment">//先取出当前元素的值，保存在临时变量</span></span><br><span class="line">        <span class="comment">//开始调整</span></span><br><span class="line">        <span class="comment">//说明</span></span><br><span class="line">        <span class="comment">//1. k=i*2+1  k是i的左子节点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = i * <span class="number">2</span> + <span class="number">1</span>; k &lt; length; k = k * <span class="number">2</span> + <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (k + <span class="number">1</span> &lt; length &amp;&amp; arr[k] &lt; arr[k + <span class="number">1</span>]) &#123;<span class="comment">//说明左子节点的值小于右子节点的值</span></span><br><span class="line">                k++; <span class="comment">//k指向 右子节点</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (arr[k] &gt; temp) &#123;  <span class="comment">//如果子节点大于父节点</span></span><br><span class="line">                arr[i] = arr[k]; <span class="comment">//把较大的值赋给当前节点</span></span><br><span class="line">                i = k;  <span class="comment">//!!!! i指向k 继续循环比较</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//当 for 循环结束后，我们已经将以 i 为父节点的树的最大值，放在了最顶（局部）</span></span><br><span class="line">        arr[i] = temp; <span class="comment">//将temp值放到调整后的位置</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="赫夫曼树"><a class="markdownIt-Anchor" href="#赫夫曼树">#</a> 赫夫曼树</h2>
<h3 id="基本介绍-2"><a class="markdownIt-Anchor" href="#基本介绍-2">#</a> 基本介绍</h3>
<ul>
<li>
<p>给定 n 个权值作为 n 个<a href="https://baike.baidu.com/item/%E5%8F%B6%E5%AD%90%E7%BB%93%E7%82%B9/3620239">叶子结点</a>，构造一棵二叉树，若该树的带权路径长度 (wpl) 达到最小，称这样的二叉树为<strong>最优二叉树</strong>，也称为<strong>哈夫曼树</strong> (Huffman Tree), 还有的书翻译为<strong>霍夫曼树</strong>。</p>
</li>
<li>
<p>赫夫曼树是带权路径长度最短的树，权值较大的结点离根较近。</p>
</li>
</ul>
<h3 id="几个概念"><a class="markdownIt-Anchor" href="#几个概念">#</a> 几个概念</h3>
<ul>
<li>
<p>路径和路径长度：在一棵树中，从一个结点往下可以达到的孩子或孙子结点之间的通路，称为路径。通路中分支的数目称为路径长度。若规定根结点的层数为 1，则从根结点到第 L 层结点的路径长度为 L-1</p>
</li>
<li>
<p>** 结点的权及带权路径长度：** 若将树中结点赋给一个有着某种含义的数值，则这个数值称为该结点的权。<strong>结点的带权路径长度</strong>为：从根结点到该结点之间的路径长度与该结点的权的乘积</p>
</li>
<li>
<p><strong>树的带权路径长度：<strong>树的带权路径长度规定为所有</strong>叶子结点</strong>的带权路径长度之和，记为 WPL (weighted path length) , 权值越大的结点离根结点越近的二叉树才是最优二叉树。</p>
</li>
<li>
<p><strong>WPL 最小的就是赫夫曼树</strong></p>
</li>
</ul>
<p><a href="https://imgtu.com/i/R7RTun"><img src="https://z3.ax1x.com/2021/07/07/R7RTun.png" alt="R7RTun.png"></a></p>
<h3 id="思路分析-2"><a class="markdownIt-Anchor" href="#思路分析-2">#</a> 思路分析</h3>
<p>构成赫夫曼树的步骤：</p>
<ul>
<li>
<p>从小到大进行排序，将每一个数据，每个数据都是一个节点 ， 每个节点可以看成是一颗最简单的二叉树</p>
</li>
<li>
<p>取出根节点权值最小的两颗二叉树</p>
</li>
<li>
<p>组成一颗新的二叉树，该新的二叉树的根节点的权值是前面两颗二叉树根节点权值的和</p>
</li>
<li>
<p>再将这颗新的二叉树，以根节点的权值大小 再次排序， 不断重复 1-2-3-4 的步骤，直到数列中，所有的数据都被处理，就得到一颗赫夫曼树</p>
</li>
</ul>
<p><a href="https://imgtu.com/i/R7R7Bq"><img src="https://z3.ax1x.com/2021/07/07/R7R7Bq.png" alt="R7R7Bq.png"></a></p>
<h3 id="代码分析"><a class="markdownIt-Anchor" href="#代码分析">#</a> 代码分析</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> demo01;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HuffmanTree</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">13</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">3</span>, <span class="number">29</span>, <span class="number">6</span>, <span class="number">1</span>&#125;;</span><br><span class="line">        Node root = createHuffmanTree(arr);</span><br><span class="line">        <span class="comment">//测试一把</span></span><br><span class="line">        preOrder(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(Node root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            root.preOrder();</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;该树为空树&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建赫夫曼树的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">createHuffmanTree</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//第一步为了操作方便</span></span><br><span class="line">        <span class="comment">//1.遍历 arr 数组</span></span><br><span class="line">        <span class="comment">//2.将 arr 的每个元素构成成一个Node</span></span><br><span class="line">        <span class="comment">//3.将 Node 放入到ArrayList中</span></span><br><span class="line">        List&lt;Node&gt; nodes = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> value : arr) &#123;</span><br><span class="line">            nodes.add(<span class="keyword">new</span> Node(value));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//我们处理的过程是一个循环的过程</span></span><br><span class="line">        <span class="keyword">while</span> (nodes.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">//排序 从小到大</span></span><br><span class="line">            Collections.sort(nodes);</span><br><span class="line">            System.out.println(nodes);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//取出根节点权值最小的两颗二叉树</span></span><br><span class="line">            <span class="comment">//(1) 取出权值最小的节点（二叉树）</span></span><br><span class="line">            Node leftNode = nodes.get(<span class="number">0</span>);</span><br><span class="line">            <span class="comment">//(1) 取出权值第二小的节点（二叉树）</span></span><br><span class="line">            Node rightNode = nodes.get(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//(3) 构建一颗新的二叉树</span></span><br><span class="line">            Node parent = <span class="keyword">new</span> Node(leftNode.value + rightNode.value);</span><br><span class="line">            parent.left = leftNode;</span><br><span class="line">            parent.right = rightNode;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//(4) 从ArrayList中删除处理过的二叉树</span></span><br><span class="line">            nodes.remove(leftNode);</span><br><span class="line">            nodes.remove(rightNode);</span><br><span class="line">            <span class="comment">//(5) 将parent 加入到nodes中</span></span><br><span class="line">            nodes.add(parent);</span><br><span class="line">            Collections.sort(nodes);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nodes.get(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建节点</span></span><br><span class="line"><span class="comment">//为了让Node 对象持续排序Collections集合排序</span></span><br><span class="line"><span class="comment">//让Node 实现Comparable 接口</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Node</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> value;   <span class="comment">//节点权值</span></span><br><span class="line">    Node left;   <span class="comment">//指向左子节点</span></span><br><span class="line">    Node right;  <span class="comment">//指向右子节点、</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Node&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;value=&quot;</span> + value +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Node o)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//升序 从小到大</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.value - o.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//写一个前序遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">this</span>.left.preOrder();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">this</span>.right.preOrder();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="赫夫曼编码"><a class="markdownIt-Anchor" href="#赫夫曼编码">#</a> 赫夫曼编码</h2>
<h3 id="基本介绍-3"><a class="markdownIt-Anchor" href="#基本介绍-3">#</a> 基本介绍</h3>
<ul>
<li>赫夫曼编码也叫哈夫曼编码又称霍夫曼编码，是一种编码方式，属于一种程序算法</li>
<li>赫夫曼编码是赫哈夫曼树在电讯通信中的经典的应用之一</li>
<li>赫夫曼编码广泛地用于数据文件压缩。其 ** 压缩率通常在 20%～90%** 之间</li>
<li>赫夫曼码是可变<a href="https://baike.baidu.com/item/%E5%AD%97%E9%95%BF/97660">字长</a>编码 (VLC) 的一种。Huffman 于 1952 年提出一种编码方法，称之为最佳编码</li>
</ul>
<h3 id="原理剖析"><a class="markdownIt-Anchor" href="#原理剖析">#</a> 原理剖析</h3>
<h4 id="1-定长编码"><a class="markdownIt-Anchor" href="#1-定长编码">#</a> 1、定长编码</h4>
<ul>
<li>
<p>i like like like java do you like a java    // 共 40 个字符 (包括空格) 《转换成 ACSII 码》</p>
</li>
<li>
<p>105 32 108 105 107 101 32 108 105 107 101 32 108 105 107 101 32 106 97 118 97 32 100 111 32 121 111 117 32 108 105 107 101 32 97 32 106 97 118 97 // 对应 Ascii 码</p>
</li>
<li>
<p>01101001 00100000 01101100 01101001 01101011 01100101 00100000 01101100 01101001 01101011 01100101 00100000 01101100 01101001 01101011 01100101 00100000 01101010 01100001 01110110 01100001 00100000 01100100 01101111 00100000 01111001 01101111 01110101 00100000 01101100 01101001 01101011 01100101 00100000 01100001 00100000 01101010 01100001 01110110 01100001 // 对应的二进制</p>
</li>
<li>
<p>按照二进制来传递信息，总的长度是 359  (包括空格)</p>
</li>
<li>
<p>在线转码 工具 ：<a href="https://www.mokuge.com/tool/asciito16/">https://www.mokuge.com/tool/asciito16/</a></p>
</li>
</ul>
<h4 id="2-变长编码"><a class="markdownIt-Anchor" href="#2-变长编码">#</a> 2、变长编码</h4>
<ul>
<li>
<p>i like like like java do you like a java    // 共 40 个字符 (包括空格)</p>
</li>
<li>
<p>d:1 y:1 u:1 j:2 v:2 o:2 l:4 k:4 e:4 i:5 a:5  :9 // 各个字符对应的个数</p>
</li>
<li>
<p>0=(空格)  , 1=a, 10=i, 11=e, 100=k, 101=l, 110=o, 111=v, 1000=j, 1001=u, 1010=y, 1011=d<br>
 说明：按照各个字符出现的次数进行编码，原则是出现次数越多的，则编码越小，比如 空格出现了 9 次， 编码为 0 , 其它依次类推.</p>
</li>
<li>
<p>按照上面给各个字符规定的编码，则我们在传输 “i like like like java do you like a java” 数据时，编码就是<br>
 10010110100…</p>
</li>
<li>
<p>字符的编码都不能是其他字符编码的前缀，符合此要求的编码叫做前缀编码， 即不能匹配到重复的编码</p>
</li>
</ul>
<h4 id="3-赫夫曼编码"><a class="markdownIt-Anchor" href="#3-赫夫曼编码">#</a> 3、赫夫曼编码</h4>
<ol>
<li>
<p>传输的字符串  i like like like java do you like a java</p>
</li>
<li>
<p>d:1、y:1、u:1、j:2、v:2、o:2、l:4、k:4、e:4、i:5、a:5、(空格):9 // 各个字符对应的个数</p>
</li>
<li>
<p>按照上面字符出现的次数构建一颗赫夫曼树，次数作为权值</p>
<ul>
<li>
<p>构成赫夫曼树的步骤：</p>
</li>
<li>
<p>从小到大进行排序，将每一个数据，每个数据都是一个节点 ， 每个节点可以看成是一颗最简单的二叉树</p>
</li>
<li>
<p>取出根节点权值最小的两颗二叉树</p>
</li>
<li>
<p>组成一颗新的二叉树，该新的二叉树的根节点的权值是前面两颗二叉树根节点权值的和</p>
</li>
<li>
<p>再将这颗新的二叉树，以根节点的权值大小 再次排序， 不断重复 1-2-3-4 的步骤，直到数列中，所有的数据都被处理，就得到一颗赫夫曼树</p>
</li>
</ul>
</li>
</ol>
<p><a href="https://imgtu.com/i/R7RqEV"><img src="https://z3.ax1x.com/2021/07/07/R7RqEV.png" alt="R7RqEV.png"></a></p>
<ol start="4">
<li>
<p>根据赫夫曼树，给各个字符，规定编码 (前缀编码)， 向左的路径为 0 向右的路径为 1 ， 编码如下:</p>
<p>o: 1000  u: 10010   d: 100110   y: 100111    i: 101     a : 110      k: 1110     e: 1111</p>
<p>j: 0000    v: 0001     l: 001         (空格) : 01</p>
</li>
<li>
<p>按照上面的赫夫曼编码，我们的 &quot;i like like like java do you like a java&quot;  字符串对应的编码为 (注意这里我们使用的无损压缩)</p>
<p><strong>101</strong>0100110111101111010011011110111101001101111011110100001100001110011001111000011001111000100100100110111101111011100100001100001110 通过赫夫曼编码处理 长度为 133</p>
</li>
<li>
<p>长度为 ： 133</p>
</li>
</ol>
<p><strong>说明：原来长度是 359 , 压缩了 (359-133) / 359 = 62.9%</strong></p>
<p><strong>此编码满足前缀编码，即字符的编码都不能是其他字符编码的前缀。不会造成匹配的多义性</strong></p>
<p><strong>赫夫曼编码是无损处理方案</strong></p>
<p>注：这个赫夫曼树根据排序方法不同，也可能不太一样，<strong>这样对应的赫夫曼编码也不完全一样</strong>，但是 wpl 是一样的，都是最小的，最后生成的赫夫曼编码的长度是一样的。比如：如果我们让每次生成的新的二叉树总是排在权值相同的二叉树的最后一个，则生成的二叉树为:</p>
<p><a href="https://imgtu.com/i/R7Rv34"><img src="https://z3.ax1x.com/2021/07/07/R7Rv34.png" alt="R7Rv34.png"></a></p>
<h2 id="赫夫曼树的应用"><a class="markdownIt-Anchor" href="#赫夫曼树的应用">#</a> 赫夫曼树的应用</h2>
<h3 id="实践操作"><a class="markdownIt-Anchor" href="#实践操作">#</a> 实践操作</h3>
<p><strong>数据压缩 (生成赫夫曼树)</strong>、</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">将给出的一段文本，比如 &quot;i like like like java do you like a java&quot; ， 根据前面的讲的赫夫曼编码原理，对其进行数据压缩处理 ，形式如 &quot;1010100110111101111010011011110111101001101111011110100001100001110011001111000011001111000100100100110111101111011100100001100001110</span><br><span class="line">&quot; </span><br><span class="line">步骤1：根据赫夫曼编码压缩数据的原理，需要创建 &quot;i like like like java do you like a java&quot; 对应的赫夫曼树.</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>数据压缩 (生成赫夫曼编码和赫夫曼编码后的数据)</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">我们已经生成了 赫夫曼树, 下面我们继续完成任务</span><br><span class="line">  1.生成赫夫曼树对应的赫夫曼编码  , 如下表:=01 a=100 d=11000 u=11001 e=1110 v=11011 i=101 y=11010 j=0010 k=1111 l=000 o=0011</span><br><span class="line">  2.使用赫夫曼编码来生成赫夫曼编码数据 ,即按照上面的赫夫曼编码，将&quot;i like like like java do you like a java&quot;   字符串生成对应的编码数据, 形式下.</span><br><span class="line">  1010100010111111110010001011111111001000101111111100100101001101110001110000011011101000111100101000101111111100110001001010011011100</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>数据解压 (使用赫夫曼编码解码)</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">使用赫夫曼编码来解码数据，具体要求是</span><br><span class="line">  1.前面我们得到了赫夫曼编码和对应的编码</span><br><span class="line">byte[] , 即:[-88, -65, -56, -65, -56, -65, -55, 77, -57, 6, -24, -14, -117, -4, -60, -90, 28]</span><br><span class="line">  2.现在要求使用赫夫曼编码， 进行解码，又重新得到原来的字符串&quot;i like like like java do you like a java&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>文件压缩</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">读取文件-&gt; 得到赫夫曼编码表 -&gt; 完成压缩</span><br></pre></td></tr></table></figure>
<p><strong>文件解压</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">读取压缩文件(数据和赫夫曼编码表)-&gt; 完成解压(文件恢复)</span><br></pre></td></tr></table></figure>
<p><strong>注意事项</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.如果文件本身就是经过压缩处理的，那么使用赫夫曼编码再压缩效率不会有明显变化, 比如视频,ppt 等等文件 </span><br><span class="line">2.赫夫曼编码是按字节来处理的，因此可以处理所有的文件(二进制文件、文本文件) </span><br><span class="line">3.如果一个文件中的内容，重复的数据不多，压缩效果也不会很明显. </span><br></pre></td></tr></table></figure>
<h3 id="代码实现"><a class="markdownIt-Anchor" href="#代码实现">#</a> 代码实现</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> demo01;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HuffmanCode</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        String content = &quot;i like like like java do you like a java&quot;;</span></span><br><span class="line"><span class="comment">        byte[] contentBytes = content.getBytes();</span></span><br><span class="line"><span class="comment">        System.out.println(contentBytes.length); //40</span></span><br><span class="line"><span class="comment">        //编码</span></span><br><span class="line"><span class="comment">        byte[] huffmanZipBytes = huffmanZip(contentBytes);</span></span><br><span class="line"><span class="comment">        System.out.println(Arrays.toString(huffmanZipBytes));</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        //如何将数据进行解压（解码）</span></span><br><span class="line"><span class="comment">        byte[] sourceBytes = decode(huffmanCodes, huffmanZipBytes);</span></span><br><span class="line"><span class="comment">        System.out.println(&quot;原来的字符串=&quot; + new String(sourceBytes));</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        //测试压缩文件</span></span><br><span class="line"><span class="comment">        String srcFile=&quot;F:\\alphonse.jpg&quot;;</span></span><br><span class="line"><span class="comment">        String dstFile=&quot;F:\\alphonse.zip&quot;;</span></span><br><span class="line"><span class="comment">        zipFile(srcFile,dstFile);</span></span><br><span class="line"><span class="comment">        System.out.println(&quot;压缩成功~~&quot;);</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//测试解压文件</span></span><br><span class="line">        String zipFile=<span class="string">&quot;F:\\alphonse.zip&quot;</span>;</span><br><span class="line">        String dstFile=<span class="string">&quot;F:\\alphonse1.jpg&quot;</span>;</span><br><span class="line">        unZipFile(zipFile,dstFile);</span><br><span class="line">        System.out.println(<span class="string">&quot;解压成功~~&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//编写一个方法,将一个文件进行压缩</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">zipFile</span><span class="params">(String srcFile, String dstFile)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建输出流</span></span><br><span class="line">        FileOutputStream os = <span class="keyword">null</span>;</span><br><span class="line">        ObjectOutputStream oos = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//创建文件的输入流</span></span><br><span class="line">        FileInputStream is = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            is = <span class="keyword">new</span> FileInputStream(srcFile);</span><br><span class="line">            <span class="comment">//创建一个和源文件大小一样的byte[]</span></span><br><span class="line">            <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[is.available()];</span><br><span class="line">            <span class="comment">//读取文件</span></span><br><span class="line">            is.read(b);</span><br><span class="line">            <span class="comment">//直接对源文件压缩</span></span><br><span class="line">            <span class="keyword">byte</span>[] huffmanZipBytes = huffmanZip(b);</span><br><span class="line">            <span class="comment">//创建文件的输出流，存放压缩文件</span></span><br><span class="line">            os = <span class="keyword">new</span> FileOutputStream(dstFile);</span><br><span class="line">            <span class="comment">//创建一个和文件输出流关联的ObjectOutputStream</span></span><br><span class="line">            oos = <span class="keyword">new</span> ObjectOutputStream(os);</span><br><span class="line">            <span class="comment">//把 赫夫曼编码后的字节数组写入压缩文件</span></span><br><span class="line">            oos.writeObject(huffmanZipBytes);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//这里我们以对象流的方式写入赫夫曼编码，是为了以后我们恢复源文件时使用</span></span><br><span class="line">            <span class="comment">//注意：一定要把赫夫曼编码写入压缩文件</span></span><br><span class="line">            oos.writeObject(huffmanCodes);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                is.close();</span><br><span class="line">                oos.close();</span><br><span class="line">                os.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//编写一个方法，对压缩文件解压</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> zipFile 准备解压的文件</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> dstFile 将文件解压到那个路径</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">unZipFile</span><span class="params">(String zipFile,String dstFile)</span></span>&#123;</span><br><span class="line">        <span class="comment">//定义文件的输入流</span></span><br><span class="line">        InputStream is =<span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//定义一个对象输入流</span></span><br><span class="line">        ObjectInputStream ois=<span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//定义文件的输出流</span></span><br><span class="line">        OutputStream os=<span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//创建文件输入流</span></span><br><span class="line">            is=<span class="keyword">new</span> FileInputStream(zipFile);</span><br><span class="line">            <span class="comment">//创建一个和 is 关联的对象输入流</span></span><br><span class="line">            ois = <span class="keyword">new</span> ObjectInputStream(is);</span><br><span class="line">            <span class="comment">//读取byte数组到huffmanBytes</span></span><br><span class="line">            <span class="keyword">byte</span>[] huffmanBytes=(<span class="keyword">byte</span>[])ois.readObject();</span><br><span class="line">            <span class="comment">//读取赫夫曼编码表</span></span><br><span class="line">            Map&lt;Byte,String&gt; huffmanCodes=(Map&lt;Byte,String&gt;)ois.readObject();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//解码</span></span><br><span class="line">            <span class="keyword">byte</span>[] decode = decode(huffmanCodes, huffmanBytes);</span><br><span class="line">            <span class="comment">//将bytes 数组写入到目标文件</span></span><br><span class="line">            os=<span class="keyword">new</span> FileOutputStream(dstFile);</span><br><span class="line">            <span class="comment">//写出数据到文件中</span></span><br><span class="line">            os.write(decode);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                os.close();</span><br><span class="line">                ois.close();</span><br><span class="line">                is.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//完成数据的解压</span></span><br><span class="line">    <span class="comment">//思路</span></span><br><span class="line">    <span class="comment">//1.将 [-88, -65, -56, -65, -56, -65, -55, 77, -57, 6, -24, -14, -117, -4, -60, -90, 28]</span></span><br><span class="line">    <span class="comment">//     先转成赫夫曼编码对应的二进制字符串&quot;101010011011110111101001101111011 ...&quot;</span></span><br><span class="line">    <span class="comment">//2.赫夫曼编码对应的二进制的字符串&quot;1010100110111101111010 ... &quot; =&gt; 对照 赫夫曼编码重新转成字符串 =&gt; &quot;i like like like java do you like a java&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将 一个byte 转成 一个二进制字符串</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> b 传入的byte</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回的是该 b 对应的二进制的字符串，（注意是按补码返回）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Param</span> flag 标志是否需要补高位，如果是true 表示需要补高位，如果是false 表示不补</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">byteToBitString</span><span class="params">(<span class="keyword">boolean</span> flag, <span class="keyword">byte</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//使用变量保存 b</span></span><br><span class="line">        <span class="keyword">int</span> temp = b;<span class="comment">//将 b 转成 int类型</span></span><br><span class="line">        <span class="comment">//如果是正数，我们还需要补高位</span></span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">            temp = temp | <span class="number">256</span>; <span class="comment">// 按位与256 1 0000 0000 | 0000 0001 =&gt; 1 0000 0001</span></span><br><span class="line">        &#125;</span><br><span class="line">        String str = Integer.toBinaryString(temp); <span class="comment">//返回的是 temp 对应的二进制的补码</span></span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">            <span class="keyword">return</span> str.substring(str.length() - <span class="number">8</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> str;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 编写一个方法，完成对压缩数据的解码</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> huffmanCodes 赫夫曼编码表 map</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> huffmanBytes 赫夫曼编码得到的字节数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 就是原来的字符串对应的数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] decode(Map&lt;Byte, String&gt; huffmanCodes, <span class="keyword">byte</span>[] huffmanBytes) &#123;</span><br><span class="line">        <span class="comment">//1.先得到 huffmanBytes 对应的二进制的字符串，如 1010100110111101111010 ...</span></span><br><span class="line">        StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="comment">//将byte数组转成二进制的字符串</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; huffmanBytes.length; i++) &#123;</span><br><span class="line">            <span class="keyword">byte</span> b = huffmanBytes[i];</span><br><span class="line">            <span class="comment">//判断是不是最后一个字节</span></span><br><span class="line">            <span class="keyword">boolean</span> flag = (i == huffmanBytes.length - <span class="number">1</span>);</span><br><span class="line">            stringBuilder.append(byteToBitString(!flag, b));</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(stringBuilder.toString());</span><br><span class="line">        <span class="comment">//把字符串按照指定的赫夫曼编码进行解码</span></span><br><span class="line">        <span class="comment">//把赫夫曼编码表进行调换，因为反向查询 a-&gt;100   100-&gt;a</span></span><br><span class="line">        Map&lt;String, Byte&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Byte, String&gt; entry : huffmanCodes.entrySet()) &#123;</span><br><span class="line">            map.put(entry.getValue(), entry.getKey());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建一个集合，存放byte</span></span><br><span class="line">        List&lt;Byte&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">//i 可以理解为索引,扫描 stringBuilder</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; stringBuilder.length(); ) &#123;</span><br><span class="line">            <span class="keyword">int</span> count = <span class="number">1</span>; <span class="comment">//小的计数器</span></span><br><span class="line">            <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">            Byte b = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">while</span> (flag) &#123;</span><br><span class="line">                <span class="comment">//1010100010111111110010001 ...</span></span><br><span class="line">                <span class="comment">//递增取出一个 &#x27;1&#x27;或&#x27;0&#x27;</span></span><br><span class="line">                String key = stringBuilder.substring(i, i + count); <span class="comment">// i不动，让count移动，指定匹配一个字符</span></span><br><span class="line">                b = map.get(key);</span><br><span class="line">                <span class="keyword">if</span> (b == <span class="keyword">null</span>) &#123;<span class="comment">//没有匹配到</span></span><br><span class="line">                    count++;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//匹配到</span></span><br><span class="line">                    flag = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            list.add(b);</span><br><span class="line">            i += count; <span class="comment">//让 i 直接移动到count位置</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//当for循环结束后，我们list中就存放了所有的字符</span></span><br><span class="line">        <span class="comment">//把list中的数据放到byte[] 并返回</span></span><br><span class="line">        <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[list.size()];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; b.length; i++) &#123;</span><br><span class="line">            b[i] = list.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用一个方法将前面的方法封装起来，便于调用</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> bytes 原始的字符串对应的字节数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 是经过 赫夫曼编码处理后的字节数组（压缩后的数组）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] huffmanZip(<span class="keyword">byte</span>[] bytes) &#123;</span><br><span class="line">        List&lt;Node&gt; nodes = getNodes(bytes);</span><br><span class="line">        <span class="comment">//根据 nodes 创建赫夫曼树</span></span><br><span class="line">        Node huffmanTreeRoot = createHuffmanTree(nodes);</span><br><span class="line">        <span class="comment">//根据赫夫曼树创建对应的 赫夫曼编码</span></span><br><span class="line">        Map&lt;Byte, String&gt; huffmanCodes = getCodes(huffmanTreeRoot);</span><br><span class="line">        <span class="comment">//根据生成的赫夫曼编码，压缩得到压缩后的赫夫曼编码字节数组</span></span><br><span class="line">        <span class="keyword">byte</span>[] huffmanCodeBytes = zip(bytes, huffmanCodes);</span><br><span class="line">        <span class="keyword">return</span> huffmanCodeBytes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//编写一个方法，将字符串对应的byte[] 数组，通过生成的赫夫曼编码表，返回一个赫夫曼编码压缩后的byte[]</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 例如：String content=&quot;i like like like java do you like a java&quot;; =》 byte[] contentBytes=content.getBytes();</span></span><br><span class="line"><span class="comment">     * 返回的是字符串 &quot;1010100110111101111010011011110111101001101111011110100001100001110011001111000011001111000100100100110111101111011100100001100001110&quot;</span></span><br><span class="line"><span class="comment">     * =&gt; 对应的byte[] huffmanCodeBytes,即8位对应一个byte，放入到huffmanCodeBytes</span></span><br><span class="line"><span class="comment">     * huffmanCodeBytes[0] = 10101001(补码) =&gt; byte [推导 10101001 =》 10101001 -1 =》10101000(反码) =》(符号位不变，其他为取反)11010111 = - 88]  第一位为符号位：0为正，1为负</span></span><br><span class="line"><span class="comment">     * huffmanCodeBytes[1] =-88</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> bytes        这是原始的字符串对应的byte[]</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> huffmanCodes huffmanCodes 生成的赫夫曼编码 map</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回赫夫曼编码处理后的byte[]</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] zip(<span class="keyword">byte</span>[] bytes, Map&lt;Byte, String&gt; huffmanCodes) &#123;</span><br><span class="line">        <span class="comment">//1.利用huffmanCodes 将 bytes 转成 赫夫曼编码对应的字符串</span></span><br><span class="line">        StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="comment">//遍历 bytes 数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">byte</span> b : bytes) &#123;</span><br><span class="line">            stringBuilder.append(huffmanCodes.get(b));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;测试 stringBuilder=&quot;</span> + stringBuilder.toString());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将 &quot;1010100110111101111010011011110 ... &quot;转成 byte[]</span></span><br><span class="line">        <span class="comment">//统计返回 byte[] huffmanCodes</span></span><br><span class="line">        <span class="comment">//一句话 int len = (stringBuilder.length() + 7)/8;</span></span><br><span class="line">        <span class="keyword">int</span> len;</span><br><span class="line">        <span class="keyword">if</span> (stringBuilder.length() % <span class="number">8</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            len = stringBuilder.length() / <span class="number">8</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            len = stringBuilder.length() / <span class="number">8</span> + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">byte</span>[] huffmanCodeBytes = <span class="keyword">new</span> <span class="keyword">byte</span>[len];</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;<span class="comment">//记录是第几个 byte</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; stringBuilder.length(); i += <span class="number">8</span>) &#123; <span class="comment">//因为是霉每8位对应一个byte，所以步长+8</span></span><br><span class="line">            String strByte;</span><br><span class="line">            <span class="keyword">if</span> (i + <span class="number">8</span> &gt; stringBuilder.length()) &#123;</span><br><span class="line">                strByte = stringBuilder.substring(i);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                strByte = stringBuilder.substring(i, i + <span class="number">8</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//将 strByte 转成一个byte放入到HuffmanCodeBytes</span></span><br><span class="line">            huffmanCodeBytes[index] = (<span class="keyword">byte</span>) Integer.parseInt(strByte, <span class="number">2</span>);</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> huffmanCodeBytes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//生成赫夫曼树对应的赫夫曼编码</span></span><br><span class="line">    <span class="comment">//思路</span></span><br><span class="line">    <span class="comment">//1.将赫夫曼编码表存放在 Map&lt;Byte,String&gt; 中形式</span></span><br><span class="line">    <span class="comment">//   &#123;32=01, 97=100, 100=11000, 117=11001, 101=1110, 118=11011, 105=101, 121=11010, 106=0010, 107=1111, 108=000, 111=0011&#125;</span></span><br><span class="line">    <span class="keyword">static</span> Map&lt;Byte, String&gt; huffmanCodes = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="comment">//2.在生成赫夫曼编码表时，需要拼接路径，定义一个StringBuild 存储某个叶子节点的路径</span></span><br><span class="line">    <span class="keyword">static</span> StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//为了调用方便，重载getCodes</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Map&lt;Byte, String&gt; <span class="title">getCodes</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//处理root的左子树</span></span><br><span class="line">        getCodes(root.left, <span class="string">&quot;0&quot;</span>, stringBuilder);</span><br><span class="line">        <span class="comment">//处理root的右子树</span></span><br><span class="line">        getCodes(root.right, <span class="string">&quot;1&quot;</span>, stringBuilder);</span><br><span class="line">        <span class="keyword">return</span> huffmanCodes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 功能：将传入的node节点的所有叶子节点的赫夫曼编码得到，并放入到HuffmanCode集合</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node          传入节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> code          路径：左子节点是 0，右子节点是 1</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> stringBuilder 用于拼接路径</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getCodes</span><span class="params">(Node node, String code, StringBuilder stringBuilder)</span> </span>&#123;</span><br><span class="line">        StringBuilder stringBuilder2 = <span class="keyword">new</span> StringBuilder(stringBuilder);</span><br><span class="line">        <span class="comment">//将code加入到stringBuilder2</span></span><br><span class="line">        stringBuilder2.append(code);</span><br><span class="line">        <span class="keyword">if</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//如果node等于null，不处理</span></span><br><span class="line">            <span class="comment">//判断当前node，是叶子节点还是非叶子节点</span></span><br><span class="line">            <span class="keyword">if</span> (node.data == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//递归处理</span></span><br><span class="line">                <span class="comment">//向左递归</span></span><br><span class="line">                getCodes(node.left, <span class="string">&quot;0&quot;</span>, stringBuilder2);</span><br><span class="line">                <span class="comment">//向右递归</span></span><br><span class="line">                getCodes(node.right, <span class="string">&quot;1&quot;</span>, stringBuilder2);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//说明是一个叶子结点</span></span><br><span class="line">                <span class="comment">//就表示找到某个叶子结点的最后</span></span><br><span class="line">                huffmanCodes.put(node.data, stringBuilder2.toString());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//前序遍历的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">            root.preOrder();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;赫夫曼树为空&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> bytes 接收字节数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回的是List  [Node&#123;data=32, weight=9&#125;, Node&#123;data=97, weight=5&#125;, ....]</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> List&lt;Node&gt; <span class="title">getNodes</span><span class="params">(<span class="keyword">byte</span>[] bytes)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1.创建一个ArrayList</span></span><br><span class="line">        ArrayList&lt;Node&gt; nodes = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">//2.遍历bytes,统计每一个bytes出现的次数 -&gt; map[key,value]</span></span><br><span class="line">        Map&lt;Byte, Integer&gt; counts = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">byte</span> b : bytes) &#123;</span><br><span class="line">            Integer count = counts.get(b);</span><br><span class="line">            <span class="keyword">if</span> (count == <span class="keyword">null</span>) &#123;<span class="comment">//此时，Map中还没有这个字符数据，第一次存放该数据</span></span><br><span class="line">                counts.put(b, <span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                counts.put(b, count + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//把每个键值对转成一个Node 对象，并加入到nodes集合中</span></span><br><span class="line">        <span class="comment">//遍历map</span></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Byte, Integer&gt; entry : counts.entrySet()) &#123;</span><br><span class="line">            nodes.add(<span class="keyword">new</span> Node(entry.getKey(), entry.getValue()));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nodes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过List 创建赫夫曼树</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Node <span class="title">createHuffmanTree</span><span class="params">(List&lt;Node&gt; nodes)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (nodes.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">//排序,从小到大</span></span><br><span class="line">            Collections.sort(nodes);</span><br><span class="line">            <span class="comment">//取出第一颗最小的二叉树</span></span><br><span class="line">            Node leftNode = nodes.get(<span class="number">0</span>);</span><br><span class="line">            Node rightNode = nodes.get(<span class="number">1</span>);</span><br><span class="line">            <span class="comment">//创建一棵新的二叉树，他的根节点没有data，只有权值</span></span><br><span class="line">            Node parent = <span class="keyword">new</span> Node(<span class="keyword">null</span>, leftNode.weight + rightNode.weight);</span><br><span class="line">            parent.left = leftNode;</span><br><span class="line">            parent.right = rightNode;</span><br><span class="line">            <span class="comment">//将已经处理的两颗二叉树从nodes 中删除</span></span><br><span class="line">            nodes.remove(leftNode);</span><br><span class="line">            nodes.remove(rightNode);</span><br><span class="line">            <span class="comment">//将新的节点，加入到nodes 中</span></span><br><span class="line">            nodes.add(parent);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//nodes 最后的节点解释赫夫曼树的根节点</span></span><br><span class="line">        <span class="keyword">return</span> nodes.get(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建Node，带数据和权值</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Node</span>&gt; </span>&#123;</span><br><span class="line">    Byte data; <span class="comment">//存放数据，比如&#x27;a&#x27; =&gt; 97, &#x27; &#x27;=&gt; 32</span></span><br><span class="line">    <span class="keyword">int</span> weight; <span class="comment">//存放权值,表示字符出现的次数</span></span><br><span class="line">    Node left;</span><br><span class="line">    Node right;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(Byte data, <span class="keyword">int</span> weight)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">        <span class="keyword">this</span>.weight = weight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Node o)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//从小到大排序</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.weight - o.weight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Node&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;data=&quot;</span> + data +</span><br><span class="line">                <span class="string">&quot;, weight=&quot;</span> + weight +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.left.preOrder();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.right.preOrder();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="二叉排序树"><a class="markdownIt-Anchor" href="#二叉排序树">#</a> 二叉排序树</h2>
<h3 id="需求分析"><a class="markdownIt-Anchor" href="#需求分析">#</a> 需求分析</h3>
<p>问题：给你一个数列 (7, 3, 10, 12, 5, 1, 9)，要求能够高效的完成对数据的查询和添加</p>
<h3 id="解决方案"><a class="markdownIt-Anchor" href="#解决方案">#</a> 解决方案</h3>
<p><strong>Ø 使用数组</strong></p>
<ol>
<li>
<p>数组未排序， 优点：直接在数组尾添加，速度快。 缺点：查找速度慢. [示意图]</p>
</li>
<li>
<p>数组排序，优点：可以使用二分查找，查找速度快，缺点：为了保证数组有序，在添加新数据时，找到插入位置后，后面的数据需整体移动，速度慢。[示意图]</p>
</li>
</ol>
<p><strong>Ø 使用链式存储 - 链表</strong></p>
<ul>
<li>不管链表是否有序，查找速度都慢，添加数据速度比数组快，不需要数据整体移动。[示意图]</li>
</ul>
<h3 id="简单介绍"><a class="markdownIt-Anchor" href="#简单介绍">#</a> 简单介绍</h3>
<p>二叉排序树：BST: (Binary Sort (Search) Tree), 对于二叉排序树的任何一个非叶子节点，要求左子节点的值比当前节点的值小，右子节点的值比当前节点的值大。</p>
<p><strong>特别说明</strong>：如果有相同的值，可以将该节点放在左子节点或右子节点</p>
<p>比如针对前面的数据 (7, 3, 10, 12, 5, 1, 9) ，对应的二叉排序树为：</p>
<p><a href="https://imgtu.com/i/R7WpuR"><img src="https://z3.ax1x.com/2021/07/07/R7WpuR.png" alt="R7WpuR.png"></a></p>
<h3 id="二叉排序树的创建和遍历"><a class="markdownIt-Anchor" href="#二叉排序树的创建和遍历">#</a> 二叉排序树的创建和遍历</h3>
<p><a href="https://imgtu.com/i/R7WCHx"><img src="https://z3.ax1x.com/2021/07/07/R7WCHx.png" alt="R7WCHx.png"></a></p>
<h3 id="二叉排序树的删除"><a class="markdownIt-Anchor" href="#二叉排序树的删除">#</a> 二叉排序树的删除</h3>
<p>二叉排序树的删除情况比较复杂，有下面三种情况需要考虑三种情况：</p>
<p><a href="https://imgtu.com/i/R7WFUK"><img src="https://z3.ax1x.com/2021/07/07/R7WFUK.png" alt="R7WFUK.png"></a></p>
<ul>
<li>
<p>第一种情况:</p>
<ul>
<li>
<p>删除叶子节点 (比如：2, 5, 9, 12)</p>
</li>
<li>
<p>思路</p>
</li>
<li>
<p>(1) 需求先去找到要删除的结点 targetNode</p>
</li>
<li>
<p>(2) 找到 targetNode 的 父结点 parent</p>
</li>
<li>
<p>(3) 确定 targetNode 是 parent 的左子结点 还是右子结点</p>
</li>
<li>
<p>(4) 根据前面的情况来对应删除</p>
</li>
<li>
<p>左子结点 parent.left = null</p>
</li>
<li>
<p>右子结点 parent.right = null;</p>
</li>
</ul>
</li>
<li>
<p>第二种情况: <strong>删除只有一颗子树的节点</strong> <strong>比如</strong> <strong>1</strong></p>
<ul>
<li>
<p>思路</p>
</li>
<li>
<p>(1) 需求先去找到要删除的结点 targetNode</p>
</li>
<li>
<p>(2) 找到 targetNode 的 父结点 parent</p>
</li>
<li>
<p>(3) 确定 targetNode 的子结点是左子结点还是右子结点</p>
</li>
<li>
<p>(4) targetNode 是 parent 的左子结点还是右子结点</p>
</li>
<li>
<p>(5) 如果 targetNode 有左子结点</p>
</li>
<li>
<p>5.1 如果 targetNode 是 parent 的左子结点</p>
</li>
<li>
<p>parent.left = targetNode.left;</p>
</li>
<li>
<p>5.2 如果 targetNode 是 parent 的右子结点</p>
</li>
<li>
<p>parent.right = targetNode.left;</p>
</li>
<li>
<p>(6) 如果 targetNode 有右子结点</p>
</li>
<li>
<p>6.1 如果 targetNode 是 parent 的左子结点</p>
</li>
<li>
<p>parent.left = targetNode.right;</p>
</li>
<li>
<p>6.2 如果 targetNode 是 parent 的右子结点</p>
</li>
<li>
<p>parent.right = targetNode.right</p>
</li>
</ul>
</li>
<li>
<p>情况三 ： 删除有两颗子树的节点. (比如：7, 3，<strong>10</strong> )</p>
<ul>
<li>
<p>思路</p>
</li>
<li>
<p>(1) 需求先去找到要删除的结点 targetNode</p>
</li>
<li>
<p>(2) 找到 targetNode 的 父结点 parent</p>
</li>
<li>
<p>(3) 从 targetNode 的右子树找到最小的结点</p>
</li>
<li>
<p>(4) 用一个临时变量，将 最小结点的值保存 temp = 11</p>
</li>
<li>
<p>(5) 删除该最小结点</p>
</li>
<li>
<p>(6) targetNode.value = temp</p>
</li>
</ul>
</li>
</ul>
<h3 id="代码展示-2"><a class="markdownIt-Anchor" href="#代码展示-2">#</a> 代码展示</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> demo01;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinarySortTreeDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">7</span>, <span class="number">3</span>, <span class="number">10</span>, <span class="number">12</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">9</span>, <span class="number">2</span>&#125;;</span><br><span class="line">        BinarySortTree binarySortTree = <span class="keyword">new</span> BinarySortTree();</span><br><span class="line">        <span class="comment">//循环的添加结点到二叉排序树</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            binarySortTree.add(<span class="keyword">new</span> Node(arr[i]));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//中序遍历二叉排序树</span></span><br><span class="line">        binarySortTree.infixOrder();<span class="comment">//1 3 5 7 9 10 12</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//测试删除叶子结点</span></span><br><span class="line">        binarySortTree.delNode(<span class="number">2</span>);</span><br><span class="line">        binarySortTree.delNode(<span class="number">5</span>);</span><br><span class="line">        binarySortTree.delNode(<span class="number">9</span>);</span><br><span class="line">        binarySortTree.delNode(<span class="number">2</span>);</span><br><span class="line">        binarySortTree.delNode(<span class="number">12</span>);</span><br><span class="line">        binarySortTree.delNode(<span class="number">7</span>);</span><br><span class="line">        binarySortTree.delNode(<span class="number">3</span>);</span><br><span class="line">        <span class="comment">//binarySortTree.delNode(10);</span></span><br><span class="line">        <span class="comment">//binarySortTree.delNode(1);</span></span><br><span class="line">        System.out.println(<span class="string">&quot;删除结点后&quot;</span>);</span><br><span class="line">        binarySortTree.infixOrder();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建二叉排序树</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinarySortTree</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Node root;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加结点方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            root = node; <span class="comment">//如果root为空，直接让root指向node</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            root.add(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查找要删除的结点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">search</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> root.search(value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查找要删除的父结点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">searchParent</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> root.searchParent(value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  编写方法</span></span><br><span class="line"><span class="comment">     *  1.返回 以 node 为根节点的二叉排序树的最小结点的值</span></span><br><span class="line"><span class="comment">     *  2.删除node为根节点的二叉排序树的最小结点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node 传入的结点（当前二叉排序树的根节点）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回 以 node 为根节点的二叉排序树的最小结点的值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">delRightTreeMin</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">        Node target=node;</span><br><span class="line">        <span class="comment">//循环的查找左子节点，就会找到最小值</span></span><br><span class="line">        <span class="keyword">while</span> (target.left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            target=target.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//这是target就指向了最小结点</span></span><br><span class="line">        <span class="comment">//删除最小结点</span></span><br><span class="line">        delNode(target.value);</span><br><span class="line">        <span class="keyword">return</span> target.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除结点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delNode</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//1.需要先去找到要删除的结点 targetNode</span></span><br><span class="line">            Node targetNode = search(value);</span><br><span class="line">            <span class="comment">//如果没有找到要删除的结点</span></span><br><span class="line">            <span class="keyword">if</span> (targetNode == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果我们发现当前这个二叉排序树只有一个结点</span></span><br><span class="line">            <span class="keyword">if</span> (root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">                root = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//去找到targetNode的父结点</span></span><br><span class="line">            Node parent = searchParent(value);</span><br><span class="line">            <span class="comment">//如果要删除的结点是叶子结点</span></span><br><span class="line">            <span class="keyword">if</span> (targetNode.left == <span class="keyword">null</span> &amp;&amp; targetNode.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//判断targetNode是父结点的左子结点还是右子结点</span></span><br><span class="line">                <span class="keyword">if</span> (parent.left != <span class="keyword">null</span> &amp;&amp; parent.left.value == value) &#123;<span class="comment">//说明targetNode是parent的左子结点</span></span><br><span class="line">                    parent.left = <span class="keyword">null</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (parent.right != <span class="keyword">null</span> &amp;&amp; parent.right.value == value) &#123;<span class="comment">//说明targetNode是parent的右子结点</span></span><br><span class="line">                    parent.right = <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (targetNode.left != <span class="keyword">null</span> &amp;&amp; targetNode.right != <span class="keyword">null</span>) &#123; <span class="comment">//删除有两颗子树的结点</span></span><br><span class="line">                <span class="keyword">int</span> minValue = delRightTreeMin(targetNode.right);</span><br><span class="line">                targetNode.value=minValue;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">//删除只有一颗子树的结点</span></span><br><span class="line">                <span class="comment">//如果要删除的结点有左子结点</span></span><br><span class="line">                <span class="keyword">if</span> (targetNode.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (parent!=<span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="comment">//如果targetNode 是parent的左子结点</span></span><br><span class="line">                        <span class="keyword">if</span> (parent.left.value == value) &#123;</span><br><span class="line">                            parent.left = targetNode.left;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123; <span class="comment">//说明targetNode是parent的右子结点</span></span><br><span class="line">                            parent.right = targetNode.left;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                        root=targetNode.left;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;<span class="comment">//如果要删除的结点有右子结点</span></span><br><span class="line">                    <span class="keyword">if</span> (parent!=<span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (parent.left.value == value) &#123; <span class="comment">//targetNode是parent的左子结点</span></span><br><span class="line">                            parent.left = targetNode.right;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123; <span class="comment">//targetNode是parent的右子结点</span></span><br><span class="line">                            parent.right = targetNode.right;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                        root=targetNode.right;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//中序遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">infixOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">            root.infixOrder();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;二叉排序树为null，无法遍历&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建Node结点</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    Node left;</span><br><span class="line">    Node right;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Node&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;value=&quot;</span> + value +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加结点</span></span><br><span class="line">    <span class="comment">//递归的形式添加结点，注意需要满足二叉排序树</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断传入结点的值，和当前子树的根结点的值的关系</span></span><br><span class="line">        <span class="keyword">if</span> (node.value &lt; <span class="keyword">this</span>.value) &#123;</span><br><span class="line">            <span class="comment">//判断当前结点的左子结点是否为 null</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.left == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">this</span>.left = node;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//递归的向左子树添加</span></span><br><span class="line">                <span class="keyword">this</span>.left.add(node);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">//添加结点的值大于当前结点的值</span></span><br><span class="line">            <span class="comment">//判断当前结点的右子结点是否为 null</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">this</span>.right = node;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//递归的向右子树添加</span></span><br><span class="line">                <span class="keyword">this</span>.right.add(node);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查找要删除的结点</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 希望删除的结点的值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 如果找到该结点，就返回该结点，否则返回null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">search</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (value == <span class="keyword">this</span>.value) &#123; <span class="comment">//找到就是该结点</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value &lt; <span class="keyword">this</span>.value) &#123; <span class="comment">//如果查找的值小于当前结点，向左子树递归查找</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.left == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.left.search(value);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">//如果查找的值不小于当前结点，向右子树递归查找</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.right.search(value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查找要删除结点的父结点</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 要找到的结点的值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回要删除结点的父结点，没有就返回null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">searchParent</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//如果当前结点就是要删除的结点的父结点，就反回</span></span><br><span class="line">        <span class="keyword">if</span> ((<span class="keyword">this</span>.left != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.left.value == value) || (<span class="keyword">this</span>.right != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.right.value == value)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//如果查找的值小于当前结点的值，并且当前结点的左子结点不为null</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.left != <span class="keyword">null</span> &amp;&amp; value &lt; <span class="keyword">this</span>.value) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>.left.searchParent(value);<span class="comment">//向左子树递归查找</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value &gt;= <span class="keyword">this</span>.value &amp;&amp; <span class="keyword">this</span>.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>.right.searchParent(value);<span class="comment">//向右子树递归查找</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//中序遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">infixOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.left.infixOrder();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.right.infixOrder();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="平衡二叉树"><a class="markdownIt-Anchor" href="#平衡二叉树">#</a> 平衡二叉树</h2>
<h3 id="引出概念"><a class="markdownIt-Anchor" href="#引出概念">#</a> 引出概念</h3>
<p><strong>看一个案例 (说明二叉排序树可能的问题)</strong></p>
<p>给你一个数列 {1,2,3,4,5,6}，要求创建一颗二叉排序树 (BST), 并分析问题所在.</p>
<p><strong>下方 BST 存在的问题分析</strong>:</p>
<p>1) 左子树全部为空，从形式上看，更像一个单链表.</p>
<p>2) 插入速度没有影响</p>
<p>3) 查询速度明显降低 (因为需要依次比较), 不能发挥 BST 的优势，因为每次还需要比较左子树，其查询速度比单链表还慢</p>
<p>4) 解决方案 - 平衡二叉树 (AVL)</p>
<p><a href="https://imgtu.com/i/R7WV8e"><img src="https://z3.ax1x.com/2021/07/07/R7WV8e.png" alt="R7WV8e.png"></a></p>
<h3 id="基本介绍-4"><a class="markdownIt-Anchor" href="#基本介绍-4">#</a> 基本介绍</h3>
<p>1) 平衡二叉树也叫平衡二叉搜索树（Self-balancing binary search tree）又被称为 AVL 树， 可以<strong>保证查询效率较高</strong>。</p>
<p>2) 具有以下<strong>特点</strong>：它是一 棵空树或它的左右两个子树的高度差的绝对值不超过 1，并且左右两个子树都是一棵平衡二叉树。平衡二叉树的常用实现方法有<a href="">红黑树</a>)、<a href="">AVL</a>、<a href="">替罪羊树</a>、<a href="">Treap</a>、<a href="">伸展树</a>等。</p>
<h3 id="左旋转"><a class="markdownIt-Anchor" href="#左旋转">#</a> 左旋转</h3>
<ul>
<li 4,3,6,5,7,8="">要求：给你一个数列，创建出对应的平衡二叉树。数列</li>
</ul>
<p><a href="https://imgtu.com/i/R7WQVP"><img src="https://z3.ax1x.com/2021/07/07/R7WQVP.png" alt="R7WQVP.png"></a></p>
<h3 id="右旋转"><a class="markdownIt-Anchor" href="#右旋转">#</a> 右旋转</h3>
<ul>
<li 10,12,="" 8,="" 9,="" 7,="" 6="">要求：给你一个数列，创建出对应的平衡二叉树。数列</li>
</ul>
<p><a href="https://imgtu.com/i/R7Wevd"><img src="https://z3.ax1x.com/2021/07/07/R7Wevd.png" alt="R7Wevd.png"></a></p>
<h3 id="双旋转"><a class="markdownIt-Anchor" href="#双旋转">#</a> 双旋转</h3>
<p>前面的两个数列，进行单旋转 (即一次旋转) 就可以将非平衡二叉树转成平衡二叉树，但是在某些情况下，单旋转不能完成平衡二叉树的转换。比如数列</p>
<p><strong>int[]</strong> <strong>arr</strong> <strong>= { 10, 11, 7, 6, 8, 9 };</strong> <strong>运行原来的代码可以看到，并没有转成</strong> <strong>AVL 树.</strong></p>
<p><strong>int[]</strong> <strong>arr</strong> <strong>= {2,1,6,5,7,3}; //</strong> <strong>运行原来的代码可以看到，并没有转成 AVL 树</strong></p>
<p><a href="https://imgtu.com/i/R7WwV0"><img src="https://z3.ax1x.com/2021/07/07/R7WwV0.png" alt="R7WwV0.png"></a></p>
<h3 id="代码展示-3"><a class="markdownIt-Anchor" href="#代码展示-3">#</a> 代码展示</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> demo01;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AVLTreeDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//int[] arr=&#123;4,3,6,5,7,8&#125;;</span></span><br><span class="line">        <span class="comment">//int[] arr=&#123;10,12,8,9,7,6&#125;;</span></span><br><span class="line">        <span class="keyword">int</span>[] arr=&#123;<span class="number">10</span>,<span class="number">11</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line">        <span class="comment">//创建一个AVLTree对象</span></span><br><span class="line">        AVLTree avlTree = <span class="keyword">new</span> AVLTree();</span><br><span class="line">        <span class="comment">//添加结点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            avlTree.add(<span class="keyword">new</span> Node(arr[i]));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//遍历</span></span><br><span class="line">        System.out.println(<span class="string">&quot;中序遍历&quot;</span>);</span><br><span class="line">        avlTree.infixOrder();</span><br><span class="line">        System.out.println(<span class="string">&quot;平衡处理后~~&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;树的高度&quot;</span>+avlTree.getRoot().height()); <span class="comment">//3</span></span><br><span class="line">        System.out.println(<span class="string">&quot;树的左子树高度&quot;</span>+avlTree.getRoot().leftHeight()); <span class="comment">//2</span></span><br><span class="line">        System.out.println(<span class="string">&quot;树的右子树高度&quot;</span>+avlTree.getRoot().rightHeight()); <span class="comment">//2</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;当前的根节点为&quot;</span>+avlTree.getRoot()); <span class="comment">//8</span></span><br><span class="line">        System.out.println(<span class="string">&quot;当前的根节点左子结点为&quot;</span>+avlTree.getRoot().left); <span class="comment">//7</span></span><br><span class="line">        System.out.println(<span class="string">&quot;当前的根节点右子结点为&quot;</span>+avlTree.getRoot().right); <span class="comment">//10</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建AVL树</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AVLTree</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> Node root;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">getRoot</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加结点方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            root = node; <span class="comment">//如果root为空，直接让root指向node</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            root.add(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查找要删除的结点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">search</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> root.search(value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查找要删除的父结点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">searchParent</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> root.searchParent(value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 编写方法</span></span><br><span class="line"><span class="comment">     * 1.返回 以 node 为根节点的二叉排序树的最小结点的值</span></span><br><span class="line"><span class="comment">     * 2.删除node为根节点的二叉排序树的最小结点</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node 传入的结点（当前二叉排序树的根节点）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回 以 node 为根节点的二叉排序树的最小结点的值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">delRightTreeMin</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        Node target = node;</span><br><span class="line">        <span class="comment">//循环的查找左子节点，就会找到最小值</span></span><br><span class="line">        <span class="keyword">while</span> (target.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            target = target.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//这是target就指向了最小结点</span></span><br><span class="line">        <span class="comment">//删除最小结点</span></span><br><span class="line">        delNode(target.value);</span><br><span class="line">        <span class="keyword">return</span> target.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除结点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delNode</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//1.需要先去找到要删除的结点 targetNode</span></span><br><span class="line">            Node targetNode = search(value);</span><br><span class="line">            <span class="comment">//如果没有找到要删除的结点</span></span><br><span class="line">            <span class="keyword">if</span> (targetNode == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果我们发现当前这个二叉排序树只有一个结点</span></span><br><span class="line">            <span class="keyword">if</span> (root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">                root = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//去找到targetNode的父结点</span></span><br><span class="line">            Node parent = searchParent(value);</span><br><span class="line">            <span class="comment">//如果要删除的结点是叶子结点</span></span><br><span class="line">            <span class="keyword">if</span> (targetNode.left == <span class="keyword">null</span> &amp;&amp; targetNode.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//判断targetNode是父结点的左子结点还是右子结点</span></span><br><span class="line">                <span class="keyword">if</span> (parent.left != <span class="keyword">null</span> &amp;&amp; parent.left.value == value) &#123;<span class="comment">//说明targetNode是parent的左子结点</span></span><br><span class="line">                    parent.left = <span class="keyword">null</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (parent.right != <span class="keyword">null</span> &amp;&amp; parent.right.value == value) &#123;<span class="comment">//说明targetNode是parent的右子结点</span></span><br><span class="line">                    parent.right = <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (targetNode.left != <span class="keyword">null</span> &amp;&amp; targetNode.right != <span class="keyword">null</span>) &#123; <span class="comment">//删除有两颗子树的结点</span></span><br><span class="line">                <span class="keyword">int</span> minValue = delRightTreeMin(targetNode.right);</span><br><span class="line">                targetNode.value = minValue;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">//删除只有一颗子树的结点</span></span><br><span class="line">                <span class="comment">//如果要删除的结点有左子结点</span></span><br><span class="line">                <span class="keyword">if</span> (targetNode.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="comment">//如果targetNode 是parent的左子结点</span></span><br><span class="line">                        <span class="keyword">if</span> (parent.left.value == value) &#123;</span><br><span class="line">                            parent.left = targetNode.left;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123; <span class="comment">//说明targetNode是parent的右子结点</span></span><br><span class="line">                            parent.right = targetNode.left;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        root = targetNode.left;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;<span class="comment">//如果要删除的结点有右子结点</span></span><br><span class="line">                    <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (parent.left.value == value) &#123; <span class="comment">//targetNode是parent的左子结点</span></span><br><span class="line">                            parent.left = targetNode.right;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123; <span class="comment">//targetNode是parent的右子结点</span></span><br><span class="line">                            parent.right = targetNode.right;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        root = targetNode.right;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//中序遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">infixOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">            root.infixOrder();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;二叉排序树为null，无法遍历&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建Node结点</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    Node left;</span><br><span class="line">    Node right;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Node&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;value=&quot;</span> + value +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回左子树的高度</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">leftHeight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left.height();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回右子树的高度</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rightHeight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (right == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> right.height();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回当前结点的高度，当前结点为根节点的树的高度</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">height</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Math.max(left == <span class="keyword">null</span> ? <span class="number">0</span> : left.height(), right == <span class="keyword">null</span> ? <span class="number">0</span> : right.height()) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//左旋转的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">leftRotate</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//创建新的结点，以当前根节点的值</span></span><br><span class="line">        Node newNode = <span class="keyword">new</span> Node(value);</span><br><span class="line">        <span class="comment">//把新的结点的左子树设置成当前结点的左子树</span></span><br><span class="line">        newNode.left=left;</span><br><span class="line">        <span class="comment">//把新的结点的右子树设置成当前结点的右子树的左子树</span></span><br><span class="line">        newNode.right=right.left;</span><br><span class="line">        <span class="comment">//把当前结点的值替换成右子结点的值</span></span><br><span class="line">        value=right.value;</span><br><span class="line">        <span class="comment">//把当前结点的右子树设置成当前结点的右子树的右子树</span></span><br><span class="line">        right=right.right;</span><br><span class="line">        <span class="comment">//把当前结点的左子树(左子节点)设置成新的结点</span></span><br><span class="line">        left=newNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//右旋转的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rightRotate</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//创建新的结点，以当前根节点的值</span></span><br><span class="line">        Node newNode = <span class="keyword">new</span> Node(value);</span><br><span class="line">        <span class="comment">//把新的结点的右子树设置成当前结点的右子树</span></span><br><span class="line">        newNode.right=right;</span><br><span class="line">        <span class="comment">//把新的结点的左子树设置成当前结点的左子树的右子树</span></span><br><span class="line">        newNode.left=left.right;</span><br><span class="line">        <span class="comment">//把当前结点的值替换成左子结点的值</span></span><br><span class="line">        value=left.value;</span><br><span class="line">        <span class="comment">//把当前结点的左子树设置成当前结点的左子树的左子树</span></span><br><span class="line">        left=left.left;</span><br><span class="line">        <span class="comment">//把当前结点的右子树(右子节点)设置成新的结点</span></span><br><span class="line">        right=newNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加结点</span></span><br><span class="line">    <span class="comment">//递归的形式添加结点，注意需要满足二叉排序树</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断传入结点的值，和当前子树的根结点的值的关系</span></span><br><span class="line">        <span class="keyword">if</span> (node.value &lt; <span class="keyword">this</span>.value) &#123;</span><br><span class="line">            <span class="comment">//判断当前结点的左子结点是否为 null</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.left == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">this</span>.left = node;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//递归的向左子树添加</span></span><br><span class="line">                <span class="keyword">this</span>.left.add(node);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">//添加结点的值大于当前结点的值</span></span><br><span class="line">            <span class="comment">//判断当前结点的右子结点是否为 null</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">this</span>.right = node;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//递归的向右子树添加</span></span><br><span class="line">                <span class="keyword">this</span>.right.add(node);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//双旋转</span></span><br><span class="line">        <span class="comment">//当添加完一个结点后，如果发现：(右子树高度 - 左子树高度) &gt; 1,实现左旋转</span></span><br><span class="line">        <span class="keyword">if</span> (rightHeight()-leftHeight()&gt;<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">//如果它的右子树的左子树的高度大于他的右子树的右子树高度</span></span><br><span class="line">            <span class="keyword">if</span> (right!=<span class="keyword">null</span> &amp;&amp; right.leftHeight()&gt;right.rightHeight())&#123;</span><br><span class="line">                <span class="comment">//先对他的右子结点(右子树)进行右旋转</span></span><br><span class="line">                right.leftRotate();</span><br><span class="line">                <span class="comment">//再对当前结点进行左旋转</span></span><br><span class="line">                leftRotate();</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//直接左旋转</span></span><br><span class="line">                leftRotate();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//必须要 ！！！！！！！！！！！！</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//双旋转</span></span><br><span class="line">        <span class="comment">//当添加完一个结点后，如果发现：(左子树高度 - 右子树高度) &gt; 1,实现右旋转</span></span><br><span class="line">        <span class="keyword">if</span> (leftHeight()-rightHeight()&gt;<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">//如果他的左子树的右子树高度大于它的左子树的左子树高度</span></span><br><span class="line">            <span class="keyword">if</span> (left!=<span class="keyword">null</span> &amp;&amp; left.rightHeight()&gt;left.leftHeight())&#123;</span><br><span class="line">                <span class="comment">//先对当前结点的左子结点(左子树)-&gt;左旋转</span></span><br><span class="line">                left.leftRotate();</span><br><span class="line">                <span class="comment">//再对当前结点进行右旋转</span></span><br><span class="line">                rightRotate();</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//直接进行右旋转即可</span></span><br><span class="line">                rightRotate();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查找要删除的结点</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 希望删除的结点的值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 如果找到该结点，就返回该结点，否则返回null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">search</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (value == <span class="keyword">this</span>.value) &#123; <span class="comment">//找到就是该结点</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value &lt; <span class="keyword">this</span>.value) &#123; <span class="comment">//如果查找的值小于当前结点，向左子树递归查找</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.left == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.left.search(value);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">//如果查找的值不小于当前结点，向右子树递归查找</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.right.search(value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查找要删除结点的父结点</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 要找到的结点的值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回要删除结点的父结点，没有就返回null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">searchParent</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//如果当前结点就是要删除的结点的父结点，就反回</span></span><br><span class="line">        <span class="keyword">if</span> ((<span class="keyword">this</span>.left != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.left.value == value) || (<span class="keyword">this</span>.right != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.right.value == value)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//如果查找的值小于当前结点的值，并且当前结点的左子结点不为null</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.left != <span class="keyword">null</span> &amp;&amp; value &lt; <span class="keyword">this</span>.value) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>.left.searchParent(value);<span class="comment">//向左子树递归查找</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value &gt;= <span class="keyword">this</span>.value &amp;&amp; <span class="keyword">this</span>.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>.right.searchParent(value);<span class="comment">//向右子树递归查找</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//中序遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">infixOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.left.infixOrder();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.right.infixOrder();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>11.树结构实际应用</category>
      </categories>
      <tags>
        <tag>算法与数据结构</tag>
        <tag>堆排序</tag>
        <tag>赫夫曼树</tag>
        <tag>赫夫曼编码</tag>
        <tag>二叉排序树</tag>
        <tag>平衡二叉树</tag>
      </tags>
  </entry>
</search>
