<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>数据结构与算法的关系</title>
    <url>/2021/06/30/02.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%9A%84%E5%85%B3%E7%B3%BB/</url>
    <content><![CDATA[<p><a href="https://imgtu.com/i/RUJJJ0"><img src="https://z3.ax1x.com/2021/06/28/RUJJJ0.png" alt="RUJJJ0.png"></a></p>
<p><a href="https://imgtu.com/i/RUJYWV"><img src="https://z3.ax1x.com/2021/06/28/RUJYWV.png" alt="RUJYWV.png"></a></p>
]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>02.数据结构与算法的关系</category>
      </categories>
      <tags>
        <tag>算法与数据结构</tag>
        <tag>线性结构与非线性结构</tag>
      </tags>
  </entry>
  <entry>
    <title>算法简介</title>
    <url>/2021/06/30/01.%E7%AE%97%E6%B3%95%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<p><a href="https://imgtu.com/i/RUGLZ9"><img src="https://z3.ax1x.com/2021/06/28/RUGLZ9.png" alt="RUGLZ9.png"></a></p>
<p><a href="https://imgtu.com/i/RUGOaR"><img src="https://z3.ax1x.com/2021/06/28/RUGOaR.png" alt="RUGOaR.png"></a></p>
]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>01.算法简介</category>
      </categories>
      <tags>
        <tag>算法与数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>稀疏数组与队列</title>
    <url>/2021/06/30/03.%E7%A8%80%E7%96%8F%E6%95%B0%E7%BB%84%E5%92%8C%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<h2 id="稀疏数组"><a class="markdownIt-Anchor" href="#稀疏数组">#</a> 稀疏数组</h2>
<p><a href="https://imgtu.com/i/RwkEUe"><img src="https://z3.ax1x.com/2021/06/29/RwkEUe.png" alt="RwkEUe.png"></a></p>
<p><a href="https://imgtu.com/i/RwkAED"><img src="https://z3.ax1x.com/2021/06/29/RwkAED.png" alt="RwkAED.png"></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SparceArray</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建一个原始的二维数组</span></span><br><span class="line">        <span class="comment">//0:表示没有旗子，1表示黑子 2表示黑子</span></span><br><span class="line">        <span class="keyword">int</span> chessArr1[][]=<span class="keyword">new</span> <span class="keyword">int</span> [<span class="number">11</span>][<span class="number">11</span>];</span><br><span class="line">        chessArr1[<span class="number">1</span>][<span class="number">2</span>]=<span class="number">1</span>;</span><br><span class="line">        chessArr1[<span class="number">2</span>][<span class="number">3</span>]=<span class="number">2</span>;</span><br><span class="line">        <span class="comment">//输出原始的二维数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] row:chessArr1)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> data:row)&#123;</span><br><span class="line">                System.out.printf(<span class="string">&quot;%d\t&quot;</span>, data);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将二维数组 转稀疏数组 的思想</span></span><br><span class="line">        <span class="comment">//1.先遍历二维数组 得到非0数据的个数</span></span><br><span class="line">        <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">11</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">11</span>;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(chessArr1[i][j]!=<span class="number">0</span>)&#123;</span><br><span class="line">                    sum++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//2.创建对应的稀疏数组</span></span><br><span class="line">        <span class="keyword">int</span> sparseArr[][]=<span class="keyword">new</span> <span class="keyword">int</span> [sum+<span class="number">1</span>][<span class="number">3</span>];</span><br><span class="line">        <span class="comment">//给稀疏数组赋值</span></span><br><span class="line">        sparseArr[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">11</span>;</span><br><span class="line">        sparseArr[<span class="number">0</span>][<span class="number">1</span>]=<span class="number">11</span>;</span><br><span class="line">        sparseArr[<span class="number">0</span>][<span class="number">2</span>]=sum;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历二维数组，将非0的值存放到sparseArr中</span></span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">0</span>;<span class="comment">//count 用于记录是第几个非0数据</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">11</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">11</span>;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(chessArr1[i][j]!=<span class="number">0</span>)&#123;</span><br><span class="line">                    count++;</span><br><span class="line">                    sparseArr[count][<span class="number">0</span>]=i;</span><br><span class="line">                    sparseArr[count][<span class="number">1</span>]=j;</span><br><span class="line">                    sparseArr[count][<span class="number">2</span>]=chessArr1[i][j];</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//输出稀疏数组的形式</span></span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println(<span class="string">&quot;得到的稀疏数组为~~~~~~&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;sparseArr.length;i++)&#123;</span><br><span class="line">            System.out.printf(<span class="string">&quot;%d\t%d\t%d\t\n&quot;</span>,sparseArr[i][<span class="number">0</span>],sparseArr[i][<span class="number">1</span>],sparseArr[i][<span class="number">2</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">        <span class="comment">//将稀疏数组恢复成二维数组</span></span><br><span class="line">        <span class="comment">//1.先读取稀疏数组的第一行</span></span><br><span class="line">        <span class="keyword">int</span> chessArr2[][]=<span class="keyword">new</span> <span class="keyword">int</span> [sparseArr[<span class="number">0</span>][<span class="number">0</span>]][sparseArr[<span class="number">0</span>][<span class="number">1</span>]];</span><br><span class="line">        <span class="comment">//2.读取稀疏数组后几行数据（第二行开始），赋值给二维数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;sparseArr.length;i++)&#123;</span><br><span class="line">            chessArr2[sparseArr[i][<span class="number">0</span>]][sparseArr[i][<span class="number">1</span>]]=sparseArr[i][<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//恢复后的二维数组</span></span><br><span class="line">        System.out.println(<span class="string">&quot;恢复后的二维数组&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] row:chessArr2) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> data:row)&#123;</span><br><span class="line">                System.out.printf(<span class="string">&quot;%d\t&quot;</span>,data);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="队列"><a class="markdownIt-Anchor" href="#队列">#</a> 队列</h2>
<p><strong>介绍</strong></p>
<ol>
<li>
<p>队列是一个有序列表，可以用数组或是链表来实现</p>
</li>
<li>
<p>遵循先入先出的原则</p>
</li>
</ol>
<p><a href="https://imgtu.com/i/RwkPu6"><img src="https://z3.ax1x.com/2021/06/29/RwkPu6.png" alt="RwkPu6.png"></a></p>
<p><a href="https://imgtu.com/i/RwkiDK"><img src="https://z3.ax1x.com/2021/06/29/RwkiDK.png" alt="RwkiDK.png"></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayQueueDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//测试一把</span></span><br><span class="line">        <span class="comment">//创建一个队列</span></span><br><span class="line">        ArrayQueue arrayQueue = <span class="keyword">new</span> ArrayQueue(<span class="number">3</span>);</span><br><span class="line">        <span class="keyword">char</span> key=<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">boolean</span> loop=<span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">//输出一个菜单</span></span><br><span class="line">        <span class="keyword">while</span>(loop)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;s(show):显示队列&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;e(exit):退出程序&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;a(add):添加数据到队列&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;g(get):从队列取出数据&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;h(head):查看队列头数据&quot;</span>);</span><br><span class="line">            key=scanner.next().charAt(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">switch</span> (key)&#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;s&#x27;</span>:<span class="comment">//显示队列</span></span><br><span class="line">                    arrayQueue.showQueue();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;e&#x27;</span>:<span class="comment">//退出程序</span></span><br><span class="line">                    scanner.close();</span><br><span class="line">                    loop=<span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;a&#x27;</span>:<span class="comment">//添加数据到队列</span></span><br><span class="line">                    System.out.println(<span class="string">&quot;请输入一个数&quot;</span>);</span><br><span class="line">                    <span class="keyword">int</span> value = scanner.nextInt();</span><br><span class="line">                    arrayQueue.addQueue(value);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;g&#x27;</span>:<span class="comment">//从队列取出数据</span></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">int</span> queue = arrayQueue.getQueue();</span><br><span class="line">                        System.out.printf(<span class="string">&quot;取出的数据是%d\n&quot;</span>,queue);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        System.out.println(e.getMessage());</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;h&#x27;</span>:<span class="comment">//查看队列头数据</span></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">int</span> i = arrayQueue.headQueue();</span><br><span class="line">                        System.out.printf(<span class="string">&quot;队列头的数据是%d\n&quot;</span>,i);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        System.out.println(e.getMessage());</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    System.out.println(<span class="string">&quot;请输出正确信息&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;程序退出&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用数组模拟队列-编写一个人ArrayQueue类</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArrayQueue</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxSize;<span class="comment">//表示数组的最大容量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> front;<span class="comment">//队列头</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> rear;<span class="comment">//队列尾</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] arr;<span class="comment">//该数组用于存放数据，模拟队列</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建队列的构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayQueue</span><span class="params">(<span class="keyword">int</span> arrMaxSize)</span> </span>&#123;</span><br><span class="line">        maxSize = arrMaxSize;</span><br><span class="line">        arr = <span class="keyword">new</span> <span class="keyword">int</span>[maxSize];</span><br><span class="line">        front = -<span class="number">1</span>;<span class="comment">//指向队列头部，分析出front是指向队列头的前一个位置</span></span><br><span class="line">        rear = -<span class="number">1</span>;<span class="comment">//指向队列尾部，指向队列尾的数据【既就是队列最后一个数据】</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断队列是否满</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFull</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> rear == maxSize - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断队列是否为空</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> rear == front;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加数据到队列</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addQueue</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(isFull())&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;队列满，无法在添加数据&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        rear++;<span class="comment">//rear后移</span></span><br><span class="line">        arr[rear]=n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取队列的数据，出队列</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getQueue</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//判断队列是否空</span></span><br><span class="line">        <span class="keyword">if</span>(isEmpty())&#123;</span><br><span class="line">            <span class="comment">//抛出异常处理</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;队列为空,不能取数据&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        front++;</span><br><span class="line">        <span class="keyword">return</span> arr[front];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//显示队列的所有数据</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showQueue</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//遍历</span></span><br><span class="line">        <span class="keyword">if</span>(isEmpty())&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;队列为空，无数据&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">            System.out.printf(<span class="string">&quot;arr[%d]=%d\n&quot;</span>,i,arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//显示队列的头数据，注意不是取出数据</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">headQueue</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty())&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;队列为空,无数据&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr[front+<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><a href="https://imgtu.com/i/RwkFHO"><img src="https://z3.ax1x.com/2021/06/29/RwkFHO.png" alt="RwkFHO.png"></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CircleArrayQueue</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//测试一把</span></span><br><span class="line">        System.out.println(<span class="string">&quot;测试数组模拟环形队列的案例~~~~~&quot;</span>);</span><br><span class="line">        <span class="comment">//说明：设置4，其队列最大有效数个数为3</span></span><br><span class="line">        CircleArray circleArray = <span class="keyword">new</span> CircleArray(<span class="number">4</span>);</span><br><span class="line">        <span class="keyword">char</span> key = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">boolean</span> loop = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">//输出一个菜单</span></span><br><span class="line">        <span class="keyword">while</span> (loop) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;s(show):显示队列&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;e(exit):退出程序&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;a(add):添加数据到队列&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;g(get):从队列取出数据&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;h(head):查看队列头数据&quot;</span>);</span><br><span class="line">            key = scanner.next().charAt(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">switch</span> (key) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;s&#x27;</span>:<span class="comment">//显示队列</span></span><br><span class="line">                    circleArray.showQueue();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;e&#x27;</span>:<span class="comment">//退出程序</span></span><br><span class="line">                    scanner.close();</span><br><span class="line">                    loop = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;a&#x27;</span>:<span class="comment">//添加数据到队列</span></span><br><span class="line">                    System.out.println(<span class="string">&quot;请输入一个数&quot;</span>);</span><br><span class="line">                    <span class="keyword">int</span> value = scanner.nextInt();</span><br><span class="line">                    circleArray.addQueue(value);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;g&#x27;</span>:<span class="comment">//从队列取出数据</span></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">int</span> queue = circleArray.getQueue();</span><br><span class="line">                        System.out.printf(<span class="string">&quot;取出的数据是%d\n&quot;</span>, queue);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        System.out.println(e.getMessage());</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;h&#x27;</span>:<span class="comment">//查看队列头数据</span></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">int</span> i = circleArray.headQueue();</span><br><span class="line">                        System.out.printf(<span class="string">&quot;队列头的数据是%d\n&quot;</span>, i);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        System.out.println(e.getMessage());</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    System.out.println(<span class="string">&quot;请输出正确信息&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;程序退出&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CircleArray</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxSize;<span class="comment">//表示数组的最大容量</span></span><br><span class="line">    <span class="comment">//front 变量的含义做一个调整：front 就指向队列的第一个元素，也就是说arr[front]就是队列的第一个元素</span></span><br><span class="line">    <span class="comment">//front 的初始值 = 0</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> front;<span class="comment">//队列头</span></span><br><span class="line">    <span class="comment">//rear 变量的含义做一个调整：rear 就指向队列的最后一个元素的后一个位置，希望空出一个空间作为约定</span></span><br><span class="line">    <span class="comment">//rear 的初始值 = 0</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> rear;<span class="comment">//队列尾</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] arr;<span class="comment">//该数组用于存放数据，模拟队列</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CircleArray</span><span class="params">(<span class="keyword">int</span> arrMaxSize)</span> </span>&#123;</span><br><span class="line">        maxSize = arrMaxSize;</span><br><span class="line">        arr = <span class="keyword">new</span> <span class="keyword">int</span>[maxSize];</span><br><span class="line">        <span class="comment">//front 和 rear 初始值为0 可以不写</span></span><br><span class="line">        <span class="comment">//front = 0;</span></span><br><span class="line">        <span class="comment">//rear = 0;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断队列是否满</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFull</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (rear + <span class="number">1</span>) % maxSize == front;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断队列是否为空</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> rear == front;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加数据到队列</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addQueue</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isFull()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;队列满，无法在添加数据&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//因为rear本身就指向队列的最后一个元素的后一个元素，所以直接将数据加入</span></span><br><span class="line">        arr[rear] = n;</span><br><span class="line">        <span class="comment">//将rear后移，这里必须考虑取模</span></span><br><span class="line">        rear = (rear + <span class="number">1</span>) % maxSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取队列的数据，出队列</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//判断队列是否空</span></span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            <span class="comment">//抛出异常处理</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;队列为空,不能取数据&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//因为front本身就指向队列的第一个元素</span></span><br><span class="line">        <span class="comment">//1.先把front对应的值保留到一个临时变量</span></span><br><span class="line">        <span class="comment">//2.将front后移   考虑取模</span></span><br><span class="line">        <span class="comment">//3.将零食保存的变量返回</span></span><br><span class="line">        <span class="keyword">int</span> value = arr[front];</span><br><span class="line">        front = (front + <span class="number">1</span>) % maxSize;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//显示队列的所有数据</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//遍历</span></span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;队列为空，无数据&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//思路：从front开始遍历，遍历多少个元素</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = front; i &lt; front + size(); i++) &#123;</span><br><span class="line">            System.out.printf(<span class="string">&quot;arr[%d]=%d\n&quot;</span>, i % maxSize, arr[i % maxSize]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//求出当前队列有多少个有效数据</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//rear  =  2</span></span><br><span class="line">        <span class="comment">//front  =  1</span></span><br><span class="line">        <span class="comment">//maxSize  =  3</span></span><br><span class="line">        <span class="keyword">return</span> (rear + maxSize - front) % maxSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//显示队列的头数据，注意不是取出数据</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">headQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;队列为空,无数据&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//因为front本身就指向队列的第一个元素</span></span><br><span class="line">        <span class="keyword">return</span> arr[front];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>03.稀疏数组与队列</category>
      </categories>
      <tags>
        <tag>算法与数据结构</tag>
        <tag>稀疏数组</tag>
        <tag>队列</tag>
      </tags>
  </entry>
  <entry>
    <title>递归</title>
    <url>/2021/07/07/06.%E9%80%92%E5%BD%92/</url>
    <content><![CDATA[<h3 id="递归recursion"><a class="markdownIt-Anchor" href="#递归recursion">#</a> 递归 (Recursion)</h3>
<h4 id="递归的概念"><a class="markdownIt-Anchor" href="#递归的概念">#</a> 递归的概念</h4>
<p>递归就是方法自己调用自己，每次调用时传入不同的变量 **.**<strong> 递归有助于编程者解决复杂的问题</strong>，同时可以让代码变得简洁。</p>
<h3 id="递归的调用机制"><a class="markdownIt-Anchor" href="#递归的调用机制">#</a> 递归的调用机制</h3>
<p><a href="https://imgtu.com/i/R7ETeJ"><img src="https://z3.ax1x.com/2021/07/06/R7ETeJ.png" alt="R7ETeJ.png"></a></p>
<h4 id="代码演示"><a class="markdownIt-Anchor" href="#代码演示">#</a> 代码演示</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> demo1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RecursionTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> i = factorial(<span class="number">3</span>);</span><br><span class="line">        System.out.println(i);</span><br><span class="line">        test(<span class="number">4</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//递归</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &gt; <span class="number">2</span>) &#123;</span><br><span class="line">            test(n - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;n=&quot;</span> + n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//阶乘</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">factorial</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> factorial(n - <span class="number">1</span>) * n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="递归的用途"><a class="markdownIt-Anchor" href="#递归的用途">#</a> 递归的用途</h3>
<ul>
<li>
<p>各种数学问题如: 8 皇后问题，汉诺塔，阶乘问题，迷宫问题，球和篮子的问题 (google 编程大赛)</p>
</li>
<li>
<p>各种算法中也会使用到递归，比如快排，归并排序，二分查找，分治算法等.</p>
</li>
<li>
<p>将用栈解决的问题–&gt; 第归代码比较简洁</p>
</li>
</ul>
<h3 id="递归遵守的规则"><a class="markdownIt-Anchor" href="#递归遵守的规则">#</a> 递归遵守的规则</h3>
<ul>
<li>执行一个方法时，就创建一个新的受保护的独立空间 (栈空间)</li>
<li>方法的局部变量是独立的，不会相互影响，比如 n 变量</li>
<li>如果方法中使用的是引用类型变量 (比如数组)，就会共享该引用类型的数据.</li>
<li>递归必须向退出递归的条件逼近，否则就是无限递归，出现 StackOverflowError，死龟了：)</li>
<li>当一个方法执行完毕，或者遇到 return，就会返回，遵守谁调用，就将结果返回给谁，同时当方法执行完毕或者返回时，该方法也就执行完毕。</li>
</ul>
<h3 id="递归的案例"><a class="markdownIt-Anchor" href="#递归的案例">#</a> 递归的案例</h3>
<h4 id="迷宫问题"><a class="markdownIt-Anchor" href="#迷宫问题">#</a> 迷宫问题</h4>
<h5 id="问题介绍"><a class="markdownIt-Anchor" href="#问题介绍">#</a> 问题介绍</h5>
<p><a href="https://imgtu.com/i/R7ELJx"><img src="https://z3.ax1x.com/2021/07/06/R7ELJx.png" alt="R7ELJx.png"></a></p>
<h5 id="代码实现"><a class="markdownIt-Anchor" href="#代码实现">#</a> 代码实现</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> demo2;</span><br><span class="line"></span><br><span class="line"><span class="comment">//迷宫问题</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MiGong</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//先创建一个二维数组</span></span><br><span class="line">        <span class="comment">//模拟地图</span></span><br><span class="line">        <span class="keyword">int</span>[][] map = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">8</span>][<span class="number">7</span>];</span><br><span class="line">        <span class="comment">//使用 1 表示墙</span></span><br><span class="line">        <span class="comment">//上下全部置为 1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++) &#123;</span><br><span class="line">            map[<span class="number">0</span>][i] = <span class="number">1</span>;</span><br><span class="line">            map[<span class="number">7</span>][i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//左右全部置为 1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line">            map[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">            map[i][<span class="number">6</span>] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//设置挡板  用 1 表示</span></span><br><span class="line">        map[<span class="number">3</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        map[<span class="number">3</span>][<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">        map[<span class="number">6</span>][<span class="number">4</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//输出地图</span></span><br><span class="line">        System.out.println(<span class="string">&quot;地图情况&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">7</span>; j++) &#123;</span><br><span class="line">                System.out.print(map[i][j] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用递归回溯给小球找路</span></span><br><span class="line"></span><br><span class="line">        setWay(map, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//输出新的地图，小球走过，并标识过的地图</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;小球走过，并标识过的地图&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">7</span>; j++) &#123;</span><br><span class="line">                System.out.print(map[i][j] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用递归回溯来给小球找路</span></span><br><span class="line">    <span class="comment">//1、 map 表示地图</span></span><br><span class="line">    <span class="comment">//2、 i,j 表示哪个位置开始出发(1,1)</span></span><br><span class="line">    <span class="comment">//3、 如果小球能到map[6][5] 位置，则说明通路找到了</span></span><br><span class="line">    <span class="comment">//4、 当map[i][j] 为 0 时表示该点没有走，为 1 时表示墙；2 表示通路可以走，3 表示已经走了 但是走不通</span></span><br><span class="line">    <span class="comment">//5、 在走迷宫时，需要确定一个策略（方法） 下 -&gt; 右 -&gt; 上 -&gt; 左，如果该点走不通，在回溯</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> map 表示地图</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i   从哪个位置开始找</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> j</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 如果找到通路，就返回true，否则返回false</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">setWay</span><span class="params">(<span class="keyword">int</span>[][] map, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (map[<span class="number">6</span>][<span class="number">5</span>] == <span class="number">2</span>) &#123;<span class="comment">//表示通路已经找到</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (map[i][j] == <span class="number">0</span>) &#123;<span class="comment">//如果该点没有走过</span></span><br><span class="line">                <span class="comment">//按照策略走 下 -&gt; 右 -&gt; 上 -&gt; 左</span></span><br><span class="line">                map[i][j] = <span class="number">2</span>;<span class="comment">//假定该点可以走通</span></span><br><span class="line">                <span class="keyword">if</span> (setWay(map, i + <span class="number">1</span>, j)) &#123;<span class="comment">//向下走</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (setWay(map, i, j + <span class="number">1</span>)) &#123;<span class="comment">//向右走</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (setWay(map, i - <span class="number">1</span>, j)) &#123;<span class="comment">//向上走</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (setWay(map, i, j - <span class="number">1</span>)) &#123;<span class="comment">//向左走</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//说明该点走不通，是死路</span></span><br><span class="line">                    map[i][j] = <span class="number">3</span>;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;<span class="comment">//如果map[i][j] != 0,可能是1,2,3</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="八皇后问题"><a class="markdownIt-Anchor" href="#八皇后问题">#</a> 八皇后问题</h4>
<h5 id="问题介绍-2"><a class="markdownIt-Anchor" href="#问题介绍-2">#</a> 问题介绍</h5>
<p><a href="https://imgtu.com/i/R7ExyD"><img src="https://z3.ax1x.com/2021/07/06/R7ExyD.png" alt="R7ExyD.png"></a></p>
<h5 id="算法分析"><a class="markdownIt-Anchor" href="#算法分析">#</a> 算法分析</h5>
<ol>
<li>
<p>第一个皇后先放第一行第一列</p>
</li>
<li>
<p>第二个皇后放在第二行第一列、然后判断是否 OK [即判断是冲突]， 如果不 OK，继续放在第二列、第三列、依次把所有列都放完，找到一个合适</p>
</li>
<li>
<p>继续第三个皇后，还是第一列、第二列…… 直到第 8 个皇后也能放在一个不冲突的位置，算是找到了一个正确解</p>
</li>
<li>
<p>当得到一个正确解时，在栈回退到上一个栈时，就会开始回溯，即将第一个皇后，放到第一列的所有正确解，全部得到.</p>
</li>
<li>
<p>然后回头继续第一个皇后放第二列，后面继续循环执行 1,2,3,4 的步骤</p>
</li>
</ol>
<h5 id="说明"><a class="markdownIt-Anchor" href="#说明">#</a> 说明</h5>
<p>理论上应该创建一个二维数组来表示棋盘，但是实际上可以通过算法，用一个一维数组即可解决问题. arr [8] = {0 , 4, 7, 5, 2, 6, 1, 3} // 对应 arr 下标 表示第几行，即第几个皇后，arr [i] = val , val 表示第 i+1 个皇后，放在第 i+1 行的第 val+1 列</p>
<h5 id="代码演示-2"><a class="markdownIt-Anchor" href="#代码演示-2">#</a> 代码演示</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> demo3;</span><br><span class="line"></span><br><span class="line"><span class="comment">//八皇后问题</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Queue</span> </span>&#123;</span><br><span class="line">    <span class="comment">//先定义一个max，表示共有多少个皇后</span></span><br><span class="line">    <span class="keyword">int</span> max=<span class="number">8</span>;</span><br><span class="line">    <span class="comment">//定义数组array，保存皇后放置位置的结果，比如arr = &#123;0,4,7,5,2,6,1,3&#125;</span></span><br><span class="line">    <span class="keyword">int</span>[] array = <span class="keyword">new</span> <span class="keyword">int</span>[max];</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//测试</span></span><br><span class="line">        Queue queue = <span class="keyword">new</span> Queue();</span><br><span class="line">        queue.check(<span class="number">0</span>);</span><br><span class="line">        System.out.printf(<span class="string">&quot;一共有%d种解法&quot;</span>,count);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//编写一个方法，放置第n个皇后</span></span><br><span class="line">    <span class="comment">//特别注意：check 是 每一次递归时，进入到check都有 for (int i = 0; i &lt; max; i++)，因此会有回溯</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == max)&#123;<span class="comment">//n=8,其实八个皇后已然放好了</span></span><br><span class="line">            print();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//依次放入皇后，并判断是否冲突</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; max; i++) &#123;</span><br><span class="line">            <span class="comment">//先把当前这个皇后n,放到该行的第一列</span></span><br><span class="line">            array[n]=i;</span><br><span class="line">            <span class="comment">//判断当放置第n个皇后到i列时，是否冲突</span></span><br><span class="line">            <span class="keyword">if</span>(judge(n))&#123;</span><br><span class="line">                <span class="comment">//接着放置n+1个皇后，开始递归</span></span><br><span class="line">                check(n+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果冲突，就继续执行array[n] = i;即将第n个皇后，放置在本行的后移一个位置</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查看当我们放置第n个皇后时，就去检测该皇后是否和前面已经摆放的皇后冲突</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> n 表示第n皇后</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">judge</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="comment">//1.array[i]==array[n]  表示判断 第n个皇后是否和前面的n-1个皇后在同一列</span></span><br><span class="line">            <span class="comment">//2.Math.abs(n-i)==Math.abs(array[n]-array[i])  表示判断第n个皇后是否和第i个皇后在同一斜线上</span></span><br><span class="line">            <span class="keyword">if</span>(array[i]==array[n] || Math.abs(n-i)==Math.abs(array[n]-array[i]))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//写一个方法，可以将皇后摆放的位置输出</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">        count++;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">            System.out.print(array[i]+<span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>06.递归</category>
      </categories>
      <tags>
        <tag>算法与数据结构</tag>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title>哈希表</title>
    <url>/2021/07/07/09.%E5%93%88%E5%B8%8C%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="哈希表"><a class="markdownIt-Anchor" href="#哈希表">#</a> 哈希表</h1>
<h2 id="基本介绍"><a class="markdownIt-Anchor" href="#基本介绍">#</a> 基本介绍</h2>
<p><strong>散列表</strong>（Hash table，也叫哈希表）</p>
<p>​	根据关键码值（key value）而直接进行访问<strong>数据结构</strong>。也就是说，他通过吧关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做<strong>散列函数</strong>，存放记录的数组叫做<strong>散列表</strong></p>
<p><a href="https://imgtu.com/i/R7mCTJ"><img src="https://z3.ax1x.com/2021/07/06/R7mCTJ.png" alt="R7mCTJ.png"></a></p>
<p><a href="https://imgtu.com/i/R7mFYR"><img src="https://z3.ax1x.com/2021/07/06/R7mFYR.png" alt="R7mFYR.png"></a></p>
<p><a href="https://imgtu.com/i/R7e7wQ"><img src="https://z3.ax1x.com/2021/07/06/R7e7wQ.png" alt="R7e7wQ.png"></a></p>
<h3 id="例题"><a class="markdownIt-Anchor" href="#例题">#</a> 例题</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">有一个公司,当有新的员工来报道时,要求将该员工的信息加入(id,性别,年龄,名字,住址..),当输入该员工的id时,要求查找到该员工的所有信息.</span><br><span class="line">要求: </span><br><span class="line">不使用数据库,,速度越快越好=&gt;哈希表(散列)</span><br><span class="line">添加时，保证按照id从低到高插入  </span><br><span class="line">[课后思考：如果id不是从低到高插入，但要求各条链表仍是从低到高，怎么解决?]</span><br></pre></td></tr></table></figure>
<p><a href="https://imgtu.com/i/R7mkf1"><img src="https://z3.ax1x.com/2021/07/06/R7mkf1.png" alt="R7mkf1.png"></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> demo01;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashTabDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建哈希表</span></span><br><span class="line">        HashTab hashTab=<span class="keyword">new</span> HashTab(<span class="number">7</span>);</span><br><span class="line">        <span class="comment">//写一个简单陈的菜单</span></span><br><span class="line">        String key=<span class="string">&quot;&quot;</span>;</span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;add:  添加雇员&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;list: 显示雇员&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;find: 查找雇员&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;exit: 退出系统&quot;</span>);</span><br><span class="line"></span><br><span class="line">            key=scanner.next();</span><br><span class="line">            <span class="keyword">switch</span> (key)&#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;add&quot;</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;输入id&quot;</span>);</span><br><span class="line">                    <span class="keyword">int</span> id = scanner.nextInt();</span><br><span class="line">                    System.out.println(<span class="string">&quot;输入姓名&quot;</span>);</span><br><span class="line">                    String name = scanner.next();</span><br><span class="line">                    <span class="comment">//创建雇员</span></span><br><span class="line">                    Emp emp=<span class="keyword">new</span> Emp(id,name);</span><br><span class="line">                    hashTab.add(emp);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;list&quot;</span>:</span><br><span class="line">                    hashTab.list();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;find&quot;</span>:</span><br><span class="line">                    System.out.println(<span class="string">&quot;请输入查找的 id&quot;</span>);</span><br><span class="line">                    id = scanner.nextInt();</span><br><span class="line">                    hashTab.findEmpById(id);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;exit&quot;</span>:</span><br><span class="line">                    scanner.close();</span><br><span class="line">                    System.exit(<span class="number">0</span>);</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建HashTable 管理多条链表</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HashTab</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> EmpLinkedList[] empLinkedListArray;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;  <span class="comment">//表示共有多少条链表</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashTab</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.size=size;</span><br><span class="line">        <span class="comment">//初始化 empLinkedListArray</span></span><br><span class="line">        empLinkedListArray = <span class="keyword">new</span> EmpLinkedList[size];</span><br><span class="line">        <span class="comment">// ?????这是不要忘了分别初始化每条链表</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            empLinkedListArray[i]=<span class="keyword">new</span> EmpLinkedList();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加雇员</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Emp emp)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//根据员工的id，得到该员工应当添加到那条链表</span></span><br><span class="line">        <span class="keyword">int</span> empLinkListNO=hashFun(emp.id);</span><br><span class="line">        <span class="comment">//将emp 添加到对应的链表中</span></span><br><span class="line">        empLinkedListArray[empLinkListNO].add(emp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历所有的链表,遍历hashTab</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">list</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            empLinkedListArray[i].list(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据输入的id，查找雇员</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">findEmpById</span><span class="params">(<span class="keyword">int</span> id)</span></span>&#123;</span><br><span class="line">        <span class="comment">//使用散列函数确定到哪条链表查找</span></span><br><span class="line">        <span class="keyword">int</span> empLinkedListNO=hashFun(id);</span><br><span class="line">        Emp emp=empLinkedListArray[empLinkedListNO].findEmpById(id);</span><br><span class="line">        <span class="keyword">if</span> (emp!=<span class="keyword">null</span>)&#123;<span class="comment">//找到</span></span><br><span class="line">            System.out.printf(<span class="string">&quot;在第 %d 链表中找到 雇员 id=%d\n&quot;</span>,(empLinkedListNO+<span class="number">1</span>),id);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;在哈希表中，没有找到该雇员~~&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//编写一个散列函数，使用一个简单的取模法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashFun</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id % size;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//表示 一个雇员</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Emp</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> Emp next;  <span class="comment">//  next 默认为null</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Emp</span><span class="params">(<span class="keyword">int</span> id, String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建 EmpLinkedList，表示链表</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EmpLinkedList</span> </span>&#123;</span><br><span class="line">    <span class="comment">//头指针，指向第一个Emp，因此我们这个链表的head是直接指向第一个 Emp</span></span><br><span class="line">    <span class="keyword">private</span> Emp head; <span class="comment">//默认为null</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加雇员到链表</span></span><br><span class="line">    <span class="comment">//说明</span></span><br><span class="line">    <span class="comment">//1.假定，当添加雇员时，id 是自增长的，即id的分配总是从小到大</span></span><br><span class="line">    <span class="comment">//   因此我们将该雇员直接加入到本链表的最后即可</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Emp emp)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//如果是添加第一个雇员</span></span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">            head = emp;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果不是第一个雇员，则使用一个辅助 指针，帮助定位到最后</span></span><br><span class="line">        Emp curEmp = head;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (curEmp.next == <span class="keyword">null</span>) &#123;<span class="comment">//说明到链表最后</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            curEmp = curEmp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//退出时直接将 emp 加入到链表</span></span><br><span class="line">        curEmp.next = emp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历链表的雇员信息</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">list</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//说明链表为 null</span></span><br><span class="line">            System.out.println(<span class="string">&quot;第&quot;</span>+(no+<span class="number">1</span>)+<span class="string">&quot;条链表为 null&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.print(<span class="string">&quot;第&quot;</span>+(no+<span class="number">1</span>)+<span class="string">&quot;条链表的信息为：&quot;</span>);</span><br><span class="line">        Emp curEmp = head;<span class="comment">//辅助指针</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            System.out.printf(<span class="string">&quot;=&gt; id=%d,name=%s\n&quot;</span>, curEmp.id, curEmp.name);</span><br><span class="line">            <span class="keyword">if</span> (curEmp.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//说明curEmp 已经是最后一个节点</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            curEmp = curEmp.next;<span class="comment">//后移</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据id查找雇员</span></span><br><span class="line">    <span class="comment">//如果查找到，就返回Emp，如果没找到，就返回 null</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Emp <span class="title">findEmpById</span><span class="params">(<span class="keyword">int</span> id)</span></span>&#123;</span><br><span class="line">        <span class="comment">//判断链表是否为 null</span></span><br><span class="line">        <span class="keyword">if</span>(head==<span class="keyword">null</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;链表为 null&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//辅助指针</span></span><br><span class="line">        Emp curEmp=head;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(curEmp.id==id)&#123;<span class="comment">//找到</span></span><br><span class="line">                <span class="keyword">break</span>;<span class="comment">//这时curEmp就指向要查找的雇员</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//退出条件</span></span><br><span class="line">            <span class="keyword">if</span>(curEmp.next==<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="comment">//说明遍历当前链表没有找到该雇员</span></span><br><span class="line">                curEmp=<span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            curEmp=curEmp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> curEmp;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>09.哈希表</category>
      </categories>
      <tags>
        <tag>算法与数据结构</tag>
        <tag>哈希表</tag>
      </tags>
  </entry>
  <entry>
    <title>查找算法</title>
    <url>/2021/07/07/08.%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="查找算法介绍"><a class="markdownIt-Anchor" href="#查找算法介绍">#</a> 查找算法介绍</h1>
<p>在 java 中，我们常用的查找有四种：</p>
<ol>
<li>顺序（线性）查找</li>
<li>二分查找 / 折半查找</li>
<li>插值查找</li>
<li>斐波那契查找</li>
</ol>
<h2 id="顺序线性查找算法"><a class="markdownIt-Anchor" href="#顺序线性查找算法">#</a> 顺序（线性）查找算法</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SeqSearch</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr=&#123;<span class="number">1</span>,<span class="number">8</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">74</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">1</span>,<span class="number">6</span>,-<span class="number">238</span>&#125;;<span class="comment">//无序数组</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> index = seqSearch(arr,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (index == -<span class="number">1</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;没有找到&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;找到该值下标为&quot;</span>+index);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//普通的线性查找</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">seqSearch</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">        <span class="comment">//线性查找是注意比较，发现有相同值，就返回下标</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] == value) &#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="二分查找-折半查找算法"><a class="markdownIt-Anchor" href="#二分查找-折半查找算法">#</a> 二分查找 / 折半查找算法</h2>
<p><a href="https://imgtu.com/i/R7e1MT"><img src="https://z3.ax1x.com/2021/07/06/R7e1MT.png" alt="R7e1MT.png"></a></p>
<h3 id="代码示例"><a class="markdownIt-Anchor" href="#代码示例">#</a> 代码示例</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> demo02;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//二分查找必须保证该数组是有序的</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinarySearch</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>, <span class="number">8</span>, <span class="number">10</span>, <span class="number">89</span>, <span class="number">100</span>,<span class="number">100</span>,<span class="number">100</span>, <span class="number">213</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> resIndex=binarySearch(arr,<span class="number">0</span>,arr.length,<span class="number">100</span>);</span><br><span class="line">        System.out.println(resIndex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr     数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> left    左边的索引</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> right   右边的索引</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> findVal 需要查找的值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 如果找到就返回下标，没有找到就返回-1</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> findVal)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> midVal = arr[mid];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(left&gt;right)&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (findVal &gt; midVal) &#123;<span class="comment">//向右递归</span></span><br><span class="line">            <span class="keyword">return</span> binarySearch(arr, mid + <span class="number">1</span>, right, findVal);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (findVal &lt; midVal) &#123;<span class="comment">//向左递归</span></span><br><span class="line">            <span class="keyword">return</span> binarySearch(arr, left, mid - <span class="number">1</span>, findVal);</span><br><span class="line">        &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="进阶代码"><a class="markdownIt-Anchor" href="#进阶代码">#</a> 进阶代码</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> demo02;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *课后习题：</span></span><br><span class="line"><span class="comment"> * &#123;1, 8, 10, 89, 100,100,100, 213&#125;当一个有序数组中</span></span><br><span class="line"><span class="comment"> * 有多个相同数值时，如何将所有的数值都查找到</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 思路分析：</span></span><br><span class="line"><span class="comment"> * 1、在找到mid 索引值，不需要马上返回</span></span><br><span class="line"><span class="comment"> * 2、向mid 索引值的左边扫描，将所有满足 100 的元素的下标，加入到集合 ArrayList 中</span></span><br><span class="line"><span class="comment"> * 3、向mid 索引值的右边扫描，将所有满足 100 的元素的下标，加入到集合 ArrayList</span></span><br><span class="line"><span class="comment"> * 4、将 ArrayList 返回</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">//二分查找必须保证该数组是有序的</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinarySearch_pro</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>, <span class="number">8</span>, <span class="number">10</span>, <span class="number">89</span>, <span class="number">100</span>,<span class="number">100</span>,<span class="number">100</span>, <span class="number">213</span>&#125;;</span><br><span class="line"></span><br><span class="line">        ArrayList&lt;Integer&gt; integers = binarySearch_pro(arr, <span class="number">0</span>, arr.length-<span class="number">1</span>, <span class="number">100</span>);</span><br><span class="line">        System.out.println(integers);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr     数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> left    左边的索引</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> right   右边的索引</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> findVal 需要查找的值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 如果找到就返回下标，没有找到就返回-1</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ArrayList&lt;Integer&gt; <span class="title">binarySearch_pro</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> findVal)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> midVal = arr[mid];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(left&gt;right)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (findVal &gt; midVal) &#123;<span class="comment">//向右递归</span></span><br><span class="line">            <span class="keyword">return</span> binarySearch_pro(arr, mid + <span class="number">1</span>, right, findVal);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (findVal &lt; midVal) &#123;<span class="comment">//向左递归</span></span><br><span class="line">            <span class="keyword">return</span> binarySearch_pro(arr, left, mid - <span class="number">1</span>, findVal);</span><br><span class="line">        &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 思路分析：</span></span><br><span class="line"><span class="comment">             * 1、在找到mid 索引值，不需要马上返回</span></span><br><span class="line"><span class="comment">             * 2、向mid 索引值的左边扫描，将所有满足 100 的元素的下标，加入到集合 ArrayList中</span></span><br><span class="line"><span class="comment">             * 3、向mid 索引值的右边扫描，将所有满足 100 的元素的下标，加入到集合 ArrayList</span></span><br><span class="line"><span class="comment">             * 4、将 ArrayList 返回</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            ArrayList&lt;Integer&gt; resIndexList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="comment">//向mid 索引值的左边扫描，将所有满足 100 的元素的下标，加入到集合 ArrayList 中</span></span><br><span class="line">            <span class="keyword">int</span> temp=mid-<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span> (temp&lt;<span class="number">0</span>||arr[temp]!=findVal)&#123;</span><br><span class="line">                    <span class="comment">//退出</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//否则，就将temp放入到resIndexList 中</span></span><br><span class="line">                resIndexList.add(temp);</span><br><span class="line">                temp-=<span class="number">1</span>; <span class="comment">//temp 左移</span></span><br><span class="line">            &#125;</span><br><span class="line">            resIndexList.add(mid);</span><br><span class="line">            <span class="comment">//向mid 索引值的右边扫描，将所有满足 100 的元素的下标，加入到集合 ArrayList</span></span><br><span class="line">            temp=mid+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span> (temp&gt;arr.length-<span class="number">1</span> || arr[temp]!=findVal)&#123;</span><br><span class="line">                    <span class="comment">//退出</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//否则，就将temp放入到resIndexList 中</span></span><br><span class="line">                resIndexList.add(temp);</span><br><span class="line">                temp+=<span class="number">1</span>; <span class="comment">//temp 右移</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> resIndexList;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="插值查找算法"><a class="markdownIt-Anchor" href="#插值查找算法">#</a> 插值查找算法</h2>
<h3 id="原理介绍"><a class="markdownIt-Anchor" href="#原理介绍">#</a> 原理介绍</h3>
<ol>
<li>
<p>插值查找算法类似于二分查找，不同的是插值查找每次从<strong>自适应</strong> mid 处开始查找。</p>
</li>
<li>
<p>将折半查找中的求 mid 索引的公式，low 表示左边索引 left, high 表示右边索引 right。key 就是前面我们讲的 findVal</p>
<p><a href="https://imgtu.com/i/R7eJZ4"><img src="https://z3.ax1x.com/2021/07/06/R7eJZ4.png" alt="R7eJZ4.png"></a></p>
</li>
<li>
<p>int mid = low + (high - low) * (key - arr[low]) / (arr[high] - arr[low]) ;   <em>插值索引</em><br>
对应前面的代码公式：<br>
int mid = left + (right – left) * (findVal – arr[left]) / (arr[right] – arr[left])</p>
</li>
</ol>
<p><a href="https://imgtu.com/i/R7edRx"><img src="https://z3.ax1x.com/2021/07/06/R7edRx.png" alt="R7edRx.png"></a></p>
<h3 id="注意事项"><a class="markdownIt-Anchor" href="#注意事项">#</a> 注意事项</h3>
<ol>
<li>
<p>对于数据量较大，<strong>关键字分布比较均匀</strong>的查找表来说，采用<strong>插值查找，速度较快.</strong></p>
</li>
<li>
<p>关键字分布不均匀的情况下，该方法不一定比折半查找要好</p>
</li>
</ol>
<h3 id="代码展示"><a class="markdownIt-Anchor" href="#代码展示">#</a> 代码展示</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> demo03;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InsertValueSearch</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">100</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            arr[i] = i + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> index = insertValueSearch(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;index=&quot;</span>+index);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 编写插值查找算法</span></span><br><span class="line"><span class="comment">     * 说明：插值查找算法也要求数组是有序的</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr     数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> left    左边索引</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> right   右边索引</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> findVal 查找的值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 如果找到就返回对应的下标，没有就返回 -1</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">insertValueSearch</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> findVal)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断退出</span></span><br><span class="line">        <span class="keyword">if</span> (left &gt; right || findVal &lt; arr[<span class="number">0</span>] || findVal &gt; arr[arr.length - <span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//求出 mid</span></span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) * (findVal - arr[left]) / (arr[right] - arr[left]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> midVal=arr[mid];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(findVal&gt;midVal)&#123; <span class="comment">//说明应该向右边递归查找</span></span><br><span class="line">            <span class="keyword">return</span> insertValueSearch(arr,mid+<span class="number">1</span>,right,findVal);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(findVal&lt;midVal)&#123; <span class="comment">//说明应该向左边递归查找</span></span><br><span class="line">            <span class="keyword">return</span> insertValueSearch(arr,left,mid-<span class="number">1</span>,findVal);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="斐波那契查找算法"><a class="markdownIt-Anchor" href="#斐波那契查找算法">#</a> 斐波那契查找算法</h2>
<h3 id="基本介绍"><a class="markdownIt-Anchor" href="#基本介绍">#</a> 基本介绍</h3>
<p>黄金分割点是指把一条<a href="">线段</a>分割为两部分，使其中一部分与全长之比等于另一部分与这部分之比。取其前三位数字的近似值是<a href=""> 0.618</a>。由于按此比例设计的造型十分美丽，因此称为<a href="">黄金分割</a>，也称为<a href="">中外比</a>。这是一个神奇的数字，会带来意向不大的效果。</p>
<p><strong>斐波那契数列</strong> {1, 1, 2, 3, 5, 8, 13, 21, 34, 55} 发现斐波那契数列的两个相邻数 的比例，无限接近 黄金分割值 0.618</p>
<h3 id="原理分析"><a class="markdownIt-Anchor" href="#原理分析">#</a> 原理分析</h3>
<p><strong>斐波那契 (黄金分割法) 原理:</strong></p>
<p><strong>斐波那契查找</strong>原理与前两种相似，仅仅改变了中间结点（mid）的位置，mid 不再是中间或插值得到，而是位于黄金分割点附近，即<strong> mid=low+F (k-1)-1</strong>（F 代表斐波那契数列），如下图所示</p>
<p><a href="https://imgtu.com/i/R7ecod"><img src="https://z3.ax1x.com/2021/07/06/R7ecod.png" alt="R7ecod.png"></a></p>
<p><strong>对 F (k-1)-1 的理解：</strong></p>
<p>1、由斐波那契数列 <strong>F[k]=F[k-1]+F[k-2]</strong> 的性质，可以得到 <strong>（F[k]-1）=（F[k-1]-1）+（F[k-2]-1）+1</strong> 。该式说明：只要顺序表的长度为<strong> F [k]-1</strong>，则可以将该表分成长度为<strong> F [k-1]-1</strong> 和<strong> F [k-2]-1</strong> 的两段，即如上图所示。从而中间位置为<strong> mid=low+F (k-1)-1</strong></p>
<p>2、类似的，每一子段也可以用相同的方式分割</p>
<p>3、但顺序表长度 n 不一定刚好等于 F [k]-1，所以需要将原来的顺序表长度 n 增加至 F [k]-1。这里的 k 值只要能使得 F [k]-1 恰好大于或等于 n 即可，由以下代码得到，顺序表长度增加后，新增的位置（从 n+1 到 F [k]-1 位置），都赋为 n 位置的值即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(n&gt;fib(k)-<span class="number">1</span>)</span><br><span class="line">    k++;</span><br></pre></td></tr></table></figure>
<h3 id="代码分析"><a class="markdownIt-Anchor" href="#代码分析">#</a> 代码分析</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> demo04;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Fibonaci</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> maxSize = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>, <span class="number">8</span>, <span class="number">10</span>, <span class="number">89</span>, <span class="number">1000</span>, <span class="number">1024</span>&#125;;</span><br><span class="line">        System.out.println(fibSearch(arr, <span class="number">8</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//因为后面 mid=low+F(k-1)-1,需要使用斐波那契数列，所以先获取到一个菲波那契数列</span></span><br><span class="line">    <span class="comment">//非递归方式得到一个斐波那契数列</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] fib() &#123;</span><br><span class="line">        <span class="keyword">int</span>[] f = <span class="keyword">new</span> <span class="keyword">int</span>[maxSize];</span><br><span class="line">        f[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        f[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; maxSize; i++) &#123;</span><br><span class="line">            f[i] = f[i - <span class="number">1</span>] + f[i - <span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> a   数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 需要查找的数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回对应的下标，如果没有就返回-1；</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">//编写斐波那契算法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">fibSearch</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> high = a.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">0</span>;<span class="comment">//表示斐波那契数值下标</span></span><br><span class="line">        <span class="keyword">int</span> mid = <span class="number">0</span>;<span class="comment">//放mid 的值</span></span><br><span class="line">        <span class="keyword">int</span>[] f = fib();<span class="comment">//获取斐波那契数列</span></span><br><span class="line">        <span class="comment">//获取斐波那契分割数值的下标</span></span><br><span class="line">        <span class="keyword">while</span> (high &gt; f[k] - <span class="number">1</span>) &#123;</span><br><span class="line">            k++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//因为f[k] 值可能大于 a 的长度，因此我们需要使用Arrays类，构造一个新的数组，并指向temp[]</span></span><br><span class="line">        <span class="comment">//不足的部分会使用 0 填充</span></span><br><span class="line">        <span class="keyword">int</span>[] temp = Arrays.copyOf(a, f[k]);</span><br><span class="line">        <span class="comment">//实际上需要使用a数组最后的数据填充temp</span></span><br><span class="line">        <span class="comment">//举例：</span></span><br><span class="line">        <span class="comment">//&#123;1,8,10,89,1000,1024,0,0,0&#125; -----&gt; &#123;1,8,10,89,1000,1024,1024,1024,1024&#125;</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = high + <span class="number">1</span>; i &lt; temp.length; i++) &#123;</span><br><span class="line">            temp[i] = a[high];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用while来循环处理，找到我们的数 key</span></span><br><span class="line">        <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">            mid =low + f[k - <span class="number">1</span>] - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (key &lt; temp[mid]) &#123;<span class="comment">//向数组左边查找</span></span><br><span class="line">                high = mid - <span class="number">1</span>;</span><br><span class="line">                <span class="comment">//为什么是k--</span></span><br><span class="line">                <span class="comment">//说明</span></span><br><span class="line">                <span class="comment">//1.全部元素 = 前面的元素 + 后面的元素</span></span><br><span class="line">                <span class="comment">//2.f[k] = f[k-1] +f[k-2]</span></span><br><span class="line">                <span class="comment">//3.因为前面有f[k-1] 个元素，所有可以继续拆分f[k-1]=f[k-2]+f[k-3]</span></span><br><span class="line">                <span class="comment">//即 在f[k-1] 的前面继续查找 k--</span></span><br><span class="line">                <span class="comment">//即下次循环 mid=f[k-1-1]-1</span></span><br><span class="line">                k--;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key &gt; temp[mid]) &#123;<span class="comment">//向数组右边查找</span></span><br><span class="line">                low = mid + <span class="number">1</span>;</span><br><span class="line">                <span class="comment">//为什么是k-=2;</span></span><br><span class="line">                <span class="comment">//说明</span></span><br><span class="line">                <span class="comment">//1.全部元素 = 前面的元素 + 后面的元素</span></span><br><span class="line">                <span class="comment">//2.f[k] = f[k-1] +f[k-2]</span></span><br><span class="line">                <span class="comment">//3.因为前面有f[k-2] 个元素，所有可以继续拆分f[k-2]=f[k-3]+f[k-4]</span></span><br><span class="line">                <span class="comment">//即 在f[k-2] 的前面继续查找 k-=2</span></span><br><span class="line">                <span class="comment">//即下次循环 mid=f[k-1-2]-1</span></span><br><span class="line">                k -= <span class="number">2</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;<span class="comment">//找到</span></span><br><span class="line">                <span class="comment">//需要确定，返回的是哪个下标</span></span><br><span class="line">                <span class="keyword">if</span> (mid &lt;= high) &#123;</span><br><span class="line">                    <span class="keyword">return</span> mid;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> high;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>08.查找算法</category>
      </categories>
      <tags>
        <tag>算法与数据结构</tag>
        <tag>线性查找</tag>
        <tag>二分/折半查找</tag>
        <tag>插值查找</tag>
        <tag>斐波那契查找</tag>
      </tags>
  </entry>
  <entry>
    <title>多路查找树</title>
    <url>/2021/07/08/12.%E5%A4%9A%E8%B7%AF%E6%9F%A5%E6%89%BE%E6%A0%91/</url>
    <content><![CDATA[<h2 id="二叉树存在的问题"><a class="markdownIt-Anchor" href="#二叉树存在的问题">#</a> 二叉树存在的问题</h2>
<p>二叉树的操作效率较高，但是也存在问题，请看下面的二叉树</p>
<p><a href="https://imgtu.com/i/R7fPMj"><img src="https://z3.ax1x.com/2021/07/07/R7fPMj.png" alt="R7fPMj.png"></a></p>
<p>1)<strong> 二叉树需要加载到内存的，如果二叉树的节点少，没有什么问题，但是如果二叉树的节点很多 (比如 1 亿)， 就存在如下问题:</strong></p>
<p>2)<strong> 问题 1：在构建二叉树时，需要多次进行 i/o 操作 (海量数据存在数据库或文件中)，节点海量，构建二叉树时，速度有影响</strong></p>
<p>3)<strong> 问题 2：节点海量，也会造成二叉树的高度很大，会降低操作速度.</strong></p>
<h2 id="多叉树"><a class="markdownIt-Anchor" href="#多叉树">#</a> 多叉树</h2>
<ul>
<li>
<p>在二叉树中，每个节点有数据项，最多有两个子节点。1) 如果<strong>允许每个节点可以有更多的数据项和更多的子节点</strong>，就是<strong>多叉树（multiway tree）</strong></p>
</li>
<li>
<p><strong>后面我们讲解的 2-3 树，2-3-4 树就是多叉树，多叉树通过重新组织节点，减少树的高度，能对二叉树进行优化。</strong></p>
</li>
<li>
<p><strong>下面 2-3 树就是一颗多叉树</strong></p>
</li>
</ul>
<p><a href="https://imgtu.com/i/R7fAZq"><img src="https://z3.ax1x.com/2021/07/07/R7fAZq.png" alt="R7fAZq.png"></a></p>
<h2 id="b树"><a class="markdownIt-Anchor" href="#b树">#</a> B 树</h2>
<p>B 树通过重新组织节点，降低树的高度，并且减少 i/o 读写次数来提升效率。</p>
<p><a href="https://imgtu.com/i/R7fnWF"><img src="https://z3.ax1x.com/2021/07/07/R7fnWF.png" alt="R7fnWF.png"></a>1)<strong> 如图 B 树通过重新组织节点， 降低了树的高度.</strong></p>
<p>2)<strong> 文件系统及数据库系统的设计者利用了磁盘预读原理，将一个节点的大小设为等于一个页 (页得大小通常为 4k)，这样每个节点只需要一次 I/O 就可以完全载入</strong></p>
<p>3) 将树的度 M 设置为 1024，在 600 亿个元素中最多只需要 4 次 I/O 操作就可以读取到想要的元素，B 树 (B+) 广泛应用于文件存储系统以及数据库系统中</p>
<p>​		结点的度：就是一个结点下面的子树个数有几个</p>
<p>​		树的度：指定所有的结点里面度的最大值，就是树的度</p>
<h2 id="2-3树"><a class="markdownIt-Anchor" href="#2-3树">#</a> 2-3 树</h2>
<p>2-3 树是最简单的 B 树结构，有以下特点</p>
<ol>
<li><strong>2-3 树的所有叶子节点都在同一层（只要是 B 树都满足这个条件）</strong></li>
<li>有两个子节点的节点叫做二节点，二节点要么没有子节点，要么有两个子节点</li>
<li>有三个子节点的节点叫做三节点，三节点要么没有子节点，要么有三个子节点</li>
<li>2-3 树是由二节点和三节点构成的数</li>
</ol>
<h3 id="实例"><a class="markdownIt-Anchor" href="#实例">#</a> 实例</h3>
<p>问题：将数列 {16, 24, 12, 32, 14, 26, 34, 10, 8, 28, 38, 20} 构建成 2-3 树，并保证数据插入的<br>
大小顺序。(演示一下构建 2-3 树的过程.)</p>
<p><strong>插入规则:</strong></p>
<ol>
<li>
<p>2-3 树的所有叶子节点都在同一层.(只要是 B 树都满足这个条件)</p>
</li>
<li>
<p>有两个子节点的节点叫二节点，二节点要么没有子节点，要么有两个子节点.</p>
</li>
<li>
<p>有三个子节点的节点叫三节点，三节点要么没有子节点，要么有三个子节点</p>
</li>
<li>
<p>当按照规则插入一个数到某个节点时，不能满足上面三个要求，就需要拆，先向上拆，如果上层满，则拆本层，后仍然需要满足上面 3 个条件。</p>
</li>
<li>
<p>对于三节点的子树的值大小仍然遵守 (BST 二叉排序树) 的规则</p>
</li>
</ol>
<p><a href="https://imgtu.com/i/R7fQy9"><img src="https://z3.ax1x.com/2021/07/07/R7fQy9.png" alt="R7fQy9.png"></a></p>
<p><a href="https://imgtu.com/i/R7f8dx"><img src="https://z3.ax1x.com/2021/07/07/R7f8dx.png" alt="R7f8dx.png"></a></p>
<h2 id="b树-2"><a class="markdownIt-Anchor" href="#b树-2">#</a> B 树</h2>
<p>**<a href="">B-tree</a><strong> 树即<a href=""> B 树</a></strong>，B 即 Balanced，平衡的意思。有人把 B-tree 翻译成 B - 树，容易让人产生误解。会以为 B - 树是一种树，而 B 树又是另一种树。** 实际上，<strong>B-tree 就是指的 B 树。</strong></p>
<p>前面已经介绍了 2-3 树和 2-3-4 树，他们就是 B 树 (英语：B-tree 也写成 B - 树)，这里我们再做一个说明，我们在学习 Mysql 时，经常听到说某种类型的索引是基于 B 树或者 B + 树的，如图:</p>
<p><a href="https://imgtu.com/i/R7fYFK"><img src="https://z3.ax1x.com/2021/07/07/R7fYFK.png" alt="R7fYFK.png"></a></p>
<p><strong>B 树的说明：</strong></p>
<ol>
<li>
<p>B 树的阶：节点的最多子节点个数。比如 2-3 树的阶是 3，2-3-4 树的阶是 4</p>
</li>
<li>
<p>B - 树的搜索，从根结点开始，对结点内的关键字（有序）序列进行二分查找，如果命中则结束，否则进入查询关键字所属范围的儿子结点；重复，直到所对应的儿子指针为空，或已经是叶子结点</p>
</li>
<li>
<p>关键字集合分布在整颗树中，即叶子节点和非叶子节点都存放数据.</p>
</li>
<li>
<p>搜索有可能在非叶子结点结束</p>
</li>
<li>
<p>其搜索性能等价于在关键字全集内做一次二分查找</p>
</li>
</ol>
<h2 id="b树-3"><a class="markdownIt-Anchor" href="#b树-3">#</a> B + 树</h2>
<p>B + 树是 B 树的变体，也是一种多路搜索树。</p>
<p><a href="https://imgtu.com/i/R7fwyd"><img src="https://z3.ax1x.com/2021/07/07/R7fwyd.png" alt="R7fwyd.png"></a></p>
<p><strong>B + 树的说明:</strong></p>
<ol>
<li>
<p>B + 树的搜索与 B 树也基本相同，区别是 B + 树只有达到叶子结点才命中（B 树可以在非叶子结点命中），其性能也等价于在关键字全集做一次二分查找</p>
</li>
<li>
<p>所有<strong>关键字都出现在叶子结点的链表中</strong>（即数据只能在叶子节点【也叫稠密索引】），且链表中的关键字 (数据) 恰好是有序的。</p>
</li>
<li>
<p>不可能在非叶子结点命中</p>
</li>
<li>
<p>非叶子结点相当于是叶子结点的索引（稀疏索引），叶子结点相当于是存储（关键字）数据的数据层</p>
</li>
<li>
<p>更适合文件索引系统</p>
</li>
<li>
<p>B 树和 B + 树各有自己的应用场景，不能说 B + 树<strong>完全比</strong> B 树好，反之亦然.</p>
</li>
</ol>
<h2 id="b树-4"><a class="markdownIt-Anchor" href="#b树-4">#</a> B * 树</h2>
<p>B * 树是 B + 树的变体，在 B + 树的非根和非叶子结点再增加指向兄弟的指针。</p>
<p><a href="https://imgtu.com/i/R7fgfS"><img src="https://z3.ax1x.com/2021/07/07/R7fgfS.png" alt="R7fgfS.png"></a></p>
<p><strong>B * 树的说明:</strong></p>
<ol>
<li>
<p>B* 树定义了非叶子结点关键字个数至少为 (2/3) * M，即<strong>块的最低使用率为 2/3</strong>，而<strong> B + 树的块的最低使用率为 1/2</strong>。   M: 树的度</p>
</li>
<li>
<p>从第 1 个特点我们可以看出，B * 树分配新结点的概率比 B + 树要低，空间使用率更高</p>
</li>
</ol>
]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>12.多路查找树</category>
      </categories>
      <tags>
        <tag>算法与数据结构</tag>
        <tag>多叉树</tag>
        <tag>B树</tag>
        <tag>B+树</tag>
        <tag>B×树</tag>
      </tags>
  </entry>
  <entry>
    <title>CSDN路线图</title>
    <url>/2021/06/30/CSDN/</url>
    <content><![CDATA[<p><a href="https://blog.csdn.net/One_L_Star/article/details/102394373">https://blog.csdn.net/One_L_Star/article/details/102394373</a><a href="https://imgtu.com/i/RU1A3D"><img src="https://z3.ax1x.com/2021/06/28/RU1A3D.png" alt="RU1A3D.png"></a><br>
<a href="https://imgtu.com/i/RU1VjH"><img src="https://z3.ax1x.com/2021/06/28/RU1VjH.png" alt="RU1VjH.png"></a><br>
<a href="https://imgtu.com/i/RU1eud"><img src="https://z3.ax1x.com/2021/06/28/RU1eud.png" alt="RU1eud.png"></a><br>
<a href="https://imgtu.com/i/RU1nHI"><img src="https://z3.ax1x.com/2021/06/28/RU1nHI.png" alt="RU1nHI.png"></a><br>
<a href="https://imgtu.com/i/RU1KEt"><img src="https://z3.ax1x.com/2021/06/28/RU1KEt.png" alt="RU1KEt.png"></a></p>
<p><a href="https://imgtu.com/i/RU1Ege"><img src="https://z3.ax1x.com/2021/06/28/RU1Ege.png" alt="RU1Ege.png"></a><br>
<a href="https://imgtu.com/i/RU1i4K"><img src="https://z3.ax1x.com/2021/06/28/RU1i4K.png" alt="RU1i4K.png"></a><br>
<a href="https://imgtu.com/i/RU1k9O"><img src="https://z3.ax1x.com/2021/06/28/RU1k9O.png" alt="RU1k9O.png"></a></p>
]]></content>
      <categories>
        <category>路线图</category>
      </categories>
      <tags>
        <tag>路线图</tag>
      </tags>
  </entry>
  <entry>
    <title>尚硅谷路线图</title>
    <url>/2021/06/30/%E5%B0%9A%E7%A1%85%E8%B0%B7%E8%B7%AF%E7%BA%BF%E5%9B%BE/</url>
    <content><![CDATA[<p><a href="https://imgtu.com/i/RUnSBV"><img src="https://z3.ax1x.com/2021/06/28/RUnSBV.jpg" alt="RUnSBV.jpg"></a></p>
<p><a href="https://imgtu.com/i/RUnQ4e"><img src="https://z3.ax1x.com/2021/06/28/RUnQ4e.png" alt="RUnQ4e.png"></a><br>
<a href="https://imgtu.com/i/RUnMND"><img src="https://z3.ax1x.com/2021/06/28/RUnMND.png" alt="RUnMND.png"></a><br>
<a href="https://imgtu.com/i/RUnKAO"><img src="https://z3.ax1x.com/2021/06/28/RUnKAO.png" alt="RUnKAO.png"></a></p>
<p><a href="https://imgtu.com/i/RUn19H"><img src="https://z3.ax1x.com/2021/06/28/RUn19H.png" alt="RUn19H.png"></a></p>
]]></content>
      <categories>
        <category>路线图</category>
      </categories>
      <tags>
        <tag>路线图</tag>
      </tags>
  </entry>
  <entry>
    <title>敖丙路线图</title>
    <url>/2021/06/30/%E6%95%96%E4%B8%99%E8%84%91%E5%9B%BE/</url>
    <content><![CDATA[<p><a href="https://imgtu.com/i/RNNajO"><img src="https://z3.ax1x.com/2021/06/28/RNNajO.jpg" alt="RNNajO.jpg"></a></p>
]]></content>
      <categories>
        <category>路线图</category>
      </categories>
      <tags>
        <tag>路线图</tag>
      </tags>
  </entry>
  <entry>
    <title>狂神路线图</title>
    <url>/2021/06/30/%E7%8B%82%E7%A5%9E%E8%B7%AF%E7%BA%BF%E5%9B%BE/</url>
    <content><![CDATA[<p><a href="https://www.bilibili.com/read/cv5702420">https://www.bilibili.com/read/cv5702420</a></p>
<p><a href="https://imgtu.com/i/RU3lZR"><img src="https://z3.ax1x.com/2021/06/28/RU3lZR.png" alt="RU3lZR.png"></a></p>
<p><a href="https://imgtu.com/i/RU3ML9"><img src="https://z3.ax1x.com/2021/06/28/RU3ML9.png" alt="RU3ML9.png"></a><br>
<a href="https://imgtu.com/i/RU31d1"><img src="https://z3.ax1x.com/2021/06/28/RU31d1.png" alt="RU31d1.png"></a><br>
<a href="https://imgtu.com/i/RU3Gi6"><img src="https://z3.ax1x.com/2021/06/28/RU3Gi6.png" alt="RU3Gi6.png"></a></p>
<p><a href="https://imgtu.com/i/RU3KsJ"><img src="https://z3.ax1x.com/2021/06/28/RU3KsJ.png" alt="RU3KsJ.png"></a><br>
<a href="https://imgtu.com/i/RU3ZGT"><img src="https://z3.ax1x.com/2021/06/28/RU3ZGT.png" alt="RU3ZGT.png"></a><br>
<a href="https://imgtu.com/i/RU3uM4"><img src="https://z3.ax1x.com/2021/06/28/RU3uM4.png" alt="RU3uM4.png"></a><br>
<a href="https://imgtu.com/i/RU3mzF"><img src="https://z3.ax1x.com/2021/06/28/RU3mzF.png" alt="RU3mzF.png"></a><br>
<a href="https://imgtu.com/i/RU3eRU"><img src="https://z3.ax1x.com/2021/06/28/RU3eRU.png" alt="RU3eRU.png"></a><br>
<a href="https://imgtu.com/i/RU33Ix"><img src="https://z3.ax1x.com/2021/06/28/RU33Ix.png" alt="RU33Ix.png"></a></p>
]]></content>
      <categories>
        <category>路线图</category>
      </categories>
      <tags>
        <tag>路线图</tag>
      </tags>
  </entry>
  <entry>
    <title>我的笔记</title>
    <url>/2021/06/30/%E7%BD%AE%E9%A1%B6/</url>
    <content><![CDATA[<p>katex: true 开启数学公式<br>
 sticky: 100  置顶</p>
]]></content>
      <categories>
        <category>我的笔记</category>
        <category>生活</category>
      </categories>
      <tags>
        <tag>随手记</tag>
      </tags>
  </entry>
  <entry>
    <title>黑马路线图</title>
    <url>/2021/06/30/%E9%BB%91%E9%A9%AC%E8%B7%AF%E7%BA%BF%E5%9B%BE/</url>
    <content><![CDATA[<p><a href="https://imgtu.com/i/RUlhcQ"><img src="https://z3.ax1x.com/2021/06/28/RUlhcQ.png" alt="RUlhcQ.png"></a></p>
]]></content>
      <categories>
        <category>路线图</category>
      </categories>
      <tags>
        <tag>路线图</tag>
      </tags>
  </entry>
  <entry>
    <title>链表LinkedList</title>
    <url>/2021/06/30/04.%E9%93%BE%E8%A1%A8LinkedList/</url>
    <content><![CDATA[<h2 id="链表linkedlist"><a class="markdownIt-Anchor" href="#链表linkedlist">#</a> 链表 LinkedList</h2>
<h3 id="链表简介"><a class="markdownIt-Anchor" href="#链表简介">#</a> 链表简介</h3>
<p>链表是有序的列表，它在内存中的存储</p>
<p><a href="https://imgtu.com/i/RwA5yq"><img src="https://z3.ax1x.com/2021/06/29/RwA5yq.png" alt="RwA5yq.png"></a></p>
<p>小结：</p>
<ol>
<li>
<p>链表是以节点的方式来存储，是链式存储</p>
</li>
<li>
<p>每个节点包含 data 域， next 域：指向下一个节点.</p>
</li>
<li>
<p>如图：发现链表的<strong>各个节点不一定是连续存储</strong>.</p>
</li>
<li>
<p>链表分带头节点的链表和没有头节点的链表，根据实际的需求来确定</p>
<p>1. 单链表（带头结点）逻辑结构示意图</p>
</li>
</ol>
<p><a href="https://imgtu.com/i/RwA7wT"><img src="https://z3.ax1x.com/2021/06/29/RwA7wT.png" alt="RwA7wT.png"></a></p>
<h2 id="单链表"><a class="markdownIt-Anchor" href="#单链表">#</a> 单链表</h2>
<h3 id="单链表的应用增删改查"><a class="markdownIt-Anchor" href="#单链表的应用增删改查">#</a> 单链表的应用【增删改查】</h3>
<p><a href="https://imgtu.com/i/RwALY4"><img src="https://z3.ax1x.com/2021/06/29/RwALY4.png" alt="RwALY4.png"></a></p>
<p><a href="https://imgtu.com/i/RwAOfJ"><img src="https://z3.ax1x.com/2021/06/29/RwAOfJ.png" alt="RwAOfJ.png"></a></p>
<p><a href="https://imgtu.com/i/RwEkfH"><img src="https://z3.ax1x.com/2021/06/29/RwEkfH.png" alt="RwEkfH.png"></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.LinkedList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleLinkedListDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//进行测试</span></span><br><span class="line">        <span class="comment">//先创建几个节点</span></span><br><span class="line">        HeroNode hero1 = <span class="keyword">new</span> HeroNode(<span class="number">1</span>, <span class="string">&quot;佐菲&quot;</span>, <span class="string">&quot;炎头队长&quot;</span>);</span><br><span class="line">        HeroNode hero2 = <span class="keyword">new</span> HeroNode(<span class="number">2</span>, <span class="string">&quot;曼&quot;</span>, <span class="string">&quot;老二&quot;</span>);</span><br><span class="line">        HeroNode hero3 = <span class="keyword">new</span> HeroNode(<span class="number">3</span>, <span class="string">&quot;赛文&quot;</span>, <span class="string">&quot;seven&quot;</span>);</span><br><span class="line">        HeroNode hero4 = <span class="keyword">new</span> HeroNode(<span class="number">4</span>, <span class="string">&quot;杰克&quot;</span>, <span class="string">&quot;归曼&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建一个链表</span></span><br><span class="line">        SingleLinkedList singleLinkedList = <span class="keyword">new</span> SingleLinkedList();</span><br><span class="line">        <span class="comment">//添加</span></span><br><span class="line">        <span class="comment">//singleLinkedList.add(hero1);</span></span><br><span class="line">        <span class="comment">//singleLinkedList.add(hero2);</span></span><br><span class="line">        <span class="comment">//singleLinkedList.add(hero3);</span></span><br><span class="line">        <span class="comment">//singleLinkedList.add(hero4);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//加入按照编号的顺序</span></span><br><span class="line">        singleLinkedList.addByOrder(hero1);</span><br><span class="line">        singleLinkedList.addByOrder(hero4);</span><br><span class="line">        singleLinkedList.addByOrder(hero3);</span><br><span class="line">        singleLinkedList.addByOrder(hero2);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;修改前的链表&quot;</span>);</span><br><span class="line">        singleLinkedList.list();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//测试修改节点的代码</span></span><br><span class="line">        HeroNode newheroNode=<span class="keyword">new</span> HeroNode(<span class="number">2</span>,<span class="string">&quot;奥特曼&quot;</span>,<span class="string">&quot;初代&quot;</span>);</span><br><span class="line">        singleLinkedList.update(newheroNode);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;修改后的链表&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;删除前的链表&quot;</span>);</span><br><span class="line">        singleLinkedList.list();</span><br><span class="line"></span><br><span class="line">        singleLinkedList.del(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//显示一把</span></span><br><span class="line">        System.out.println(<span class="string">&quot;删除后的链表&quot;</span>);</span><br><span class="line">        singleLinkedList.list();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义SingleLinkedList 管理我们的英雄</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingleLinkedList</span></span>&#123;</span><br><span class="line">    <span class="comment">//先初始化一个头节点，头节点不要动，不存放具体数据</span></span><br><span class="line">    <span class="keyword">private</span> HeroNode head=<span class="keyword">new</span> HeroNode(<span class="number">0</span>,<span class="string">&quot;&quot;</span>,<span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加节点到单向链表</span></span><br><span class="line">    <span class="comment">//思路，当不考虑标号顺序时</span></span><br><span class="line">    <span class="comment">//1.找到当前链表的最后节点</span></span><br><span class="line">    <span class="comment">//2.将最后这个节点的 next域 指向新的节点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(HeroNode heroNode)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//因为head节点不能动，因此我们需要一个辅助节点(指针。变量)temp</span></span><br><span class="line">        HeroNode temp=head;</span><br><span class="line">        <span class="comment">//遍历链表，找到最后</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="comment">//找到链表的最后</span></span><br><span class="line">            <span class="keyword">if</span>(temp.next==<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果没有找到，temp后移</span></span><br><span class="line">            temp=temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//当退出while循环时，temp就指向新的节点</span></span><br><span class="line">        temp.next=heroNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//第二种方式添加英雄时，根据排名将英雄插入到指定位置</span></span><br><span class="line">    <span class="comment">//(如果有这个排名，则添加失败，并给出提示)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addByOrder</span><span class="params">(HeroNode heroNode)</span></span>&#123;</span><br><span class="line">        <span class="comment">//因为头节点不能动，因此我们仍然通过一个辅助指针(元素)来帮助找到添加的位置</span></span><br><span class="line">        <span class="comment">//因为单链表，因此我们找的temp 是位于 添加位置的前一个节点，否则插入不了</span></span><br><span class="line">        HeroNode temp=head;</span><br><span class="line">        <span class="keyword">boolean</span> flag=<span class="keyword">false</span>;<span class="comment">//标志添加的编号是否存在，默认为false</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(temp.next==<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="comment">//说明temp已经在链表的最后</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(temp.next.no&gt;heroNode.no)&#123;</span><br><span class="line">                <span class="comment">//位置找到，就在temp的后面插入</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (temp.next.no==heroNode.no)&#123;</span><br><span class="line">                <span class="comment">//说明希望添加的heroNode的编号已经存在</span></span><br><span class="line">                flag=<span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            temp=temp.next;<span class="comment">//后移，遍历当前链表</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断flag的值</span></span><br><span class="line">        <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">            <span class="comment">//不能添加，说明编号存在</span></span><br><span class="line">            System.out.printf(<span class="string">&quot;准备插入的英雄编号 %d 已经存在，不能添加\n&quot;</span>,heroNode.no);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//插入到链表中 temp的后面</span></span><br><span class="line">            heroNode.next=temp.next;</span><br><span class="line">            temp.next=heroNode;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//修改节点的信息，根据编号来修改，既no不能修改</span></span><br><span class="line">    <span class="comment">//说明</span></span><br><span class="line">    <span class="comment">//1.根据newheroNode 的 no 来修改即可</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(HeroNode newheroNode)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head.next==<span class="keyword">null</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;链表为空~~~~&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//找到需要修改的节点</span></span><br><span class="line">        <span class="comment">//先定义一个辅助变量</span></span><br><span class="line">        HeroNode temp=head.next;</span><br><span class="line">        <span class="keyword">boolean</span> flag=<span class="keyword">false</span>;<span class="comment">//表示是否找到该节点</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(temp==<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;<span class="comment">//已经遍历到链表最后，无该编号节点</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(temp.no==newheroNode.no)&#123;</span><br><span class="line">                <span class="comment">//找到了该节点</span></span><br><span class="line">                flag=<span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            temp= temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//根据flag判断是否找到了要修改的节点</span></span><br><span class="line">        <span class="keyword">if</span> (flag)&#123;</span><br><span class="line">            temp.name=newheroNode.name;</span><br><span class="line">            temp.nickname=newheroNode.nickname;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//没有找到该节点</span></span><br><span class="line">            System.out.printf(<span class="string">&quot;没有找到编号为 %d 的节点,无法修改该节点\n&quot;</span>,newheroNode.no);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除节点的代码</span></span><br><span class="line">    <span class="comment">//思路</span></span><br><span class="line">    <span class="comment">//1. head 节点不能动，因此我们需要一个temp辅助节点找到待删除节点的前一个节点</span></span><br><span class="line">    <span class="comment">//2. 说明我们在比较时，时temp.next.no 和需要节点的no 进行比较</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> no)</span></span>&#123;</span><br><span class="line">        HeroNode temp=head;</span><br><span class="line">        <span class="keyword">boolean</span> flag=<span class="keyword">false</span>;<span class="comment">//标志是否找到待删除的节点</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(temp.next==<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(temp.next.no==no)&#123;</span><br><span class="line">                <span class="comment">//找到待删除节点的前一个节点</span></span><br><span class="line">                flag=<span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            temp=temp.next;<span class="comment">//temp后移，遍历</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">            <span class="comment">//找到了 可以删除了</span></span><br><span class="line">            temp.next=temp.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.printf(<span class="string">&quot;要删除的编号为 %d 的英雄不存在\n&quot;</span>,no);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//显示链表[遍历]</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">list</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//判断链表是否为空</span></span><br><span class="line">        <span class="keyword">if</span>(head.next==<span class="keyword">null</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;链表为空&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//因为头节点，不能动，因此我们需要一个辅助变量来遍历</span></span><br><span class="line">        HeroNode temp=head.next;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="comment">//判断是否到链表最后</span></span><br><span class="line">            <span class="keyword">if</span>(temp==<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//输出节点的信息</span></span><br><span class="line">            System.out.println(temp);</span><br><span class="line">            <span class="comment">//将temp后移，一定要小心</span></span><br><span class="line">            temp=temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义HeroNode，每个HeroNode，对象就是一个节点</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HeroNode</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> no;</span><br><span class="line">    <span class="keyword">public</span> String name;<span class="comment">//英雄名字</span></span><br><span class="line">    <span class="keyword">public</span> String nickname;<span class="comment">//昵称</span></span><br><span class="line">    <span class="keyword">public</span> HeroNode next;<span class="comment">//指向下一个节点</span></span><br><span class="line">    <span class="comment">//构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HeroNode</span><span class="params">(<span class="keyword">int</span> no,String name,String nickName)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.no=no;</span><br><span class="line">        <span class="keyword">this</span>.name=name;</span><br><span class="line">        <span class="keyword">this</span>.nickname=nickName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//为了显示方便，我们重写toString</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;HeroNode&#123;no=&quot;</span> + no +<span class="string">&quot;, name=&quot;</span> + name +<span class="string">&quot;, nickname=&quot;</span> + nickname +<span class="string">&quot;&#125;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="单链表的面试题"><a class="markdownIt-Anchor" href="#单链表的面试题">#</a> 单链表的面试题</h3>
<h3 id="求单链表中有效节点的个数"><a class="markdownIt-Anchor" href="#求单链表中有效节点的个数">#</a> 求单链表中有效节点的个数</h3>
<h3 id="查找单链表中的倒数第k个节点新浪面试题"><a class="markdownIt-Anchor" href="#查找单链表中的倒数第k个节点新浪面试题">#</a> 查找单链表中的倒数第 K 个节点【新浪面试题】</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.LinkListText;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedListTestDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        HeroNode h1=<span class="keyword">new</span> HeroNode(<span class="number">1</span>,<span class="string">&quot;kono&quot;</span>,<span class="string">&quot;0ne&quot;</span>);</span><br><span class="line">        HeroNode h2=<span class="keyword">new</span> HeroNode(<span class="number">2</span>,<span class="string">&quot;alphonse&quot;</span>,<span class="string">&quot;two&quot;</span>);</span><br><span class="line">        HeroNode h3=<span class="keyword">new</span> HeroNode(<span class="number">3</span>,<span class="string">&quot;kino&quot;</span>,<span class="string">&quot;three&quot;</span>);</span><br><span class="line">        HeroNode h4=<span class="keyword">new</span> HeroNode(<span class="number">4</span>,<span class="string">&quot;mibius&quot;</span>,<span class="string">&quot;four&quot;</span>);</span><br><span class="line">        HeroNode h5=<span class="keyword">new</span> HeroNode(<span class="number">5</span>,<span class="string">&quot;Taro&quot;</span>,<span class="string">&quot;five&quot;</span>);</span><br><span class="line">        HeroNode h6=<span class="keyword">new</span> HeroNode(<span class="number">6</span>,<span class="string">&quot;Taiga&quot;</span>,<span class="string">&quot;six&quot;</span>);</span><br><span class="line">        LinkedList linkedList=<span class="keyword">new</span> LinkedList();</span><br><span class="line">        linkedList.add(h1);</span><br><span class="line">        linkedList.add(h2);</span><br><span class="line">        linkedList.add(h3);</span><br><span class="line">        linkedList.add(h4);</span><br><span class="line">        linkedList.add(h5);</span><br><span class="line">        linkedList.add(h6);</span><br><span class="line">        linkedList.List();</span><br><span class="line"></span><br><span class="line">        System.out.println(LinkedList.getLength(linkedList.getHead()));</span><br><span class="line"></span><br><span class="line">        System.out.println(LinkedList.findLastIndexNode(linkedList.getHead(),<span class="number">4</span>));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinkedList</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> HeroNode head=<span class="keyword">new</span> HeroNode(<span class="number">0</span>,<span class="string">&quot;&quot;</span>,<span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查找单链表中的倒数第k个节点 【新浪面试题】</span></span><br><span class="line">    <span class="comment">//思路</span></span><br><span class="line">    <span class="comment">//1.编写一个方法,接收head节点，同时接收一个index</span></span><br><span class="line">    <span class="comment">//2. index表示是倒数第index个节点</span></span><br><span class="line">    <span class="comment">//3.先把链表从头到尾遍历，得到链表的总的长度getLength</span></span><br><span class="line">    <span class="comment">//4.得到size后，我们从链表的第一个开始遍历(size-index)个，就可以得到</span></span><br><span class="line">    <span class="comment">//5.如果找到了，就返回该节点，否则返回null</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HeroNode <span class="title">findLastIndexNode</span><span class="params">(HeroNode head,<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head.next==<span class="keyword">null</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;链表为空&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> size =getLength(head);</span><br><span class="line">        <span class="comment">//第二次遍历 size-index 位置</span></span><br><span class="line">        <span class="comment">//先做一个index校验</span></span><br><span class="line">        <span class="keyword">if</span>(index&lt;=<span class="number">0</span>||index&gt;size)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        HeroNode cur=head.next;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;size-index;i++)&#123;</span><br><span class="line">            cur=cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HeroNode <span class="title">getHead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取单链表中节点个数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> head</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getLength</span><span class="params">(HeroNode head)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head.next==<span class="keyword">null</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;链表为空&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> length=<span class="number">0</span>;</span><br><span class="line">        HeroNode cur=head.next;</span><br><span class="line">        <span class="keyword">while</span> (cur!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            length++;</span><br><span class="line">            cur=cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(HeroNode heroNode)</span></span>&#123;</span><br><span class="line">        HeroNode temp=head;</span><br><span class="line">        <span class="keyword">boolean</span> flag=<span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(temp.next==<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(temp.next.no&gt;heroNode.no)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (temp.next.no==heroNode.no)&#123;</span><br><span class="line">                flag=<span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            temp=temp.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">            System.out.printf(<span class="string">&quot;准备插入的英雄编号 %d 已经存在，不能添加\n&quot;</span>,heroNode.no);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            heroNode.next=temp.next;</span><br><span class="line">            temp.next=heroNode;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">List</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head.next==<span class="keyword">null</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;链表为空&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        HeroNode temp=head.next;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(temp==<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(temp);</span><br><span class="line">            temp=temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HeroNode</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> no;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> String nickname;</span><br><span class="line">    <span class="keyword">public</span> HeroNode next;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HeroNode</span><span class="params">(<span class="keyword">int</span> no,String name,String nickname)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.no=no;</span><br><span class="line">        <span class="keyword">this</span>.name=name;</span><br><span class="line">        <span class="keyword">this</span>.nickname=nickname;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;HeroNode&#123;no=&quot;</span> + no +<span class="string">&quot;, name=&quot;</span> + name  +<span class="string">&quot;, nickname=&quot;</span> + nickname + <span class="string">&quot;&#125;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="单链表的反转-腾讯面试题"><a class="markdownIt-Anchor" href="#单链表的反转-腾讯面试题">#</a> 单链表的反转 【腾讯面试题】</h3>
<p>思路分析</p>
<p><a href="https://imgtu.com/i/RwEYXq"><img src="https://z3.ax1x.com/2021/06/29/RwEYXq.png" alt="RwEYXq.png"></a></p>
<p><a href="https://imgtu.com/i/RwEgnx"><img src="https://z3.ax1x.com/2021/06/29/RwEgnx.png" alt="RwEgnx.png"></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.LinkedList04;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedListTestDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        HeroNode h1=<span class="keyword">new</span> HeroNode(<span class="number">1</span>,<span class="string">&quot;kono&quot;</span>,<span class="string">&quot;0ne&quot;</span>);</span><br><span class="line">        HeroNode h2=<span class="keyword">new</span> HeroNode(<span class="number">2</span>,<span class="string">&quot;alphonse&quot;</span>,<span class="string">&quot;two&quot;</span>);</span><br><span class="line">        HeroNode h3=<span class="keyword">new</span> HeroNode(<span class="number">3</span>,<span class="string">&quot;kino&quot;</span>,<span class="string">&quot;three&quot;</span>);</span><br><span class="line">        HeroNode h4=<span class="keyword">new</span> HeroNode(<span class="number">4</span>,<span class="string">&quot;mibius&quot;</span>,<span class="string">&quot;four&quot;</span>);</span><br><span class="line">        HeroNode h5=<span class="keyword">new</span> HeroNode(<span class="number">5</span>,<span class="string">&quot;Taro&quot;</span>,<span class="string">&quot;five&quot;</span>);</span><br><span class="line">        HeroNode h6=<span class="keyword">new</span> HeroNode(<span class="number">6</span>,<span class="string">&quot;Taiga&quot;</span>,<span class="string">&quot;six&quot;</span>);</span><br><span class="line">        LinkedList linkedList=<span class="keyword">new</span> LinkedList();</span><br><span class="line">        linkedList.add(h1);</span><br><span class="line">        linkedList.add(h2);</span><br><span class="line">        linkedList.add(h3);</span><br><span class="line">        linkedList.add(h4);</span><br><span class="line">        linkedList.add(h5);</span><br><span class="line">        linkedList.add(h6);</span><br><span class="line">        System.out.println(<span class="string">&quot;原链表&quot;</span>);</span><br><span class="line">        linkedList.List();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;反转后的链表&quot;</span>);</span><br><span class="line"></span><br><span class="line">        reversetList(linkedList.getHead());</span><br><span class="line"></span><br><span class="line">        linkedList.List();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将单链表反转 【腾讯面试题】</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reversetList</span><span class="params">(HeroNode head)</span></span>&#123;</span><br><span class="line">        <span class="comment">//1.如果当前链表为null，或者只有一个节点，则无需反转，直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (head.next==<span class="keyword">null</span> || head.next.next==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//定义一个辅助的指针(变量)，帮助我们遍历原来的链表</span></span><br><span class="line">        HeroNode cur=head.next;</span><br><span class="line">        HeroNode next=<span class="keyword">null</span>;<span class="comment">//指向当前节点【cur】的下一个节点</span></span><br><span class="line">        HeroNode reverseHead=<span class="keyword">new</span> HeroNode(<span class="number">0</span>,<span class="string">&quot;&quot;</span>,<span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="comment">//遍历原来的链表</span></span><br><span class="line">        <span class="comment">//每遍历一个节点，就将其取出，并放在新的链表reverseHead 的最前端</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">            next=cur.next;<span class="comment">//先暂时保存当前节点的下一个节点，因为后面需要使用</span></span><br><span class="line">            cur.next=reverseHead.next;<span class="comment">//将cur的下一个节点指向新的链表的最前端</span></span><br><span class="line">            reverseHead.next=cur;<span class="comment">//将cur 连接到新的链表上</span></span><br><span class="line">            cur=next;<span class="comment">//让cur后移</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将head.next 指向 reverseHead.next ，实现单链表的反转</span></span><br><span class="line">        head.next=reverseHead.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinkedList</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> HeroNode head=<span class="keyword">new</span> HeroNode(<span class="number">0</span>,<span class="string">&quot;&quot;</span>,<span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HeroNode <span class="title">getHead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(HeroNode heroNode)</span></span>&#123;</span><br><span class="line">        HeroNode temp=head;</span><br><span class="line">        <span class="keyword">boolean</span> flag=<span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(temp.next==<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(temp.next.no&gt;heroNode.no)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (temp.next.no==heroNode.no)&#123;</span><br><span class="line">                flag=<span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            temp=temp.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">            System.out.printf(<span class="string">&quot;准备插入的英雄编号 %d 已经存在，不能添加\n&quot;</span>,heroNode.no);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            heroNode.next=temp.next;</span><br><span class="line">            temp.next=heroNode;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">List</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head.next==<span class="keyword">null</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;链表为空&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        HeroNode temp=head.next;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(temp==<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(temp);</span><br><span class="line">            temp=temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HeroNode</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> no;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> String nickname;</span><br><span class="line">    <span class="keyword">public</span> HeroNode next;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HeroNode</span><span class="params">(<span class="keyword">int</span> no,String name,String nickname)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.no=no;</span><br><span class="line">        <span class="keyword">this</span>.name=name;</span><br><span class="line">        <span class="keyword">this</span>.nickname=nickname;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;HeroNode&#123;no=&quot;</span> + no +<span class="string">&quot;, name=&quot;</span> + name  +<span class="string">&quot;, nickname=&quot;</span> + nickname + <span class="string">&quot;&#125;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="从尾到头打印单链表百度面试题"><a class="markdownIt-Anchor" href="#从尾到头打印单链表百度面试题">#</a> 从尾到头打印单链表【百度面试题】</h3>
<p>思路</p>
<ul>
<li>方式一：先将单链表进行反转操作，然后再遍历即可，<strong>后果</strong>：会破坏原来单链表的结构，<strong>不建议</strong></li>
<li>方式二：可以利用栈这个数据结构，将各个节点压入到栈中，然后利用栈的<strong>先进后出</strong>的特点，就能实现逆序打印的效果（代码如下）</li>
</ul>
<p><a href="https://imgtu.com/i/RwEI9H"><img src="https://z3.ax1x.com/2021/06/29/RwEI9H.png" alt="RwEI9H.png"></a></p>
<p><a href="https://imgtu.com/i/RwEo3d"><img src="https://z3.ax1x.com/2021/06/29/RwEo3d.png" alt="RwEo3d.png"></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.LinkedList05;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedListTestDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        HeroNode h1=<span class="keyword">new</span> HeroNode(<span class="number">1</span>,<span class="string">&quot;kono&quot;</span>,<span class="string">&quot;0ne&quot;</span>);</span><br><span class="line">        HeroNode h2=<span class="keyword">new</span> HeroNode(<span class="number">2</span>,<span class="string">&quot;alphonse&quot;</span>,<span class="string">&quot;two&quot;</span>);</span><br><span class="line">        HeroNode h3=<span class="keyword">new</span> HeroNode(<span class="number">3</span>,<span class="string">&quot;kino&quot;</span>,<span class="string">&quot;three&quot;</span>);</span><br><span class="line">        HeroNode h4=<span class="keyword">new</span> HeroNode(<span class="number">4</span>,<span class="string">&quot;mibius&quot;</span>,<span class="string">&quot;four&quot;</span>);</span><br><span class="line">        HeroNode h5=<span class="keyword">new</span> HeroNode(<span class="number">5</span>,<span class="string">&quot;Taro&quot;</span>,<span class="string">&quot;five&quot;</span>);</span><br><span class="line">        HeroNode h6=<span class="keyword">new</span> HeroNode(<span class="number">6</span>,<span class="string">&quot;Taiga&quot;</span>,<span class="string">&quot;six&quot;</span>);</span><br><span class="line">        LinkedList linkedList=<span class="keyword">new</span> LinkedList();</span><br><span class="line">        linkedList.add(h1);</span><br><span class="line">        linkedList.add(h2);</span><br><span class="line">        linkedList.add(h3);</span><br><span class="line">        linkedList.add(h4);</span><br><span class="line">        linkedList.add(h5);</span><br><span class="line">        linkedList.add(h6);</span><br><span class="line">        System.out.println(<span class="string">&quot;原链表&quot;</span>);</span><br><span class="line">        linkedList.List();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;逆序打印，没有改变链表的结构&quot;</span>);</span><br><span class="line">        reversePrint(linkedList.getHead());</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;测试链表结构是否被破坏&quot;</span>);</span><br><span class="line">        linkedList.List();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//方式二：可以利用栈这个数据结构，将各个节点压入到栈中，然后利用栈的先进后出的特点，就能实现逆序打印的效果</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reversePrint</span><span class="params">(HeroNode head)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head.next==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;<span class="comment">//空链表，不能打印</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//创建要给一个栈，将各个节点压入栈</span></span><br><span class="line">        Stack&lt;HeroNode&gt; stack=<span class="keyword">new</span> Stack&lt;HeroNode&gt;();</span><br><span class="line">        HeroNode cur=head.next;</span><br><span class="line">        <span class="keyword">while</span> (cur!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            stack.push(cur);</span><br><span class="line">            cur=cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将链表的所有节点压入栈</span></span><br><span class="line">        <span class="keyword">while</span> (stack.size()&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//stack的特点是先进后出</span></span><br><span class="line">            System.out.println(stack.pop());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinkedList</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> HeroNode head=<span class="keyword">new</span> HeroNode(<span class="number">0</span>,<span class="string">&quot;&quot;</span>,<span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HeroNode <span class="title">getHead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(HeroNode heroNode)</span></span>&#123;</span><br><span class="line">        HeroNode temp=head;</span><br><span class="line">        <span class="keyword">boolean</span> flag=<span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(temp.next==<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(temp.next.no&gt;heroNode.no)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (temp.next.no==heroNode.no)&#123;</span><br><span class="line">                flag=<span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            temp=temp.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">            System.out.printf(<span class="string">&quot;准备插入的英雄编号 %d 已经存在，不能添加\n&quot;</span>,heroNode.no);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            heroNode.next=temp.next;</span><br><span class="line">            temp.next=heroNode;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">List</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head.next==<span class="keyword">null</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;链表为空&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        HeroNode temp=head.next;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(temp==<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(temp);</span><br><span class="line">            temp=temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HeroNode</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> no;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> String nickname;</span><br><span class="line">    <span class="keyword">public</span> HeroNode next;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HeroNode</span><span class="params">(<span class="keyword">int</span> no,String name,String nickname)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.no=no;</span><br><span class="line">        <span class="keyword">this</span>.name=name;</span><br><span class="line">        <span class="keyword">this</span>.nickname=nickname;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;HeroNode&#123;no=&quot;</span> + no +<span class="string">&quot;, name=&quot;</span> + name  +<span class="string">&quot;, nickname=&quot;</span> + nickname + <span class="string">&quot;&#125;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="双向链表"><a class="markdownIt-Anchor" href="#双向链表">#</a> 双向链表</h2>
<h3 id="思路分析"><a class="markdownIt-Anchor" href="#思路分析">#</a> 思路分析</h3>
<p><a href="https://imgtu.com/i/RweEp4"><img src="https://z3.ax1x.com/2021/06/29/RweEp4.png" alt="RweEp4.png"></a></p>
<p><a href="https://imgtu.com/i/RweikT"><img src="https://z3.ax1x.com/2021/06/29/RweikT.png" alt="RweikT.png"></a></p>
<p><a href="https://imgtu.com/i/Rweu0x"><img src="https://z3.ax1x.com/2021/06/29/Rweu0x.png" alt="Rweu0x.png"></a></p>
<p><a href="https://imgtu.com/i/Rwe89e"><img src="https://z3.ax1x.com/2021/06/29/Rwe89e.png" alt="Rwe89e.png"></a></p>
<p><a href="https://imgtu.com/i/RweG1H"><img src="https://z3.ax1x.com/2021/06/29/RweG1H.jpg" alt="RweG1H.jpg"></a></p>
<p>对上图的说明:</p>
<p>分析 双向链表的遍历，添加，修改，删除的操作思路 ===》代码实现</p>
<ul>
<li>
<p>遍历  和 单链表一样，只是可以向前，也可以向后查找</p>
</li>
<li>
<p>添加  (默认添加到双向链表的最后)</p>
</li>
</ul>
<p>(1)  先找到双向链表的最后这个节点</p>
<p>(2) temp.next = newHeroNode</p>
<p>(3) newHeroNode.pre = temp;</p>
<ul>
<li>
<p>修改  思路和 原来的单向链表一样.</p>
</li>
<li>
<p>删除</p>
</li>
</ul>
<p>(1)  因为是双向链表，因此，我们可以实现自我删除某个节点</p>
<p>(2)  直接找到要删除的这个节点，比如 temp</p>
<p>(3)  temp.pre.next = temp.next</p>
<p>(4) temp.next.pre = temp.pre;</p>
<h3 id="双向链表的代码实现"><a class="markdownIt-Anchor" href="#双向链表的代码实现">#</a> 双向链表的代码实现</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.DoubleLinkedList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DoubleLinkedListDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        HeroNode h1=<span class="keyword">new</span> HeroNode(<span class="number">1</span>,<span class="string">&quot;kino&quot;</span>,<span class="string">&quot;one&quot;</span>);</span><br><span class="line">        HeroNode h3=<span class="keyword">new</span> HeroNode(<span class="number">3</span>,<span class="string">&quot;kino&quot;</span>,<span class="string">&quot;three&quot;</span>);</span><br><span class="line">        HeroNode h4=<span class="keyword">new</span> HeroNode(<span class="number">4</span>,<span class="string">&quot;kino&quot;</span>,<span class="string">&quot;four&quot;</span>);</span><br><span class="line">        HeroNode h5=<span class="keyword">new</span> HeroNode(<span class="number">5</span>,<span class="string">&quot;kino&quot;</span>,<span class="string">&quot;five&quot;</span>);</span><br><span class="line">        HeroNode h7=<span class="keyword">new</span> HeroNode(<span class="number">7</span>,<span class="string">&quot;kino&quot;</span>,<span class="string">&quot;seven&quot;</span>);</span><br><span class="line"></span><br><span class="line">        DoubleLinkedList doubleLinkedList=<span class="keyword">new</span> DoubleLinkedList();</span><br><span class="line">        doubleLinkedList.add(h1);</span><br><span class="line">        doubleLinkedList.add(h4);</span><br><span class="line">        doubleLinkedList.add(h3);</span><br><span class="line">        doubleLinkedList.add(h5);</span><br><span class="line">        doubleLinkedList.add(h7);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;双向链表测试&quot;</span>);</span><br><span class="line"></span><br><span class="line">        doubleLinkedList.list();</span><br><span class="line">        System.out.println(<span class="string">&quot;=======================&quot;</span>);</span><br><span class="line"></span><br><span class="line">        HeroNode newHerNode=<span class="keyword">new</span> HeroNode(<span class="number">5</span>,<span class="string">&quot;kino00&quot;</span>,<span class="string">&quot;new&quot;</span>);</span><br><span class="line"></span><br><span class="line">        doubleLinkedList.update(newHerNode);</span><br><span class="line">        <span class="comment">//doubleLinkedList.list();</span></span><br><span class="line">        doubleLinkedList.del(<span class="number">7</span>);</span><br><span class="line">        doubleLinkedList.list();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DoubleLinkedList</span></span>&#123;</span><br><span class="line">    <span class="comment">//先初始化一个头节点，头节点不要动，不存放具体数据</span></span><br><span class="line">    <span class="keyword">private</span> HeroNode head=<span class="keyword">new</span> HeroNode(<span class="number">0</span>,<span class="string">&quot;&quot;</span>,<span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回头节点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HeroNode <span class="title">getHead</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历双链表</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">list</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//判断链表是否为null</span></span><br><span class="line">        <span class="keyword">if</span> (head.next==<span class="keyword">null</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;链表为null&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//因为头节点，不能动，因此我们需要一个辅助变量来遍历</span></span><br><span class="line">        HeroNode temp=head.next;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (temp==<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//输出节点信息</span></span><br><span class="line">            System.out.println(temp);</span><br><span class="line">            <span class="comment">//将temp后移，一定要小心</span></span><br><span class="line">            temp=temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加一个节点到双向链表的最后</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(HeroNode heroNode)</span></span>&#123;</span><br><span class="line">        <span class="comment">//因为头节点，不能动，因此我们需要一个辅助变量来遍历</span></span><br><span class="line">        HeroNode temp=head;</span><br><span class="line">        <span class="comment">//遍历链表，找到最后</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="comment">//找到链表最后</span></span><br><span class="line">            <span class="keyword">if</span>(temp.next==<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果没有找到最后，temp后移</span></span><br><span class="line">            temp=temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//当退出while循环时，temp就指向链表的最后</span></span><br><span class="line">        <span class="comment">//形成双向链表</span></span><br><span class="line">        temp.next=heroNode;</span><br><span class="line">        heroNode.pre=temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//修改一个节点的内容</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(HeroNode newHeroNode)</span></span>&#123;</span><br><span class="line">        <span class="comment">//因为头节点，不能动，因此我们需要一个辅助变量来遍历</span></span><br><span class="line">        HeroNode temp=head.next;</span><br><span class="line">        <span class="keyword">boolean</span> flag=<span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(temp==<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;<span class="comment">//已经遍历完链表</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(temp.no==newHeroNode.no)&#123;</span><br><span class="line">                flag=<span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            temp=temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">            temp.name=newHeroNode.name;</span><br><span class="line">            temp.nickname=newHeroNode.nickname;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.printf(<span class="string">&quot;没找到编号为%d的节点，不能修改\n&quot;</span>,newHeroNode);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从双向链表中删除一个节点</span></span><br><span class="line">    <span class="comment">//1.对于双向链表，可以直接找到删除节点</span></span><br><span class="line">    <span class="comment">//2.找到后直接删除即可</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> no)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断当前链表是否为空</span></span><br><span class="line">        <span class="keyword">if</span>(head.next==<span class="keyword">null</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;链表为null，无法删除&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//因为头节点，不能动，因此我们需要一个辅助变量来遍历</span></span><br><span class="line">        HeroNode temp=head.next;</span><br><span class="line">        <span class="keyword">boolean</span> flag=<span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(temp==<span class="keyword">null</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;链表为null&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(temp==<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;<span class="comment">//已经找到链表最后一个节点的下一个节点</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(temp.no==no)&#123;</span><br><span class="line">                flag=<span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            temp=temp.next;<span class="comment">//temo后移</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">            temp.pre.next=temp.next;</span><br><span class="line">            <span class="comment">//如果是最后一个节点，就不需要执行下面这句话，否则出现空指针异常</span></span><br><span class="line">            <span class="keyword">if</span>(temp.next!=<span class="keyword">null</span>) &#123;</span><br><span class="line">                temp.next.pre = temp.pre;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//双链表按照编号循序添加</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HeroNode</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> no;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> String nickname;</span><br><span class="line">    <span class="keyword">public</span> HeroNode next;<span class="comment">//指向下一个节点，默认为null</span></span><br><span class="line">    <span class="keyword">public</span> HeroNode pre;<span class="comment">//指向前一个节点，默认为null</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HeroNode</span><span class="params">(<span class="keyword">int</span> no, String name, String nickname)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.no = no;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.nickname = nickname;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//为了显示方便，我们重写toString</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;HeroNode&#123;no=&quot;</span> + no +<span class="string">&quot;, name=&quot;</span> + name +<span class="string">&quot;, nickname=&quot;</span> + nickname +<span class="string">&quot;&#125;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="单向环形链表"><a class="markdownIt-Anchor" href="#单向环形链表">#</a> 单向环形链表</h3>
<h4 id="单向环形链表介绍"><a class="markdownIt-Anchor" href="#单向环形链表介绍">#</a> 单向环形链表介绍</h4>
<p><a href="https://imgtu.com/i/RweJcd"><img src="https://z3.ax1x.com/2021/06/29/RweJcd.png" alt="RweJcd.png"></a></p>
<h4 id="josephu约瑟夫问题"><a class="markdownIt-Anchor" href="#josephu约瑟夫问题">#</a> Josephu (约瑟夫) 问题</h4>
<p>Ø<strong>Josephu</strong> <strong>问题</strong></p>
<p>Josephu 问题为：设编号为 1，2，… n 的 n 个人围坐一圈，约定编号为 k（1&lt;=k&lt;=n）的人从 1 开始报数，数到 m 的那个人出列，它的下一位又从 1 开始报数，数到 m 的那个人又出列，依次类推，直到所有人出列为止，由此产生一个出队编号的序列。</p>
<p>Ø<strong> 提示</strong></p>
<p>用一个不带头结点的循环链表来处理 Josephu 问题：先构成一个有 n 个结点的单循环链表，然后由 k 结点起从 1 开始计数，计到 m 时，对应结点从链表中删除，然后再从被删除结点的下一个结点又从 1 开始计数，直到最后一个结点从链表中删除算法结束。</p>
<p><a href="https://imgtu.com/i/RweUBt"><img src="https://z3.ax1x.com/2021/06/29/RweUBt.png" alt="RweUBt.png"></a></p>
<p><a href="https://imgtu.com/i/RwewAf"><img src="https://z3.ax1x.com/2021/06/29/RwewAf.png" alt="RwewAf.png"></a></p>
<p><a href="https://imgtu.com/i/Rwer9g"><img src="https://z3.ax1x.com/2021/06/29/Rwer9g.png" alt="Rwer9g.png"></a></p>
<h4 id="代码展示"><a class="markdownIt-Anchor" href="#代码展示">#</a> 代码展示</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.Josepfu;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Josepfu</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//测试一把，看是否构建环形链表 ，和是否能遍历</span></span><br><span class="line">        CircleSingleLinkedList circleSingleLinkedList = <span class="keyword">new</span> CircleSingleLinkedList();</span><br><span class="line">        circleSingleLinkedList.addBoy(<span class="number">5</span>);<span class="comment">//加入5个小孩节点</span></span><br><span class="line">        circleSingleLinkedList.showBoy();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//测试小孩出圈</span></span><br><span class="line">        circleSingleLinkedList.countBoy(<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个环形的单向链表</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CircleSingleLinkedList</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建一个first节点，当前没有编号</span></span><br><span class="line">    <span class="keyword">private</span> Boy first = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加小孩节点，构建一个环形的链表</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addBoy</span><span class="params">(<span class="keyword">int</span> nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//nums 做一个数据校验</span></span><br><span class="line">        <span class="keyword">if</span> (nums &lt; <span class="number">1</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;nums的值不正确&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//辅助节点，帮助构建环形链表</span></span><br><span class="line">        Boy curBoy = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//使用for来创建环形链表</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= nums; i++) &#123;</span><br><span class="line">            <span class="comment">//根据标号，创建小孩节点</span></span><br><span class="line">            Boy boy = <span class="keyword">new</span> Boy(i);</span><br><span class="line">            <span class="comment">//如果是第一个小孩</span></span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">1</span>) &#123;</span><br><span class="line">                first = boy;</span><br><span class="line">                first.setNext(first);<span class="comment">//构成环</span></span><br><span class="line">                curBoy = first;<span class="comment">//让curBoy指向第一个小孩</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                curBoy.setNext(boy);</span><br><span class="line">                boy.setNext(first);</span><br><span class="line">                curBoy = boy;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历当前的环形链表</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showBoy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//判断链表是否为null</span></span><br><span class="line">        <span class="keyword">if</span> (first == <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;链表为null&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//因为first不能动，使用一个辅助指针完成遍历</span></span><br><span class="line">        Boy curBoy = first;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            System.out.printf(<span class="string">&quot;小孩的编号%d \n&quot;</span>, curBoy.getNo());</span><br><span class="line">            <span class="keyword">if</span> (curBoy.getNext() == first) &#123;</span><br><span class="line">                <span class="comment">//说明已经遍历完毕</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            curBoy = curBoy.getNext();<span class="comment">//curBoy后移</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据用户的输入，计算出小孩出圈的顺序</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> startNo  表示第几个小孩开始数数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> countNum 表示数几下</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nums     表示最初有几个消灾在圈中</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">countBoy</span><span class="params">(<span class="keyword">int</span> startNo, <span class="keyword">int</span> countNum, <span class="keyword">int</span> nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//先对数据进行校验</span></span><br><span class="line">        <span class="keyword">if</span> (first == <span class="keyword">null</span> || startNo &lt; <span class="number">1</span> || startNo &gt; nums) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;参数输入有误，请重新输入&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//创建要给辅助指针，帮助完成小孩出圈</span></span><br><span class="line">        Boy helper = first;</span><br><span class="line">        <span class="comment">//要求创建一个辅助指针（helper），事先应该指向环形链表的最后这个节点</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (helper.getNext() == first) &#123;</span><br><span class="line">                <span class="comment">//说明helper指向最后小孩节点</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            helper = helper.getNext();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//小孩报数前，先让first 和 helper 移动 k-1 次（移动到k的身上）</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; startNo - <span class="number">1</span>; j++) &#123;</span><br><span class="line">            first = first.getNext();</span><br><span class="line">            helper = helper.getNext();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//当小孩报数时，让first 和 helper 指针同时的移动m-1次，然后出圈</span></span><br><span class="line">        <span class="comment">//这里是一个循环操作，直到圈中只有一个节点</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (helper == first) &#123;</span><br><span class="line">                <span class="comment">//说明圈中只有一个节点</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//让first 和helper 指针同时的移动countNum-1</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; countNum - <span class="number">1</span>; j++) &#123;</span><br><span class="line">                first = first.getNext();</span><br><span class="line">                helper = helper.getNext();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//此时first指向的节点，就是要出圈的小孩节点</span></span><br><span class="line">            System.out.printf(<span class="string">&quot;小孩%d出圈\n&quot;</span>, first.getNo());</span><br><span class="line">            <span class="comment">//这时将first指向的小孩节点出圈</span></span><br><span class="line">            first = first.getNext();</span><br><span class="line">            helper.setNext(first);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.printf(<span class="string">&quot;最后留在圈中的小孩编号%d\n&quot;</span>, first.getNo());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个Boy类，表示一个节点</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Boy</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> no;<span class="comment">//编号</span></span><br><span class="line">    <span class="keyword">private</span> Boy next;<span class="comment">//指向下一个节点，默认null</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Boy</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.no = no;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> no;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNo</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.no = no;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Boy <span class="title">getNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNext</span><span class="params">(Boy next)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>04.链表LinkedList</category>
      </categories>
      <tags>
        <tag>算法与数据结构</tag>
        <tag>单链表</tag>
        <tag>双链表</tag>
      </tags>
  </entry>
  <entry>
    <title>树结构基础部分</title>
    <url>/2021/07/08/10.%E6%A0%91%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86/</url>
    <content><![CDATA[<h1 id="树"><a class="markdownIt-Anchor" href="#树">#</a> 树</h1>
<h2 id="三种存储方式的比较"><a class="markdownIt-Anchor" href="#三种存储方式的比较">#</a> 三种存储方式的比较</h2>
<ul>
<li>数组存储方式分析
<ul>
<li>优点：通过下标方式访问元素，速度快。<strong>对于有序数组</strong>，还可使用二分查找提高检索速度。</li>
<li>缺点：如果要检索具体某个值，或者插入值 (按一定顺序)<strong> 会整体移动</strong>，效率较低</li>
</ul>
</li>
<li>链表存储方式分析
<ul>
<li>优点：在一定程度上对数组存储方式有优化 (比如：插入一个数值节点，只需要将插入节点，链接到链表中即可， 删除效率也很好)</li>
<li>缺点：在进行检索时，效率仍然较低，比如 (检索某个值，需要从头节点开始遍历)</li>
</ul>
</li>
<li>树的存储方式分析
<ul>
<li>能提高数据<strong>存储，读取</strong>的效率，比如利用 <strong>二叉排序树</strong> (Binary Sort Tree)，既可以保证数据的检索速度，同时也可以保证数据的插入，删除，修改的速度。</li>
</ul>
</li>
</ul>
<p><a href="https://imgtu.com/i/R7mZ6K"><img src="https://z3.ax1x.com/2021/07/06/R7mZ6K.png" alt="R7mZ6K.png"></a></p>
<h2 id="树的示意图"><a class="markdownIt-Anchor" href="#树的示意图">#</a> 树的示意图</h2>
<p><a href="https://imgtu.com/i/R7mu0e"><img src="https://z3.ax1x.com/2021/07/06/R7mu0e.png" alt="R7mu0e.png"></a></p>
<h2 id="树的常用术语"><a class="markdownIt-Anchor" href="#树的常用术语">#</a> 树的常用术语</h2>
<ol>
<li>节点</li>
<li>根节点（root 节点）</li>
<li>父节点</li>
<li>子节点</li>
<li>叶子节点（没有子节点的节点）</li>
<li>节点的权（节点值）</li>
<li>路径（从 root 节点找到该节点的路线）</li>
<li>层</li>
<li>子树</li>
<li>树的高度（最大层数）</li>
<li>森林：多棵子树构成森林</li>
</ol>
<h1 id="二叉树"><a class="markdownIt-Anchor" href="#二叉树">#</a> 二叉树</h1>
<h2 id="二叉树的概念"><a class="markdownIt-Anchor" href="#二叉树的概念">#</a> 二叉树的概念</h2>
<ol>
<li>树的种类有很多，每个节点<strong>最多只能有两个子节点</strong>的<strong>一种</strong>形式称为<strong>二叉树</strong></li>
<li>二叉树的子节点分为左节点和右节点</li>
<li>如果该二叉树的所有叶子节点都在最后一层，并且结点总数 = 2^n -1 , n 为层数，则我们称为满二叉树。</li>
<li><a href="https://imgtu.com/i/R7mQkd"><img src="https://z3.ax1x.com/2021/07/06/R7mQkd.png" alt="R7mQkd.png"></a></li>
<li>如果该二叉树的所有叶子节点都在最后一层或者倒数第二层，而且最后一层的叶子节点在左边连续，倒数第二层的叶子节点在右边连续，我们成为完全二叉树</li>
<li><a href="https://imgtu.com/i/R7m1fI"><img src="https://z3.ax1x.com/2021/07/06/R7m1fI.png" alt="R7m1fI.png"></a></li>
</ol>
<h2 id="二叉树的遍历"><a class="markdownIt-Anchor" href="#二叉树的遍历">#</a> 二叉树的遍历</h2>
<ul>
<li>
<p>前序遍历：先输出父节点，再遍历左子树和右子树</p>
</li>
<li>
<p>中序遍历：先遍历左子树，再输出父节点，再遍历右子树</p>
</li>
<li>
<p>后序遍历：先遍历左子树，再遍历右子树，最后输出父节点</p>
</li>
<li>
<p>小结：看输出父节点的顺序，就确定是前序，中序还是后序</p>
</li>
</ul>
<p><a href="https://imgtu.com/i/R7mJ6f"><img src="https://z3.ax1x.com/2021/07/06/R7mJ6f.png" alt="R7mJ6f.png"></a></p>
<h3 id="代码展示"><a class="markdownIt-Anchor" href="#代码展示">#</a> 代码展示</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> demo01;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinaryTreeDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//先创建一棵二叉树</span></span><br><span class="line">        BinaryTree binaryTree=<span class="keyword">new</span> BinaryTree();</span><br><span class="line">        <span class="comment">//创建需要的节点</span></span><br><span class="line">        HeroNode root=<span class="keyword">new</span> HeroNode(<span class="number">1</span>,<span class="string">&quot;zoffy&quot;</span>);</span><br><span class="line">        HeroNode node2=<span class="keyword">new</span> HeroNode(<span class="number">2</span>,<span class="string">&quot;man&quot;</span>);</span><br><span class="line">        HeroNode node3=<span class="keyword">new</span> HeroNode(<span class="number">3</span>,<span class="string">&quot;taro&quot;</span>);</span><br><span class="line">        HeroNode node4=<span class="keyword">new</span> HeroNode(<span class="number">4</span>,<span class="string">&quot;taiga&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//先手动创建该二叉树，后面学习递归方式创建二叉树</span></span><br><span class="line">        root.setLeft(node2);</span><br><span class="line">        root.setRight(node3);</span><br><span class="line">        node3.setRight(node4);</span><br><span class="line">        binaryTree.setRoot(root);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//测试</span></span><br><span class="line">        System.out.println(<span class="string">&quot;前序遍历&quot;</span>);</span><br><span class="line">        binaryTree.preOrder();</span><br><span class="line">        System.out.println(<span class="string">&quot;中序遍历&quot;</span>);</span><br><span class="line">        binaryTree.infixOrder();</span><br><span class="line">        System.out.println(<span class="string">&quot;后序遍历&quot;</span>);</span><br><span class="line">        binaryTree.postOrder();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义BinaryTree 二叉树</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinaryTree</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> HeroNode root;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRoot</span><span class="params">(HeroNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.root=root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//前序遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.root!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">this</span>.root.preOrder();</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;二叉树为null，无法遍历&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//中序遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">infixOrder</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.root!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">this</span>.root.infixOrder();</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;二叉树为null，无法遍历&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//后序遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postOrder</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.root!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">this</span>.root.postOrder();</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;二叉树为null，无法遍历&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建HeroNode 节点</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HeroNode</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> no;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> HeroNode left;  <span class="comment">//默认为null</span></span><br><span class="line">    <span class="keyword">private</span> HeroNode right; <span class="comment">//默认为null</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HeroNode</span><span class="params">(<span class="keyword">int</span> no, String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.no = no;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> no;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNo</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.no = no;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HeroNode <span class="title">getLeft</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLeft</span><span class="params">(HeroNode left)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.left = left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HeroNode <span class="title">getRight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRight</span><span class="params">(HeroNode right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;HeroNode &#123; no=&quot;</span> + no + <span class="string">&quot;, name=&quot;</span> + name + <span class="string">&quot;&#125;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//编写前序遍历的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">this</span>);<span class="comment">//先输出根节点</span></span><br><span class="line">        <span class="comment">//递归向左子树前序遍历</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">this</span>.left.preOrder();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//递归向右子树前序遍历</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">this</span>.right.preOrder();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//中序遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">infixOrder</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//先递归向左子树中序遍历</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">this</span>.left.infixOrder();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//然后输出根节点</span></span><br><span class="line">        System.out.println(<span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">//递归向右子树中序遍历</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">this</span>.right.infixOrder();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//后序遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postOrder</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//先递归向左子树中序遍历</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">this</span>.left.postOrder();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//然后递归向右子树中序遍历</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">this</span>.right.postOrder();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//最后输出根节点</span></span><br><span class="line">        System.out.println(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="二叉树的查找"><a class="markdownIt-Anchor" href="#二叉树的查找">#</a> 二叉树的查找</h2>
<p><a href="https://imgtu.com/i/R7m0ts"><img src="https://z3.ax1x.com/2021/07/06/R7m0ts.png" alt="R7m0ts.png"></a></p>
<h3 id="代码展示-2"><a class="markdownIt-Anchor" href="#代码展示-2">#</a> 代码展示</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> demo02;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinaryTreeDemoSearch</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//先创建一棵二叉树</span></span><br><span class="line">        BinaryTree binaryTree=<span class="keyword">new</span> BinaryTree();</span><br><span class="line">        <span class="comment">//创建需要的节点</span></span><br><span class="line">        HeroNode root=<span class="keyword">new</span> HeroNode(<span class="number">1</span>,<span class="string">&quot;zoffy&quot;</span>);</span><br><span class="line">        HeroNode node2=<span class="keyword">new</span> HeroNode(<span class="number">2</span>,<span class="string">&quot;man&quot;</span>);</span><br><span class="line">        HeroNode node3=<span class="keyword">new</span> HeroNode(<span class="number">3</span>,<span class="string">&quot;taro&quot;</span>);</span><br><span class="line">        HeroNode node4=<span class="keyword">new</span> HeroNode(<span class="number">4</span>,<span class="string">&quot;taiga&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//先手动创建该二叉树，后面学习递归方式创建二叉树</span></span><br><span class="line">        root.setLeft(node2);</span><br><span class="line">        root.setRight(node3);</span><br><span class="line">        node3.setRight(node4);</span><br><span class="line">        binaryTree.setRoot(root);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//查找</span></span><br><span class="line">        System.out.println(<span class="string">&quot;前序查找&quot;</span>);</span><br><span class="line">        HeroNode node = binaryTree.preOrderSearch(<span class="number">3</span>);</span><br><span class="line">        <span class="keyword">if</span> (node!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            System.out.printf(<span class="string">&quot;找到了，信息为no=%d,name=%s&quot;</span>,node.getNo(), node.getName());</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;没找到&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义BinaryTree 二叉树</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinaryTree</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> HeroNode root;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRoot</span><span class="params">(HeroNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.root=root;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//前序查找</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HeroNode <span class="title">preOrderSearch</span><span class="params">(<span class="keyword">int</span> no)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> root.preOrderSearch(no);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//中序查找</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HeroNode <span class="title">infixOrderSearch</span><span class="params">(<span class="keyword">int</span> no)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> root.infixOrderSearch(no);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//后序查找</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HeroNode <span class="title">postOrderSearch</span><span class="params">(<span class="keyword">int</span> no)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> root.postOrderSearch(no);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建HeroNode 节点</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HeroNode</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> no;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> HeroNode left;  <span class="comment">//默认为null</span></span><br><span class="line">    <span class="keyword">private</span> HeroNode right; <span class="comment">//默认为null</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HeroNode</span><span class="params">(<span class="keyword">int</span> no, String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.no = no;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> no;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNo</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.no = no;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HeroNode <span class="title">getLeft</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLeft</span><span class="params">(HeroNode left)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.left = left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HeroNode <span class="title">getRight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRight</span><span class="params">(HeroNode right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;HeroNode &#123; no=&quot;</span> + no + <span class="string">&quot;, name=&quot;</span> + name + <span class="string">&quot;&#125;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//前序遍历查找</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> no    查找no</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>      如果找到就返回该Node，如果没有找到就返回 null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HeroNode <span class="title">preOrderSearch</span><span class="params">(<span class="keyword">int</span> no)</span></span>&#123;</span><br><span class="line">        <span class="comment">//比较当前节点是不是要查找的节点</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.no==no)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//1.判断当前节点的左子节点是否为 null，如果不为 null，则递归前序查找</span></span><br><span class="line">        <span class="comment">//2.如果左递归前序查找，找到节点，则返回</span></span><br><span class="line">        HeroNode resNode = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            resNode=<span class="keyword">this</span>.left.preOrderSearch(no);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (resNode!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">//说明找到了</span></span><br><span class="line">            <span class="keyword">return</span> resNode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//1.左递归前序查找，找到节点，则返回，否则继续判断</span></span><br><span class="line">        <span class="comment">//2.当前的节点的右子节点是否为null，如果不为 null，则继续向右递归前序查找</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            resNode=<span class="keyword">this</span>.right.preOrderSearch(no);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> resNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//中序遍历查找</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HeroNode <span class="title">infixOrderSearch</span><span class="params">(<span class="keyword">int</span> no)</span></span>&#123;</span><br><span class="line">        HeroNode resNode = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//判断当前节点的左子节点是否为null，如果不为null，则递归中序查找</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            resNode=<span class="keyword">this</span>.left.infixOrderSearch(no);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (resNode!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">//说明找到了</span></span><br><span class="line">            <span class="keyword">return</span> resNode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果找到，就返回，如果没找到就和当前节点比较，如果是则返回当前节点</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.no==no)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//否则继续进行右递归的中序查找</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            resNode=<span class="keyword">this</span>.right.infixOrderSearch(no);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> resNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//后序遍历查找</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HeroNode <span class="title">postOrderSearch</span><span class="params">(<span class="keyword">int</span> no)</span></span>&#123;</span><br><span class="line">        HeroNode resNode = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//判断当前节点的左子节点是否为null，如果不为null，则递归后序查找</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            resNode=<span class="keyword">this</span>.left.postOrderSearch(no);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (resNode!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">//说明在左子树找到</span></span><br><span class="line">            <span class="keyword">return</span> resNode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果左子树没有找到，就向右递归进行后序遍历查找</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            resNode=<span class="keyword">this</span>.right.postOrderSearch(no);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果左右子树都没有找到，就比较当前节点是不是</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.no==no)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> resNode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="二叉树的删除"><a class="markdownIt-Anchor" href="#二叉树的删除">#</a> 二叉树的删除</h2>
<p><a href="https://imgtu.com/i/R7ms10"><img src="https://z3.ax1x.com/2021/07/06/R7ms10.png" alt="R7ms10.png"></a></p>
<h3 id="代码展示-3"><a class="markdownIt-Anchor" href="#代码展示-3">#</a> 代码展示</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> demo03;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinaryTreeDemoDelete</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//先创建一棵二叉树</span></span><br><span class="line">        BinaryTree binaryTree = <span class="keyword">new</span> BinaryTree();</span><br><span class="line">        <span class="comment">//创建需要的节点</span></span><br><span class="line">        HeroNode root = <span class="keyword">new</span> HeroNode(<span class="number">1</span>, <span class="string">&quot;zoffy&quot;</span>);</span><br><span class="line">        HeroNode node2 = <span class="keyword">new</span> HeroNode(<span class="number">2</span>, <span class="string">&quot;man&quot;</span>);</span><br><span class="line">        HeroNode node3 = <span class="keyword">new</span> HeroNode(<span class="number">3</span>, <span class="string">&quot;taro&quot;</span>);</span><br><span class="line">        HeroNode node4 = <span class="keyword">new</span> HeroNode(<span class="number">4</span>, <span class="string">&quot;taiga&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//先手动创建该二叉树，后面学习递归方式创建二叉树</span></span><br><span class="line">        root.setLeft(node2);</span><br><span class="line">        root.setRight(node3);</span><br><span class="line">        node3.setRight(node4);</span><br><span class="line">        binaryTree.setRoot(root);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//测试删除</span></span><br><span class="line">        binaryTree.delNode(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义BinaryTree 二叉树</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinaryTree</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> HeroNode root;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRoot</span><span class="params">(HeroNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.root = root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delNode</span><span class="params">(<span class="keyword">int</span> no)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">//如果只有一个root节点，这里立即判断root是不是就是要删除的节点</span></span><br><span class="line">            <span class="keyword">if</span> (root.getNo()==no)&#123;</span><br><span class="line">                root=<span class="keyword">null</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                root.delNode(no);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;这个树是空树，不能删除~~~&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建HeroNode 节点</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HeroNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> no;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> HeroNode left;  <span class="comment">//默认为null</span></span><br><span class="line">    <span class="keyword">private</span> HeroNode right; <span class="comment">//默认为null</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HeroNode</span><span class="params">(<span class="keyword">int</span> no, String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.no = no;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> no;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNo</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.no = no;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HeroNode <span class="title">getLeft</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLeft</span><span class="params">(HeroNode left)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.left = left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HeroNode <span class="title">getRight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRight</span><span class="params">(HeroNode right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;HeroNode &#123; no=&quot;</span> + no + <span class="string">&quot;, name=&quot;</span> + name + <span class="string">&quot;&#125;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//递归删除节点</span></span><br><span class="line">    <span class="comment">//1.如果删除的节点是叶子节点，则删除该节点</span></span><br><span class="line">    <span class="comment">//2.如归删除的节点是非叶子节点，则删除该子树</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delNode</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 思路：</span></span><br><span class="line"><span class="comment">         * 1.因为我们的二叉树是单向的，所以我们是判断当前节点的子节点是否需要删除节点，而不能去判断当前这个节点是不是需要删除节点</span></span><br><span class="line"><span class="comment">         * 2.如果当前节点的左子节点不为空，而且左子节点就是要删除节点，就将this.left = null；并且就返回（结束递归删除）</span></span><br><span class="line"><span class="comment">         * 3.如果当前节点的右子节点不为空，并且右子节点就是要删除节点，就将this.right= null；并且就返回（结束递归删除）</span></span><br><span class="line"><span class="comment">         * 4.如果第2步和第3步没有删除节点，那么我们就需要向左子树进行递归删除</span></span><br><span class="line"><span class="comment">         * 5.如果第4步也没有删除节点应当向右子树进行递归删除</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">//2.如果当前节点的左子节点不为空，而且左子节点就是要删除节点，就将this.left = null；并且就返回（结束递归删除）</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.left != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.left.no == no) &#123;</span><br><span class="line">            <span class="keyword">this</span>.left = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3.如果当前节点的右子节点不为空，并且右子节点就是要删除节点，就将this.right= null；并且就返回（结束递归删除）</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.right != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.right.no == no) &#123;</span><br><span class="line">            <span class="keyword">this</span>.right = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//4.向左子树进行递归删除</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">this</span>.left.delNode(no);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//5.向右子树进行递归删除</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">this</span>.right.delNode(no);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="顺序存储二叉树"><a class="markdownIt-Anchor" href="#顺序存储二叉树">#</a> 顺序存储二叉树</h1>
<h2 id="基本介绍"><a class="markdownIt-Anchor" href="#基本介绍">#</a> 基本介绍</h2>
<p>从数据存储来看，<strong>数组存储方式</strong>和<strong>树</strong>的存储方式可以相互转换，即数组可以转换成树，树也可以转换成数组，如下面所示。</p>
<p><a href="https://imgtu.com/i/R7m2BF"><img src="https://z3.ax1x.com/2021/07/06/R7m2BF.png" alt="R7m2BF.png"></a></p>
<ul>
<li>
<p>顺序二叉树通常只考虑完全二叉树</p>
</li>
<li>
<p>第 n 个元素的左子节点为 2 * n + 1</p>
</li>
<li>
<p>第 n 个元素的右子节点为 2 * n + 2</p>
</li>
<li>
<p>第 n 个元素的父节点为 (n-1) / 2</p>
</li>
<li>
<p>n : 表示二叉树中的第几个元素 (按 0 开始编号 如上图所示)</p>
</li>
</ul>
<h2 id="代码展示-4"><a class="markdownIt-Anchor" href="#代码展示-4">#</a> 代码展示</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> demo04;</span><br><span class="line"><span class="comment">//顺序存储二叉树的前、中、后序遍历</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayBinaryTreeDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;;</span><br><span class="line">        <span class="comment">//创建一个ArrBinaryTree</span></span><br><span class="line">        ArrayBinaryTree binaryTree=<span class="keyword">new</span> ArrayBinaryTree(arr);</span><br><span class="line">        System.out.println(<span class="string">&quot;前序遍历&quot;</span>);</span><br><span class="line">        binaryTree.preOrder();</span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println(<span class="string">&quot;中序遍历&quot;</span>);</span><br><span class="line">        binaryTree.infixOrder();</span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println(<span class="string">&quot;后序遍历&quot;</span>);</span><br><span class="line">        binaryTree.postOrder();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//编写一个ArrayBinaryTree，实现顺序存储二叉树遍历</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArrayBinaryTree</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] arr;<span class="comment">//存储数据节点的数组</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayBinaryTree</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.arr = arr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//重载 preOrder</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.preOrder(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重载 infixOrder</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">infixOrder</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.infixOrder(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重载 postOrder</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postOrder</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.postOrder(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//编写一个方法，完成顺序存储二叉树的前序遍历</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index 数组下标</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//如果数组为空，或者 arr.length == 0;</span></span><br><span class="line">        <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length == <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;数组为空，无法进行二叉树的前序遍历&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//输出当前这个元素</span></span><br><span class="line">        System.out.print(arr[index]);</span><br><span class="line">        <span class="comment">//向左遍历递归</span></span><br><span class="line">        <span class="keyword">if</span> (index * <span class="number">2</span> + <span class="number">1</span> &lt; arr.length) &#123;</span><br><span class="line">            preOrder(<span class="number">2</span> * index + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//向右遍历递归</span></span><br><span class="line">        <span class="keyword">if</span> (index * <span class="number">2</span> + <span class="number">2</span> &lt; arr.length) &#123;</span><br><span class="line">            preOrder(<span class="number">2</span> * index + <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//编写一个方法，完成顺序存储二叉树的中序遍历</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index 数组下标</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">infixOrder</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//如果数组为空，或者 arr.length == 0;</span></span><br><span class="line">        <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length == <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;数组为空，无法进行二叉树的中序遍历&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//向左遍历递归</span></span><br><span class="line">        <span class="keyword">if</span> (index * <span class="number">2</span> + <span class="number">1</span> &lt; arr.length) &#123;</span><br><span class="line">            infixOrder(<span class="number">2</span> * index + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//输出当前这个元素</span></span><br><span class="line">        System.out.print(arr[index]);</span><br><span class="line">        <span class="comment">//向右遍历递归</span></span><br><span class="line">        <span class="keyword">if</span> (index * <span class="number">2</span> + <span class="number">2</span> &lt; arr.length) &#123;</span><br><span class="line">            infixOrder(<span class="number">2</span> * index + <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//编写一个方法，完成顺序存储二叉树的后序遍历</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index 数组下标</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postOrder</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//如果数组为空，或者 arr.length == 0;</span></span><br><span class="line">        <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length == <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;数组为空，无法进行二叉树的后序遍历&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//向左遍历递归</span></span><br><span class="line">        <span class="keyword">if</span> (index * <span class="number">2</span> + <span class="number">1</span> &lt; arr.length) &#123;</span><br><span class="line">            postOrder(<span class="number">2</span> * index + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//向右遍历递归</span></span><br><span class="line">        <span class="keyword">if</span> (index * <span class="number">2</span> + <span class="number">2</span> &lt; arr.length) &#123;</span><br><span class="line">            postOrder(<span class="number">2</span> * index + <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//输出当前这个元素</span></span><br><span class="line">        System.out.print(arr[index]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;	</span><br></pre></td></tr></table></figure>
<h1 id="线索化二叉树"><a class="markdownIt-Anchor" href="#线索化二叉树">#</a> 线索化二叉树</h1>
<h2 id="基本介绍-2"><a class="markdownIt-Anchor" href="#基本介绍-2">#</a> 基本介绍</h2>
<ul>
<li>
<p>n 个结点的二叉链表中含有 n+1 【公式 2n-(n-1)=n+1】 个空指针域。利用二叉链表中的空指针域，存放指向<strong>该</strong><a href="">结点</a>) 在<strong>某种遍历次序</strong>下的前驱和后继结点的指针（这种附加的指针称为 &quot;线索&quot;）</p>
</li>
<li>
<p>这种加上了线索的二叉链表 称为<strong>线索链表</strong>，相应的二叉树称为<strong>线索二叉树 (Threaded BinaryTree)</strong>。根据线索性质的不同，线索二叉树可分为<strong>前序线索二叉树、中序线索二叉树和后序线索二叉树</strong>三种</p>
</li>
<li>
<p>一个结点的前一个结点，称为<strong>前驱</strong>结点</p>
</li>
<li>
<p>一个结点的后一个结点，称为<strong>后继</strong>结点</p>
</li>
</ul>
<p><a href="https://imgtu.com/i/R7m4hR"><img src="https://z3.ax1x.com/2021/07/06/R7m4hR.png" alt="R7m4hR.png"></a></p>
<ul>
<li>说明：当线索化二叉树，Node 节点的属性 left 和 right，有以下两种情况：(根据上图分析)
<ol>
<li>left 指向的是左子树，也可能是指向的前驱节点，比如 1 号 节点 left 指向的左子树，而 10 号 节点的 left 指向的就是前驱节点</li>
<li>right 指向的是右子树，也可能是指向后继节点， 比如 1 号 节点 right 指向的右子树，而 10 号 节点的 right 指向的是后继节点</li>
</ol>
</li>
</ul>
<h2 id="代码展示-5"><a class="markdownIt-Anchor" href="#代码展示-5">#</a> 代码展示</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> demo05;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadedBinaryTreeDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建需要的节点</span></span><br><span class="line">        HeroNode root = <span class="keyword">new</span> HeroNode(<span class="number">1</span>, <span class="string">&quot;zoffy&quot;</span>);</span><br><span class="line">        HeroNode node2 = <span class="keyword">new</span> HeroNode(<span class="number">3</span>, <span class="string">&quot;man&quot;</span>);</span><br><span class="line">        HeroNode node3 = <span class="keyword">new</span> HeroNode(<span class="number">6</span>, <span class="string">&quot;taro&quot;</span>);</span><br><span class="line">        HeroNode node4 = <span class="keyword">new</span> HeroNode(<span class="number">8</span>, <span class="string">&quot;taiga&quot;</span>);</span><br><span class="line">        HeroNode node5 = <span class="keyword">new</span> HeroNode(<span class="number">10</span>, <span class="string">&quot;mebius&quot;</span>);</span><br><span class="line">        HeroNode node6 = <span class="keyword">new</span> HeroNode(<span class="number">14</span>, <span class="string">&quot;zero&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//二叉树，后面我们递归创建，现在简单处理使用手动创建</span></span><br><span class="line">        root.setLeft(node2);</span><br><span class="line">        root.setRight(node3);</span><br><span class="line">        node2.setLeft(node4);</span><br><span class="line">        node2.setRight(node5);</span><br><span class="line">        node3.setLeft(node6);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//测试线索化</span></span><br><span class="line">        ThreadedBinaryTree threadedBinaryTree = <span class="keyword">new</span> ThreadedBinaryTree();</span><br><span class="line">        threadedBinaryTree.setRoot(root);</span><br><span class="line">        threadedBinaryTree.threadedNodes();</span><br><span class="line"></span><br><span class="line">        HeroNode left = node5.getLeft();</span><br><span class="line">        System.out.println(left);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//当线索化二叉树后，不能再使用原来的方法遍历</span></span><br><span class="line">        System.out.println(<span class="string">&quot;使用线索化的方式遍历线索化二叉树&quot;</span>);</span><br><span class="line">        threadedBinaryTree.threadedList();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义ThreadedBinaryTree 实现了线索化功能的二叉树</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadedBinaryTree</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> HeroNode root;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//为了实现线索化，需要创建要给指向当前节点的前驱节点的指针</span></span><br><span class="line">    <span class="comment">//在递归进行线索化时，pre 总是保留前一个节点</span></span><br><span class="line">    <span class="keyword">private</span> HeroNode pre = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRoot</span><span class="params">(HeroNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.root = root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重载threadedNodes方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">threadedNodes</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.threadedNodes(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历线索化二叉树的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">threadedList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//定义一个变量，存储当前遍历的节点，从root开始</span></span><br><span class="line">        HeroNode node = root;</span><br><span class="line">        <span class="keyword">while</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//循环的找到leftType==1的节点，第一个找到的是8节点</span></span><br><span class="line">            <span class="comment">//后面随着遍历而变化，因为当leftType==1时，说明该节点是按照线索化处理后的有效节点</span></span><br><span class="line">            <span class="keyword">while</span> (node.getLeftType() == <span class="number">0</span>) &#123;</span><br><span class="line">                node = node.getLeft();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//打印这个节点</span></span><br><span class="line">            System.out.println(node);</span><br><span class="line">            <span class="comment">//如果当前节点的右指针指向的是后继节点，就一直输出</span></span><br><span class="line">            <span class="keyword">while</span> (node.getRightType() == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">//获取到当前节点的后继节点</span></span><br><span class="line">                node = node.getRight();</span><br><span class="line">                System.out.println(node);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//替换这个遍历的节点</span></span><br><span class="line">            node = node.getRight();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//编写对二叉树进行中序线索化的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">threadedNodes</span><span class="params">(HeroNode node)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//如果node==null 不能线索化</span></span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//第一步 先线索化左子树</span></span><br><span class="line">        threadedNodes(node.getLeft());</span><br><span class="line">        <span class="comment">//第二步 线索化当前节点</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//处理当前节点的前驱节点</span></span><br><span class="line">        <span class="keyword">if</span> (node.getLeft() == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//让当前节点的左指针指向前驱节点</span></span><br><span class="line">            node.setLeft(pre);</span><br><span class="line">            <span class="comment">//修改当前节点的左指针的类型，指向前驱节点</span></span><br><span class="line">            node.setLeftType(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//处理后继节点</span></span><br><span class="line">        <span class="keyword">if</span> (pre != <span class="keyword">null</span> &amp;&amp; pre.getRight() == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//让前驱节点的右指针指向当前节点</span></span><br><span class="line">            pre.setRight(node);</span><br><span class="line">            <span class="comment">//修改前驱节点的右指针类型</span></span><br><span class="line">            pre.setRightType(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//！！！！！！！！每处理一个节点后，让当前节点是下一个节点的前驱节点</span></span><br><span class="line">        pre = node;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//第三步 再线索化右子树</span></span><br><span class="line">        threadedNodes(node.getRight());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建HeroNode 节点</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HeroNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> no;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> HeroNode left;  <span class="comment">//默认为null</span></span><br><span class="line">    <span class="keyword">private</span> HeroNode right; <span class="comment">//默认为null</span></span><br><span class="line">    <span class="comment">//说明：</span></span><br><span class="line">    <span class="comment">//1.如果leftType == 0 表示指向的是左子树，如果leftType == 1 则表示指向前驱节点</span></span><br><span class="line">    <span class="comment">//2.如果rightType ==0 表示指向的是右子树，如果rightType == 1 表示指向后继节点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> leftType;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> rightType;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HeroNode</span><span class="params">(<span class="keyword">int</span> no, String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.no = no;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> no;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNo</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.no = no;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HeroNode <span class="title">getLeft</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLeft</span><span class="params">(HeroNode left)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.left = left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HeroNode <span class="title">getRight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRight</span><span class="params">(HeroNode right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getLeftType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> leftType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLeftType</span><span class="params">(<span class="keyword">int</span> leftType)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.leftType = leftType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getRightType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> rightType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRightType</span><span class="params">(<span class="keyword">int</span> rightType)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.rightType = rightType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;HeroNode &#123; no=&quot;</span> + no + <span class="string">&quot;, name=&quot;</span> + name + <span class="string">&quot;&#125;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>10.树结构基础部分</category>
      </categories>
      <tags>
        <tag>算法与数据结构</tag>
        <tag>二叉树</tag>
        <tag>顺序存储二叉树</tag>
        <tag>线索化二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>图</title>
    <url>/2021/07/08/13.%E5%9B%BE/</url>
    <content><![CDATA[<h1 id="图"><a class="markdownIt-Anchor" href="#图">#</a> 图</h1>
<p><strong>为什么要有图</strong></p>
<p>1) 前面我们学了线性表和树</p>
<p>2) 线性表局限于一个直接前驱和一个直接后继的关系</p>
<p>3) 树也只能有一个直接前驱也就是父节点</p>
<p>4) 当我们需要表示多对多的关系时， 这里我们就用到了图</p>
<h2 id="基本介绍"><a class="markdownIt-Anchor" href="#基本介绍">#</a> 基本介绍</h2>
<p>图是一种数据结构，其中结点可以具有零个或多个相邻元素。两个结点之间的连接称为边。 结点也可以称为顶点。如图：</p>
<p><a href="https://imgtu.com/i/R7fIwq"><img src="https://z3.ax1x.com/2021/07/07/R7fIwq.png" alt="R7fIwq.png"></a></p>
<h2 id="常见概念"><a class="markdownIt-Anchor" href="#常见概念">#</a> 常见概念</h2>
<ol>
<li>顶点 (vertex)</li>
<li>边 (edge)</li>
<li>路径</li>
<li>无向图 (下图所示)</li>
</ol>
<p><a href="https://imgtu.com/i/R7foT0"><img src="https://z3.ax1x.com/2021/07/07/R7foT0.png" alt="R7foT0.png"></a></p>
<ol start="5">
<li>有向图</li>
<li>带权图（网）</li>
</ol>
<p><a href="https://imgtu.com/i/R7f7kV"><img src="https://z3.ax1x.com/2021/07/07/R7f7kV.png" alt="R7f7kV.png"></a></p>
<h2 id="表示方式"><a class="markdownIt-Anchor" href="#表示方式">#</a> 表示方式</h2>
<p>图的表示方式有两种：二维数组表示（邻接矩阵）；链表表示（邻接表）</p>
<h3 id="邻接矩阵"><a class="markdownIt-Anchor" href="#邻接矩阵">#</a> 邻接矩阵</h3>
<p>邻接矩阵是表示图形中顶点之间相邻关系的矩阵，对于 n 个顶点的图而言，矩阵是的 row 和 col 表示的是 1…n 个点</p>
<p><a href="https://imgtu.com/i/R7fHYT"><img src="https://z3.ax1x.com/2021/07/07/R7fHYT.png" alt="R7fHYT.png"></a></p>
<h3 id="链表邻接表"><a class="markdownIt-Anchor" href="#链表邻接表">#</a> 链表（邻接表）</h3>
<ol>
<li>
<p>邻接矩阵需要为每个顶点都分配 n 个边的空间，其实有很多边都是不存在，会造成空间的一定损失.</p>
</li>
<li>
<p>邻接表的实现只关心存在的边，不关心不存在的边。因此没有空间浪费，邻接表由数组 + 链表组成</p>
</li>
</ol>
<p><a href="https://imgtu.com/i/R7fLpF"><img src="https://z3.ax1x.com/2021/07/07/R7fLpF.png" alt="R7fLpF.png"></a></p>
<h2 id="入门案例"><a class="markdownIt-Anchor" href="#入门案例">#</a> 入门案例</h2>
<p><a href="https://imgtu.com/i/R7fX6J"><img src="https://z3.ax1x.com/2021/07/07/R7fX6J.png" alt="R7fX6J.png"></a></p>
<h2 id="代码实现"><a class="markdownIt-Anchor" href="#代码实现">#</a> 代码实现</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> demo01;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Graph</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;String&gt; vertexList;<span class="comment">//存储顶点集合</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[][] edges; <span class="comment">//存储图对应的邻接矩阵</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> numOfEdges; <span class="comment">//表示边的数目</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//测试是否创建成功</span></span><br><span class="line">        <span class="keyword">int</span> n=<span class="number">5</span>;</span><br><span class="line">        String[] Vertexs =&#123;<span class="string">&quot;A&quot;</span>,<span class="string">&quot;B&quot;</span>,<span class="string">&quot;C&quot;</span>,<span class="string">&quot;D&quot;</span>,<span class="string">&quot;E&quot;</span>&#125;;</span><br><span class="line">        <span class="comment">//创建图对象</span></span><br><span class="line">        Graph graph = <span class="keyword">new</span> Graph(n);</span><br><span class="line">        <span class="comment">//循环的添加顶点</span></span><br><span class="line">        <span class="keyword">for</span> (String vertex:Vertexs)&#123;</span><br><span class="line">            graph.insertVertex(vertex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//添加边</span></span><br><span class="line">        <span class="comment">//A-B A-C B-C B-D B-E</span></span><br><span class="line">        graph.insertEdge(<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>);<span class="comment">//A-B</span></span><br><span class="line">        graph.insertEdge(<span class="number">0</span>,<span class="number">2</span>,<span class="number">1</span>);<span class="comment">//A-C</span></span><br><span class="line">        graph.insertEdge(<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>);<span class="comment">//B-C</span></span><br><span class="line">        graph.insertEdge(<span class="number">1</span>,<span class="number">3</span>,<span class="number">1</span>);<span class="comment">//B-D</span></span><br><span class="line">        graph.insertEdge(<span class="number">1</span>,<span class="number">4</span>,<span class="number">1</span>);<span class="comment">//B-E</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//显示邻接矩阵</span></span><br><span class="line">        graph.showGraph();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Graph</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="comment">//初始化矩阵和vertexList</span></span><br><span class="line">        edges=<span class="keyword">new</span> <span class="keyword">int</span>[n][n];</span><br><span class="line">        vertexList=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        numOfEdges=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//图中常用的方法</span></span><br><span class="line">    <span class="comment">//返回节点的个数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNumOfVertex</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> vertexList.size();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//得到边的数目</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNumOfEdges</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> numOfEdges;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回结点 i (下标)对应的数据 0-&gt;&quot;A&quot; 1-&gt;&quot;B&quot; 2-&gt;&quot;C&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getValueByIndex</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> vertexList.get(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回v1,v2的权值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getWeight</span><span class="params">(<span class="keyword">int</span> v1,<span class="keyword">int</span> v2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> edges[v1][v2];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//显示图对应的矩阵</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showGraph</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] link:edges)&#123;</span><br><span class="line">            System.out.println(Arrays.toString(link));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//插入顶点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertVertex</span><span class="params">(String vertex)</span></span>&#123;</span><br><span class="line">        vertexList.add(vertex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加边</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v1 表示点的下标即是第几个顶点 &quot;A&quot;-&quot;B&quot; &quot;A&quot;-0 &quot;B&quot;-1</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v2 第二个顶点对应的下标</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> weight</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertEdge</span><span class="params">(<span class="keyword">int</span> v1,<span class="keyword">int</span> v2,<span class="keyword">int</span> weight)</span></span>&#123;</span><br><span class="line">        <span class="comment">//因为是无向图</span></span><br><span class="line">        edges[v1][v2]=weight;</span><br><span class="line">        edges[v2][v1]=weight;</span><br><span class="line">        numOfEdges++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="图的遍历"><a class="markdownIt-Anchor" href="#图的遍历">#</a> 图的遍历</h1>
<p>所谓图的遍历，即是对结点的访问。一个图有那么多个结点，如何遍历这些结点，需要特定策略，一般有两种访问策略:</p>
<p>(1) 深度优先遍历</p>
<p>(2) 广度优先遍历</p>
<h2 id="深度优先遍历dfs"><a class="markdownIt-Anchor" href="#深度优先遍历dfs">#</a> 深度优先遍历 DFS</h2>
<h3 id="简单介绍"><a class="markdownIt-Anchor" href="#简单介绍">#</a> 简单介绍</h3>
<ul>
<li>
<p>图的深度优先搜索 (Depth First Search) 。</p>
<ol>
<li>
<p>深度优先遍历，从初始访问结点出发，初始访问结点可能有多个邻接结点，深度优先遍历的策略就是首先访问第一个邻接结点，然后再以这个被访问的邻接结点作为初始结点，访问它的第一个邻接结点， 可以这样理解：每次都在访问完<strong>当前结点</strong>后首先访问<strong>当前结点的第一个邻接结点</strong>。</p>
</li>
<li>
<p>我们可以看到，这样的访问策略是优先往纵向挖掘深入，而不是对一个结点的所有邻接结点进行横向访问。</p>
</li>
<li>
<p>显然，深度优先搜索是一个递归的过程</p>
</li>
</ol>
</li>
</ul>
<h3 id="算法步骤"><a class="markdownIt-Anchor" href="#算法步骤">#</a> 算法步骤</h3>
<ol>
<li>
<p>访问初始结点 v，并标记结点 v 为已访问。</p>
</li>
<li>
<p>查找结点 v 的第一个邻接结点 w。</p>
</li>
<li>
<p>若 w 存在，则继续执行 4，如果 w 不存在，则回到第 1 步，将从 v 的下一个结点继续。</p>
</li>
<li>
<p>若 w 未被访问，对 w 进行深度优先遍历递归（即把 w 当做另一个 v，然后进行步骤 123）。</p>
</li>
<li>
<p>查找结点 v 的 w 邻接结点的下一个邻接结点，转到步骤 3。</p>
</li>
</ol>
<p><a href="https://imgtu.com/i/R7fxmR"><img src="https://z3.ax1x.com/2021/07/07/R7fxmR.png" alt="R7fxmR.png"></a></p>
<h3 id="代码展示"><a class="markdownIt-Anchor" href="#代码展示">#</a> 代码展示</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> demo02;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Graph</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;String&gt; vertexList;<span class="comment">//存储顶点集合</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[][] edges; <span class="comment">//存储图对应的邻接矩阵</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> numOfEdges; <span class="comment">//表示边的数目</span></span><br><span class="line">    <span class="comment">//定义给数组boolean[] ,记录某个结点是否被访问</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span>[] isVisited ;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//测试是否创建成功</span></span><br><span class="line">        <span class="keyword">int</span> n=<span class="number">5</span>;</span><br><span class="line">        String[] Vertexs =&#123;<span class="string">&quot;A&quot;</span>,<span class="string">&quot;B&quot;</span>,<span class="string">&quot;C&quot;</span>,<span class="string">&quot;D&quot;</span>,<span class="string">&quot;E&quot;</span>&#125;;</span><br><span class="line">        <span class="comment">//创建图对象</span></span><br><span class="line">        Graph graph = <span class="keyword">new</span> Graph(n);</span><br><span class="line">        <span class="comment">//循环的添加顶点</span></span><br><span class="line">        <span class="keyword">for</span> (String vertex:Vertexs)&#123;</span><br><span class="line">            graph.insertVertex(vertex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//添加边</span></span><br><span class="line">        <span class="comment">//A-B A-C B-C B-D B-E</span></span><br><span class="line">        graph.insertEdge(<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>);<span class="comment">//A-B</span></span><br><span class="line">        graph.insertEdge(<span class="number">0</span>,<span class="number">2</span>,<span class="number">1</span>);<span class="comment">//A-C</span></span><br><span class="line">        graph.insertEdge(<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>);<span class="comment">//B-C</span></span><br><span class="line">        graph.insertEdge(<span class="number">1</span>,<span class="number">3</span>,<span class="number">1</span>);<span class="comment">//B-D</span></span><br><span class="line">        graph.insertEdge(<span class="number">1</span>,<span class="number">4</span>,<span class="number">1</span>);<span class="comment">//B-E</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//显示邻接矩阵</span></span><br><span class="line">        graph.showGraph();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//测试 dfs 遍历是否 OK</span></span><br><span class="line">        System.out.println(<span class="string">&quot;深度遍历&quot;</span>);</span><br><span class="line">        graph.dfs();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Graph</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="comment">//初始化矩阵和vertexList</span></span><br><span class="line">        edges=<span class="keyword">new</span> <span class="keyword">int</span>[n][n];</span><br><span class="line">        vertexList=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        numOfEdges=<span class="number">0</span>;</span><br><span class="line">        isVisited = <span class="keyword">new</span> <span class="keyword">boolean</span>[<span class="number">5</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//得到第一个邻接节点的下标 w</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getFirstNeighbor</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;vertexList.size();j++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (edges[index][j]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//根据前一个邻接节点的下标来获取下一个邻接节点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNextNeighbor</span><span class="params">(<span class="keyword">int</span> v1,<span class="keyword">int</span> v2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=v2+<span class="number">1</span>;j&lt;vertexList.size();j++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (edges[v1][j]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//深度优先遍历方法</span></span><br><span class="line">    <span class="comment">// i 第一次是 0</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">boolean</span>[] isVisited,<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        <span class="comment">//首先我们访问该节点，输出</span></span><br><span class="line">        System.out.print(getValueByIndex(i)+<span class="string">&quot;-&gt;&quot;</span>);</span><br><span class="line">        <span class="comment">//将节点设置成已访问</span></span><br><span class="line">        isVisited[i]=<span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">//查找结点 i 的第一个邻接节点 w</span></span><br><span class="line">        <span class="keyword">int</span> w=getFirstNeighbor(i);</span><br><span class="line">        <span class="keyword">while</span> (w!=-<span class="number">1</span>)&#123; <span class="comment">//说明有邻接节点</span></span><br><span class="line">            <span class="keyword">if</span> (!isVisited[w])&#123;</span><br><span class="line">                dfs(isVisited,w);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果 w 结点已经被访问过</span></span><br><span class="line">            w = getNextNeighbor(i,w);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对 dfs 进行一个重载，遍历我们所有的节点，并进行 dfs</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//遍历所有的节点，进行dfs【回溯】</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; getNumOfVertex(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!isVisited[i])&#123;</span><br><span class="line">                dfs(isVisited,i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//图中常用的方法</span></span><br><span class="line">    <span class="comment">//返回节点的个数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNumOfVertex</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> vertexList.size();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//得到边的数目</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNumOfEdges</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> numOfEdges;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回结点 i (下标)对应的数据 0-&gt;&quot;A&quot; 1-&gt;&quot;B&quot; 2-&gt;&quot;C&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getValueByIndex</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> vertexList.get(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回v1,v2的权值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getWeight</span><span class="params">(<span class="keyword">int</span> v1,<span class="keyword">int</span> v2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> edges[v1][v2];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//显示图对应的矩阵</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showGraph</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] link:edges)&#123;</span><br><span class="line">            System.out.println(Arrays.toString(link));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//插入顶点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertVertex</span><span class="params">(String vertex)</span></span>&#123;</span><br><span class="line">        vertexList.add(vertex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加边</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v1 表示点的下标即是第几个顶点 &quot;A&quot;-&quot;B&quot; &quot;A&quot;-0 &quot;B&quot;-1</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v2 第二个顶点对应的下标</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> weight</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertEdge</span><span class="params">(<span class="keyword">int</span> v1,<span class="keyword">int</span> v2,<span class="keyword">int</span> weight)</span></span>&#123;</span><br><span class="line">        <span class="comment">//因为是无向图</span></span><br><span class="line">        edges[v1][v2]=weight;</span><br><span class="line">        edges[v2][v1]=weight;</span><br><span class="line">        numOfEdges++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="广度优先遍历bfs"><a class="markdownIt-Anchor" href="#广度优先遍历bfs">#</a> 广度优先遍历 BFS</h2>
<h3 id="基本思想"><a class="markdownIt-Anchor" href="#基本思想">#</a> 基本思想</h3>
<p>图的广度优先搜索 (Broad First Search) 。</p>
<p>类似于一个分层搜索的过程，广度优先遍历需要使用一个队列以保持访问过的结点的顺序，以便按这个顺序来访问这些结点的邻接结点</p>
<h3 id="算法步骤-2"><a class="markdownIt-Anchor" href="#算法步骤-2">#</a> 算法步骤</h3>
<p>1) 访问初始结点 v 并标记结点 v 为已访问。</p>
<p>2) 结点 v 入队列</p>
<p>3) 当队列非空时，继续执行，否则算法结束。</p>
<p>4) 出队列，取得队头结点 u。</p>
<p>5) 查找结点 u 的第一个邻接结点 w。</p>
<p>6) 若结点 u 的邻接结点 w 不存在，则转到步骤 3；否则循环执行以下三个步骤：</p>
<p>6.1 若结点 w 尚未被访问，则访问结点 w 并标记为已访问。</p>
<p>6.2 结点 w 入队列</p>
<p>6.3 查找结点 u 的继 w 邻接结点后的下一个邻接结点 w，转到步骤 6。</p>
<p><a href="https://imgtu.com/i/R7fxmR"><img src="https://z3.ax1x.com/2021/07/07/R7fxmR.png" alt="R7fxmR.png"></a></p>
<h3 id="代码分析"><a class="markdownIt-Anchor" href="#代码分析">#</a> 代码分析</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> demo03;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="comment">//广度优先算法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Graph</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;String&gt; vertexList;<span class="comment">//存储顶点集合</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[][] edges; <span class="comment">//存储图对应的邻接矩阵</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> numOfEdges; <span class="comment">//表示边的数目</span></span><br><span class="line">    <span class="comment">//定义给数组boolean[] ,记录某个结点是否被访问</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span>[] isVisited;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//测试是否创建成功</span></span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">5</span>;</span><br><span class="line">        String[] Vertexs = &#123;<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span>, <span class="string">&quot;D&quot;</span>, <span class="string">&quot;E&quot;</span>&#125;;</span><br><span class="line">        <span class="comment">//创建图对象</span></span><br><span class="line">        Graph graph = <span class="keyword">new</span> Graph(n);</span><br><span class="line">        <span class="comment">//循环的添加顶点</span></span><br><span class="line">        <span class="keyword">for</span> (String vertex : Vertexs) &#123;</span><br><span class="line">            graph.insertVertex(vertex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//添加边</span></span><br><span class="line">        <span class="comment">//A-B A-C B-C B-D B-E</span></span><br><span class="line">        graph.insertEdge(<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>);<span class="comment">//A-B</span></span><br><span class="line">        graph.insertEdge(<span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>);<span class="comment">//A-C</span></span><br><span class="line">        graph.insertEdge(<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>);<span class="comment">//B-C</span></span><br><span class="line">        graph.insertEdge(<span class="number">1</span>, <span class="number">3</span>, <span class="number">1</span>);<span class="comment">//B-D</span></span><br><span class="line">        graph.insertEdge(<span class="number">1</span>, <span class="number">4</span>, <span class="number">1</span>);<span class="comment">//B-E</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//显示邻接矩阵</span></span><br><span class="line">        graph.showGraph();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//测试 dfs 遍历是否 OK</span></span><br><span class="line">        System.out.println(<span class="string">&quot;深度遍历&quot;</span>);</span><br><span class="line">        <span class="comment">//graph.dfs();</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//广度优先</span></span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println(<span class="string">&quot;广度优先&quot;</span>);</span><br><span class="line">        graph.bfs();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Graph</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//初始化矩阵和vertexList</span></span><br><span class="line">        edges = <span class="keyword">new</span> <span class="keyword">int</span>[n][n];</span><br><span class="line">        vertexList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        numOfEdges = <span class="number">0</span>;</span><br><span class="line">        isVisited = <span class="keyword">new</span> <span class="keyword">boolean</span>[<span class="number">5</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//得到第一个邻接节点的下标 w</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getFirstNeighbor</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; vertexList.size(); j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (edges[index][j] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据前一个邻接节点的下标来获取下一个邻接节点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNextNeighbor</span><span class="params">(<span class="keyword">int</span> v1, <span class="keyword">int</span> v2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = v2 + <span class="number">1</span>; j &lt; vertexList.size(); j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (edges[v1][j] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//深度优先遍历方法</span></span><br><span class="line">    <span class="comment">// i 第一次是 0</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">boolean</span>[] isVisited, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//首先我们访问该节点，输出</span></span><br><span class="line">        System.out.print(getValueByIndex(i) + <span class="string">&quot;-&gt;&quot;</span>);</span><br><span class="line">        <span class="comment">//将节点设置成已访问</span></span><br><span class="line">        isVisited[i] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">//查找结点 i 的第一个邻接节点 w</span></span><br><span class="line">        <span class="keyword">int</span> w = getFirstNeighbor(i);</span><br><span class="line">        <span class="keyword">while</span> (w != -<span class="number">1</span>) &#123; <span class="comment">//说明有邻接节点</span></span><br><span class="line">            <span class="keyword">if</span> (!isVisited[w]) &#123;</span><br><span class="line">                dfs(isVisited, w);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果 w 结点已经被访问过</span></span><br><span class="line">            w = getNextNeighbor(i, w);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对 dfs 进行一个重载，遍历我们所有的节点，并进行 dfs</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//遍历所有的节点，进行dfs【回溯】</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; getNumOfVertex(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!isVisited[i]) &#123;</span><br><span class="line">                dfs(isVisited, i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对一个节点进行广度优先算法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">boolean</span>[] isVisited, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> u; <span class="comment">//表示队列的头节点对应的下标</span></span><br><span class="line">        <span class="keyword">int</span> w; <span class="comment">//邻接节点 w</span></span><br><span class="line">        <span class="comment">//队列,节点访问的顺序</span></span><br><span class="line">        LinkedList queue = <span class="keyword">new</span> LinkedList();</span><br><span class="line">        <span class="comment">//访问节点，输出节点信息</span></span><br><span class="line">        System.out.print(getValueByIndex(i) + <span class="string">&quot;-&gt;&quot;</span>);</span><br><span class="line">        <span class="comment">//标记为已访问</span></span><br><span class="line">        isVisited[i] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">//将节点加入队列</span></span><br><span class="line">        queue.addLast(i);</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="comment">//取出队列的头节点下标</span></span><br><span class="line">            u = (Integer) queue.removeFirst();</span><br><span class="line">            <span class="comment">//得到第一个邻接点的下标 w</span></span><br><span class="line">            w = getFirstNeighbor(u);</span><br><span class="line">            <span class="keyword">while</span> (w != -<span class="number">1</span>) &#123; <span class="comment">//找到</span></span><br><span class="line">                <span class="comment">//判断是否访问过</span></span><br><span class="line">                <span class="keyword">if</span> (!isVisited[w]) &#123;</span><br><span class="line">                    System.out.print(getValueByIndex(w) + <span class="string">&quot;-&gt;&quot;</span>);</span><br><span class="line">                    <span class="comment">//标记已经访问</span></span><br><span class="line">                    isVisited[w] = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="comment">//加入队列</span></span><br><span class="line">                    queue.addLast(w);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//以 u 为前驱点找 w 后面的下一个邻接点</span></span><br><span class="line">                w = getNextNeighbor(u, w); <span class="comment">//体现出广度优先</span></span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//要遍历所有的节点，都进行广度优先搜索</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bfs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; getNumOfVertex(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!isVisited[i]) &#123;</span><br><span class="line">                bfs(isVisited, i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//图中常用的方法</span></span><br><span class="line">    <span class="comment">//返回节点的个数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNumOfVertex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> vertexList.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//得到边的数目</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNumOfEdges</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> numOfEdges;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回结点 i (下标)对应的数据 0-&gt;&quot;A&quot; 1-&gt;&quot;B&quot; 2-&gt;&quot;C&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getValueByIndex</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> vertexList.get(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回v1,v2的权值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getWeight</span><span class="params">(<span class="keyword">int</span> v1, <span class="keyword">int</span> v2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> edges[v1][v2];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//显示图对应的矩阵</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showGraph</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] link : edges) &#123;</span><br><span class="line">            System.out.println(Arrays.toString(link));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//插入顶点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertVertex</span><span class="params">(String vertex)</span> </span>&#123;</span><br><span class="line">        vertexList.add(vertex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加边</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v1     表示点的下标即是第几个顶点 &quot;A&quot;-&quot;B&quot; &quot;A&quot;-0 &quot;B&quot;-1</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v2     第二个顶点对应的下标</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> weight</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertEdge</span><span class="params">(<span class="keyword">int</span> v1, <span class="keyword">int</span> v2, <span class="keyword">int</span> weight)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//因为是无向图</span></span><br><span class="line">        edges[v1][v2] = weight;</span><br><span class="line">        edges[v2][v1] = weight;</span><br><span class="line">        numOfEdges++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="深度优先vs广度优先"><a class="markdownIt-Anchor" href="#深度优先vs广度优先">#</a> 深度优先 VS 广度优先</h2>
<p>深度优先：纵向往下走</p>
<p>广度优先：横向的，一层一层的走</p>
<p><a href="https://imgtu.com/i/R7hSTx"><img src="https://z3.ax1x.com/2021/07/07/R7hSTx.png" alt="R7hSTx.png"></a></p>
]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>13.图</category>
      </categories>
      <tags>
        <tag>算法与数据结构</tag>
        <tag>图</tag>
        <tag>深度优先算法</tag>
        <tag>广度优先算法</tag>
      </tags>
  </entry>
  <entry>
    <title>栈</title>
    <url>/2021/07/07/05.%E6%A0%88Stack/</url>
    <content><![CDATA[<h2 id="栈stack"><a class="markdownIt-Anchor" href="#栈stack">#</a> 栈 Stack</h2>
<h2 id="栈的简介"><a class="markdownIt-Anchor" href="#栈的简介">#</a> 栈的简介</h2>
<ol>
<li>
<p>栈的英文为 (stack)</p>
</li>
<li>
<p>栈是一个<strong>先入后出</strong> (FILO-First In Last Out) 的有序列表。</p>
</li>
<li>
<p>栈 (stack) 是限制线性表中元素的插入和删除<strong>只能在线性表的同一端</strong>进行的一种特殊线性表。允许插入和删除的一端，为变化的一端，称为<strong>栈顶</strong> (Top)，另一端为固定的一端，称为<strong>栈底</strong> (Bottom)。</p>
</li>
<li>
<p>根据栈的定义可知，最先放入栈中元素在栈底，最后放入的元素在栈顶，而删除元素刚好相反，最后放入的元素最先删除，最先放入的元素最后删除</p>
</li>
</ol>
<h2 id="出栈pop和入栈pus图显"><a class="markdownIt-Anchor" href="#出栈pop和入栈pus图显">#</a> 出栈 (pop) 和入栈 (pus)（图显）</h2>
<p><a href="https://imgtu.com/i/R7AXrQ"><img src="https://z3.ax1x.com/2021/07/06/R7AXrQ.png" alt="R7AXrQ.png"></a></p>
<p><a href="https://imgtu.com/i/R7E9P0"><img src="https://z3.ax1x.com/2021/07/06/R7E9P0.png" alt="R7E9P0.png"></a></p>
<h2 id="栈的应用场景"><a class="markdownIt-Anchor" href="#栈的应用场景">#</a> 栈的应用场景</h2>
<ol>
<li>子程序的调用：在跳往子程序前，会先将下个指令的地址存到堆栈中，直到子程序执行完后再将地址取出，以回到原来的程序中。</li>
<li>处理递归调用：和子程序的调用类似，只是除了储存下一个指令的地址外，也将参数、区域变量等数据存入堆栈中。</li>
<li>表达式的转换 [中缀表达式转后缀表达式] 与求值 (实际解决)。</li>
<li>二叉树的遍历。</li>
<li>图形的深度优先 (depth 一 first) 搜索法。</li>
</ol>
<h2 id="栈的快速入门"><a class="markdownIt-Anchor" href="#栈的快速入门">#</a> 栈的快速入门</h2>
<p><a href="https://imgtu.com/i/R7EkMF"><img src="https://z3.ax1x.com/2021/07/06/R7EkMF.png" alt="R7EkMF.png"></a></p>
<h3 id="代码展示数组模拟栈"><a class="markdownIt-Anchor" href="#代码展示数组模拟栈">#</a> 代码展示（数组模拟栈）</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> demo01;</span><br><span class="line"><span class="comment">//测试ArrayStack是否正确</span></span><br><span class="line">        <span class="comment">//创建一个ArrayStack对象表示  栈</span></span><br><span class="line">        ArrayStack stack = <span class="keyword">new</span> ArrayStack(<span class="number">4</span>);</span><br><span class="line">        String key=<span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">boolean</span> loop=<span class="keyword">true</span>;<span class="comment">//控制是否退出菜单</span></span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">while</span> (loop)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;show：表示显示栈&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;exit：表示显示栈&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;push：表示添加数据到栈（入栈）&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;pop：表示从栈中取出数据（出栈）&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;请输出你的选择&quot;</span>);</span><br><span class="line">            key=scanner.next();</span><br><span class="line">            <span class="keyword">switch</span> (key)&#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;show&quot;</span>:</span><br><span class="line">                    stack.list();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;exit&quot;</span>:</span><br><span class="line">                    scanner.close();</span><br><span class="line">                    loop=<span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;push&quot;</span>:</span><br><span class="line">                    System.out.println(<span class="string">&quot;请输入一个数&quot;</span>);</span><br><span class="line">                    <span class="keyword">int</span> value=scanner.nextInt();</span><br><span class="line">                    stack.push(value);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;pop&quot;</span>:</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">int</span> res=stack.pop();</span><br><span class="line">                        System.out.printf(<span class="string">&quot;出栈的数据是%d\n&quot;</span>,res);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        System.out.println(e.getMessage());</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                       <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;程序退出&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个ArrayStack 表示栈</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArrayStack</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxSize;<span class="comment">//栈的大小</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] stack;<span class="comment">//数组、数组模拟栈，数据就放在该数组里</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> top=-<span class="number">1</span>;<span class="comment">//top表示栈顶，初始值为-1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayStack</span><span class="params">(<span class="keyword">int</span> maxSize)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.maxSize = maxSize;</span><br><span class="line">        stack=<span class="keyword">new</span> <span class="keyword">int</span> [<span class="keyword">this</span>.maxSize];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//栈满</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFull</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> top==maxSize-<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//栈空</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> top==-<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//入栈-push</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">        <span class="comment">//先判断是否栈满</span></span><br><span class="line">        <span class="keyword">if</span>(isFull())&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;栈满&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        top++;</span><br><span class="line">        stack[top]=value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//出栈-pop,将栈顶的数据返回</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//先判断是否null</span></span><br><span class="line">        <span class="keyword">if</span>(isEmpty())&#123;</span><br><span class="line">            <span class="keyword">new</span> RuntimeException(<span class="string">&quot;栈空&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> value=stack[top];</span><br><span class="line">        top--;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//显示栈（遍历栈）</span></span><br><span class="line">    <span class="comment">//遍历是，需要从栈顶开始显示</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">list</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//判断是否栈空</span></span><br><span class="line">        <span class="keyword">if</span>(isEmpty())&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;栈空&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=top;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            System.out.printf(<span class="string">&quot;stack[%d]=%d\n&quot;</span>,i,stack[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="代码展示链表模拟栈练习"><a class="markdownIt-Anchor" href="#代码展示链表模拟栈练习">#</a> 代码展示（链表模拟栈）练习</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="栈实现综合计算器中缀表达式"><a class="markdownIt-Anchor" href="#栈实现综合计算器中缀表达式">#</a> 栈实现综合计算器 (中缀表达式)</h3>
<h4 id="思路分析图解"><a class="markdownIt-Anchor" href="#思路分析图解">#</a> 思路分析 (图解)</h4>
<p><a href="https://imgtu.com/i/R7EMRK"><img src="https://z3.ax1x.com/2021/07/06/R7EMRK.png" alt="R7EMRK.png"></a></p>
<h4 id="代码实现"><a class="markdownIt-Anchor" href="#代码实现">#</a> 代码实现</h4>
<p>先实现一位数运算，后实现多位数运算</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> demo02;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Calculator</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//完成表达式的运算</span></span><br><span class="line">        String expression=<span class="string">&quot;300+2*6-2&quot;</span>;</span><br><span class="line">        <span class="comment">//创建两个栈，数栈，符号栈</span></span><br><span class="line">        ArrayStack numStack=<span class="keyword">new</span> ArrayStack(<span class="number">10</span>);</span><br><span class="line">        ArrayStack operStack=<span class="keyword">new</span> ArrayStack(<span class="number">10</span>);</span><br><span class="line">        <span class="comment">//定义相关变量</span></span><br><span class="line">        <span class="keyword">int</span> index=<span class="number">0</span>;<span class="comment">//用于扫描</span></span><br><span class="line">        <span class="keyword">int</span> num1=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> num2=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> oper=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">char</span> ch=<span class="string">&#x27; &#x27;</span>;<span class="comment">//将每次扫描得到的char保存到ch中</span></span><br><span class="line">        String keepNum=<span class="string">&quot;&quot;</span>;<span class="comment">//用于拼接多位数</span></span><br><span class="line">        <span class="comment">//开始while循环的扫描expression</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="comment">//依次得到expression 的每一个字符</span></span><br><span class="line">            ch=expression.substring(index,index+<span class="number">1</span>).charAt(<span class="number">0</span>);</span><br><span class="line">            <span class="comment">//判断ch是什么，然后做相应的处理</span></span><br><span class="line">            <span class="comment">//如果是运算符</span></span><br><span class="line">            <span class="keyword">if</span>(operStack.isOper(ch))&#123;</span><br><span class="line">                <span class="comment">//如果是运算符；判断当前的符号栈是否为null</span></span><br><span class="line">                <span class="keyword">if</span>(!operStack.isEmpty())&#123;</span><br><span class="line">                    <span class="comment">//如果符号栈有操作符，就进行比较,如果当前的操作符的优先级小于或者等于栈中的操作符，</span></span><br><span class="line">                    <span class="comment">// 就需要从数栈中pop出两个数,在从符号栈中pop出一个符号，进行运算，将得到结果，入数栈，然后将当前的操作符入符号栈</span></span><br><span class="line">                    <span class="keyword">if</span>(operStack.priority(ch)&lt;=operStack.priority(operStack.peek()))&#123;</span><br><span class="line">                        num1=numStack.pop();</span><br><span class="line">                        num2=numStack.pop();</span><br><span class="line">                        oper=operStack.pop();</span><br><span class="line">                        res=numStack.cal(num1,num2,oper);</span><br><span class="line">                        <span class="comment">//把运算符的结果入数栈</span></span><br><span class="line">                        numStack.push(res);</span><br><span class="line">                        <span class="comment">//然后将当前的操作符入符号栈</span></span><br><span class="line">                        operStack.push(ch);</span><br><span class="line">                    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">//如果当前的操作符的优先级大于栈中的操作符</span></span><br><span class="line">                        operStack.push(ch);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//如果为null，直接入栈</span></span><br><span class="line">                    operStack.push(ch);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;<span class="comment">//如果是数字，则直接入数栈</span></span><br><span class="line">                <span class="comment">//numStack.push(ch-48);//? &quot;1+3&quot; &#x27;1&#x27; != 1</span></span><br><span class="line">                <span class="comment">//分析思路</span></span><br><span class="line">                <span class="comment">//1.当处理多位数时，不能发现是一个数就立即入栈，因为他可能是多位数</span></span><br><span class="line">                <span class="comment">//2.在处理数时，需要向expression的表达式的index，后看一位，如果是数就进行扫描，如果是符号才入栈</span></span><br><span class="line">                <span class="comment">//3.因此需要定义一个变量（字符串），用于拼接</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">//处理多位数</span></span><br><span class="line">                keepNum +=ch;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//如果ch已经是expression的最后一位，就直接入栈</span></span><br><span class="line">                <span class="keyword">if</span>(index==expression.length()-<span class="number">1</span>)&#123;</span><br><span class="line">                    numStack.push(Integer.parseInt(keepNum));</span><br><span class="line"></span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//判断下一个字符是不是数字，如果是数字，就继续扫描，如果是运算符，则入栈</span></span><br><span class="line">                    <span class="comment">//注意是看后一位，不是index++</span></span><br><span class="line">                    <span class="keyword">if</span>(operStack.isOper(expression.substring(index+<span class="number">1</span>,index+<span class="number">2</span>).charAt(<span class="number">0</span>)))&#123;</span><br><span class="line">                        <span class="comment">//如果后一位是运算符，则入栈keepNum=&quot;1&quot;或者&quot;123&quot;</span></span><br><span class="line">                        numStack.push(Integer.parseInt(keepNum));</span><br><span class="line">                        <span class="comment">//重要的！！！ ,清空keepNUm</span></span><br><span class="line">                        keepNum=<span class="string">&quot;&quot;</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//让index+1，并判断是否扫描到expression最后</span></span><br><span class="line">            index++;</span><br><span class="line">            <span class="keyword">if</span>(index&gt;=expression.length())&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//当表达式扫描完毕，按顺序的从 数栈和符号栈中pop出相应的数和符号，并运行</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(operStack.isEmpty())&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            num1=numStack.pop();</span><br><span class="line">            num2=numStack.pop();</span><br><span class="line">            oper=operStack.pop();</span><br><span class="line">            res=numStack.cal(num1,num2,oper);</span><br><span class="line">            <span class="comment">//把运算符的结果入数栈</span></span><br><span class="line">            numStack.push(res);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将数栈的最后数，pop出，就是结果</span></span><br><span class="line">        <span class="keyword">int</span> res2=numStack.pop();</span><br><span class="line">        System.out.printf(<span class="string">&quot;表达式%s=%d&quot;</span>,expression,res2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//先创建一个栈，直接使用前面创建好的</span></span><br><span class="line"><span class="comment">//定义一个ArrayStack 表示栈,需要扩展功能</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArrayStack</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxSize;<span class="comment">//栈的大小</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] stack;<span class="comment">//数组、数组模拟栈，数据就放在该数组里</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> top=-<span class="number">1</span>;<span class="comment">//top表示栈顶，初始值为-1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayStack</span><span class="params">(<span class="keyword">int</span> maxSize)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.maxSize = maxSize;</span><br><span class="line">        stack=<span class="keyword">new</span> <span class="keyword">int</span> [<span class="keyword">this</span>.maxSize];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//增加一个方法，可以返回当前栈顶的值，但是不是真正的pop</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">peek</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stack[top];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//栈满</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFull</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> top==maxSize-<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//栈空</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> top==-<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//入栈-push</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">        <span class="comment">//先判断是否栈满</span></span><br><span class="line">        <span class="keyword">if</span>(isFull())&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;栈满&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        top++;</span><br><span class="line">        stack[top]=value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//出栈-pop,将栈顶的数据返回</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//先判断是否null</span></span><br><span class="line">        <span class="keyword">if</span>(isEmpty())&#123;</span><br><span class="line">            <span class="keyword">new</span> RuntimeException(<span class="string">&quot;栈空&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> value=stack[top];</span><br><span class="line">        top--;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//显示栈（遍历栈）</span></span><br><span class="line">    <span class="comment">//遍历是，需要从栈顶开始显示数据</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">list</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//判断是否栈空</span></span><br><span class="line">        <span class="keyword">if</span>(isEmpty())&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;栈空&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=top;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            System.out.printf(<span class="string">&quot;stack[%d]=%d\n&quot;</span>,i,stack[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回运算符的优先级，优先级是程序员未确定，优先级用数字表示</span></span><br><span class="line">    <span class="comment">//数字越大，则优先级越高</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">priority</span><span class="params">(<span class="keyword">int</span> oper)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(oper == <span class="string">&#x27;*&#x27;</span>|| oper==<span class="string">&#x27;/&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(oper == <span class="string">&#x27;+&#x27;</span>|| oper==<span class="string">&#x27;-&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;<span class="comment">//假定目前的表达式只有+、-、*、/</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断是不是一个运算符</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isOper</span><span class="params">(<span class="keyword">char</span> val)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> val==<span class="string">&#x27;+&#x27;</span>||val==<span class="string">&#x27;-&#x27;</span>||val==<span class="string">&#x27;*&#x27;</span>||val==<span class="string">&#x27;/&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//计算方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">cal</span><span class="params">(<span class="keyword">int</span> num1,<span class="keyword">int</span> num2,<span class="keyword">int</span> oper)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;<span class="comment">//res 用于存放计算的结果</span></span><br><span class="line">        <span class="keyword">switch</span> (oper)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">                res=num1+num2;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">                res=num2-num1;<span class="comment">//注意顺序</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">                res=num1*num2;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>:</span><br><span class="line">                res=num2/num1;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="栈的三种表达式"><a class="markdownIt-Anchor" href="#栈的三种表达式">#</a> 栈的三种表达式</h2>
<ul>
<li>前缀表达式（波兰表达式）</li>
<li>中缀表达式</li>
<li>后缀表达式（逆波兰表达式）</li>
</ul>
<h3 id="前缀表达式"><a class="markdownIt-Anchor" href="#前缀表达式">#</a> 前缀表达式</h3>
<ul>
<li>前缀表达式又称为波兰式</li>
<li>前缀表达式的运算符位于操作数之前</li>
</ul>
<p>例如：(3+4)*5-6   对应的前缀表达式是：- * + 3 4 5 6</p>
<h4 id="前缀表达式的计算机求值"><a class="markdownIt-Anchor" href="#前缀表达式的计算机求值">#</a> 前缀表达式的计算机求值</h4>
<p>从右至左扫描表达式，遇到数字时，将数字压入堆栈，遇到运算符时，弹出栈顶的两个数，用运算符对它们做相应的计算（栈顶元素 和 次顶元素），并将结果入栈；重复上述过程直到表达式最左端，最后运算得出的值即为表达式的结果</p>
<p>例如: (3+4)×5-6 对应的前缀表达式就是 <strong>- × + 3 4 5 6 ,</strong> <strong>针对前缀表达式求值步骤如下:</strong></p>
<p>1) 从<strong>右至左扫描</strong>，将 6、5、4、3 压入堆栈</p>
<p>2) 遇到 + 运算符，因此弹出 3 和 4（3 为栈顶元素，4 为次顶元素），计算出 3+4 的值，得 7，再将 7 入栈</p>
<p>3) 接下来是 × 运算符，因此弹出 7 和 5，计算出 7×5=35，将 35 入栈</p>
<p>最后是 - 运算符，计算出 35-6 的值，即 29，由此得出最终结果</p>
<h3 id="中缀表达式"><a class="markdownIt-Anchor" href="#中缀表达式">#</a> 中缀表达式</h3>
<p>1) 中缀表达式就是<strong>常见的运算表达式</strong>，如 (3+4)×5-6</p>
<p>2) 中缀表达式的求值是我们人最熟悉的，但是对计算机来说却不好操作，因此，在计算结果时，往往会将中缀表达式转成其它表达式来操作 (一般转成后缀表达式.)</p>
<h3 id="后缀表达式"><a class="markdownIt-Anchor" href="#后缀表达式">#</a> 后缀表达式</h3>
<p>1) 后缀表达式又称<strong>逆波兰表达式</strong>，与前缀表达式相似，只是运算符位于操作数之后</p>
<p>2) 中举例说明： (3+4)×5-6 对应的后缀表达式就是 <strong>3 4 + 5 × 6 –</strong></p>
<p>例如：</p>
<p><a href="https://imgtu.com/i/R7E8qH"><img src="https://z3.ax1x.com/2021/07/06/R7E8qH.png" alt="R7E8qH.png"></a></p>
<h4 id="后缀表达式的计算机求值"><a class="markdownIt-Anchor" href="#后缀表达式的计算机求值">#</a> 后缀表达式的计算机求值</h4>
<p><strong>从左至右</strong>扫描表达式，遇到数字时，将数字压入堆栈，遇到运算符时，弹出栈顶的两个数，用运算符对它们做相应的计算（次顶元素 和 栈顶元素），并将结果入栈；重复上述过程直到表达式最右端，最后运算得出的值即为表达式的结果</p>
<p>例如: (3+4)×5-6 对应的后缀表达式就是 <strong>3 4 + 5 × 6 - ,</strong> <strong>针对后缀表达式求值步骤如下:</strong></p>
<p>1) 从左至右扫描，将 3 和 4 压入堆栈；</p>
<p>2) 遇到 + 运算符，因此弹出 4 和 3（4 为栈顶元素，3 为次顶元素），计算出 3+4 的值，得 7，再将 7 入栈；</p>
<p>3) 将 5 入栈；</p>
<p>4) 接下来是 × 运算符，因此弹出 5 和 7，计算出 7×5=35，将 35 入栈；</p>
<p>5) 将 6 入栈；</p>
<p>最后是 - 运算符，计算出 35-6 的值，即 29，由此得出最终结果</p>
<p><strong>我们完成一个逆波兰计算器，要求完成如下任务</strong>:</p>
<p>1)<strong> 输入一个逆波兰表达式</strong> (后缀表达式)<strong>，使用栈</strong> (Stack), <strong>计算其结果</strong></p>
<p>2)<strong> 支持小括号和多位数整数，因为这里我们主要讲的是数据结构，因此计算器进行简化，只支持对整数的计算。</strong></p>
<h4 id="代码实现-2"><a class="markdownIt-Anchor" href="#代码实现-2">#</a> 代码实现</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> demo3;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PolandNotation</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//先定义给逆波兰表达式</span></span><br><span class="line">        <span class="comment">//(30+4)*5-6 =&gt; 3 4 + 5 * 6 -</span></span><br><span class="line">        <span class="comment">//说明为了方便，逆波兰表达式的数字和符号使用空格隔开</span></span><br><span class="line">        String suffixExpression = <span class="string">&quot;30 4 + 5 * 6 -&quot;</span>;</span><br><span class="line">        <span class="comment">//思路</span></span><br><span class="line">        <span class="comment">//1.先将&quot;3 4 + 5 * 6 -&quot; =&gt; 放到ArrayList中</span></span><br><span class="line">        <span class="comment">//2.将ArrayList传递给一个方法，遍历ArrayList 配合栈完成计算</span></span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; list = getListString(suffixExpression);</span><br><span class="line">        System.out.println(<span class="string">&quot;list：&quot;</span>+list);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> res=calculate(list);</span><br><span class="line">        System.out.println(<span class="string">&quot;计算的结果是:&quot;</span>+res);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将一个逆波兰表达式，依次将数据和运算符放入到ArrayList中</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">getListString</span><span class="params">(String suffixExpression)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//将suffixExpression分割</span></span><br><span class="line">        String[] split = suffixExpression.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String ele : split) &#123;</span><br><span class="line">            list.add(ele);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//完成对逆波兰表达式的运算</span></span><br><span class="line">    <span class="comment">/*  (3+4)×5-6 对应的后缀表达式就是 3 4 + 5 × 6 - , 针对后缀表达式求值步骤如下:</span></span><br><span class="line"><span class="comment">        1.从左至右扫描，将3和4压入堆栈；</span></span><br><span class="line"><span class="comment">        2.遇到+运算符，因此弹出4和3（4为栈顶元素，3为次顶元素），计算出3+4的值，得7，再将7入栈；</span></span><br><span class="line"><span class="comment">        3.将5入栈；</span></span><br><span class="line"><span class="comment">        4.接下来是×运算符，因此弹出5和7，计算出7×5=35，将35入栈；</span></span><br><span class="line"><span class="comment">        5.将6入栈；</span></span><br><span class="line"><span class="comment">        6.最后是-运算符，计算出35-6的值，即29，由此得出最终结果</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">calculate</span><span class="params">(List&lt;String&gt; ls)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建给栈，只需一个栈即可</span></span><br><span class="line">        Stack&lt;String&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="comment">//遍历 ls</span></span><br><span class="line">        <span class="keyword">for</span> (String item : ls) &#123;</span><br><span class="line">            <span class="comment">//这里使用正则表达式来取出数</span></span><br><span class="line">            <span class="keyword">if</span> (item.matches(<span class="string">&quot;\\d+&quot;</span>)) &#123;<span class="comment">//匹配的是多位数</span></span><br><span class="line">                <span class="comment">//入栈</span></span><br><span class="line">                stack.push(item);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//pop出两个数，并运算，再入栈</span></span><br><span class="line">                <span class="keyword">int</span> num2 = Integer.parseInt(stack.pop());</span><br><span class="line">                <span class="keyword">int</span> num1 = Integer.parseInt(stack.pop());</span><br><span class="line">                <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (item.equals(<span class="string">&quot;+&quot;</span>)) &#123;</span><br><span class="line">                    res = num1 + num2;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (item.equals(<span class="string">&quot;-&quot;</span>)) &#123;</span><br><span class="line">                    res = num1 - num2;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (item.equals(<span class="string">&quot;*&quot;</span>)) &#123;</span><br><span class="line">                    res = num1 * num2;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (item.equals(<span class="string">&quot;/&quot;</span>)) &#123;</span><br><span class="line">                    res = num1 / num2;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span>  RuntimeException(<span class="string">&quot;运算符有误&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//把res 入栈</span></span><br><span class="line">                stack.push(res+<span class="string">&quot;&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//最后留在stack中的数便是运算结果</span></span><br><span class="line">        <span class="keyword">return</span> Integer.parseInt(stack.pop());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="中缀表达式转为后缀表达式"><a class="markdownIt-Anchor" href="#中缀表达式转为后缀表达式">#</a> 中缀表达式转为后缀表达式</h3>
<h4 id="思路分析"><a class="markdownIt-Anchor" href="#思路分析">#</a> 思路分析</h4>
<p><a href="https://imgtu.com/i/R7EDsg"><img src="https://z3.ax1x.com/2021/07/06/R7EDsg.png" alt="R7EDsg.png"></a></p>
<h4 id="代码实现-3"><a class="markdownIt-Anchor" href="#代码实现-3">#</a> 代码实现</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> demo04;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PolandNotation</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//完成将一个中缀表达式转成后缀表达式的功能</span></span><br><span class="line">        <span class="comment">//说明</span></span><br><span class="line">        <span class="comment">//1. 1+((2+3)*4)-5 =&gt; 转成1 2 3 + 4 * + 5 -</span></span><br><span class="line">        <span class="comment">//2. 因为直接对str进行操作，不方便，因此先将 &quot;1+((2+3)*4)-5&quot; =》中缀表达式对应的List</span></span><br><span class="line">        <span class="comment">//   即1+((2+3)*4)-5 =&gt; ArrayList[1,+,(,(,2,+,3,),*,4,),-,5]</span></span><br><span class="line">        <span class="comment">//3. 将得到的中缀表达式对应的List =&gt; 后缀表达式对应的List</span></span><br><span class="line">        <span class="comment">//  即 ArrayList[1,+,(,(,2,+,3,),*,4,),-,5]  =&gt; ArrayList[1,2,3,+,4,*,+,5,-]</span></span><br><span class="line"></span><br><span class="line">        String expression =<span class="string">&quot;1+((2+3)*4)-5&quot;</span>;</span><br><span class="line">        List&lt;String&gt; infixExpressionList = toInfixExpressionList(expression);</span><br><span class="line">        System.out.println(infixExpressionList); <span class="comment">//[1, +, (, (, 2, +, 3, ), *, 4, ), -, 5]</span></span><br><span class="line">        List&lt;String&gt; parseSuffixExpressionList = parseSuffixExpressionList(infixExpressionList);</span><br><span class="line">        System.out.println(parseSuffixExpressionList);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;++++++++++++++++++++++++++++++&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> calculate = calculate(parseSuffixExpressionList);</span><br><span class="line">        System.out.println(calculate);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        //先定义给逆波兰表达式</span></span><br><span class="line"><span class="comment">        //(30+4)*5-6 =&gt; 30 4 + 5 * 6 -</span></span><br><span class="line"><span class="comment">        //说明为了方便，逆波兰表达式的数字和符号使用空格隔开</span></span><br><span class="line"><span class="comment">        String suffixExpression = &quot;30 4 + 5 * 6 -&quot;;</span></span><br><span class="line"><span class="comment">        //思路</span></span><br><span class="line"><span class="comment">        //1.先将&quot;3 4 + 5 * 6 -&quot; =&gt; 放到ArrayList中</span></span><br><span class="line"><span class="comment">        //2.将ArrayList传递给一个方法，遍历ArrayList 配合栈完成计算</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        List&lt;String&gt; list = getListString(suffixExpression);</span></span><br><span class="line"><span class="comment">        System.out.println(&quot;list：&quot;+list);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        int res=calculate(list);</span></span><br><span class="line"><span class="comment">        System.out.println(&quot;计算的结果是:&quot;+res);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//将得到的中缀表达式对应的List =&gt; 后缀表达式对应的List</span></span><br><span class="line">    <span class="comment">//  即 ArrayList[1,+,(,(,2,+,3,),*,4,),-,5]  =&gt; ArrayList[1,2,3,+,4,*,+,5,-]</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">parseSuffixExpressionList</span><span class="params">(List&lt;String&gt; ls)</span></span>&#123;</span><br><span class="line">        <span class="comment">//定义两个栈</span></span><br><span class="line">        Stack&lt;String&gt; s1=<span class="keyword">new</span> Stack&lt;&gt;();<span class="comment">//符号栈</span></span><br><span class="line">        <span class="comment">//因为s2这个栈，在整个转换过程中，没有pop操作，而且后面还需要逆序输出</span></span><br><span class="line">        <span class="comment">//因此比较麻烦，所以就不用Stack&lt;String&gt; 直接使用List&lt;String&gt; s2</span></span><br><span class="line">        <span class="comment">//Stack&lt;String&gt; s2=new Stack&lt;&gt;();//存放中间结果的栈</span></span><br><span class="line">        List&lt;String&gt; s2= <span class="keyword">new</span> ArrayList&lt;&gt;();<span class="comment">//存放中间结果的List</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历ls</span></span><br><span class="line">        <span class="keyword">for</span>(String item:ls)&#123;</span><br><span class="line">            <span class="comment">//如果是一个数，就入s2</span></span><br><span class="line">            <span class="keyword">if</span>(item.matches(<span class="string">&quot;\\d+&quot;</span>))&#123;</span><br><span class="line">                s2.add(item);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(item.equals(<span class="string">&quot;(&quot;</span>))&#123;</span><br><span class="line">                s1.push(item);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(item.equals(<span class="string">&quot;)&quot;</span>))&#123;</span><br><span class="line">                <span class="comment">//) 如果是右括号“)”，则依次弹出s1栈顶的运算符，并压入s2，直到遇到左括号为止，此时将这一对括号丢弃</span></span><br><span class="line">                <span class="keyword">while</span> (!s1.peek().equals(<span class="string">&quot;(&quot;</span>))&#123;</span><br><span class="line">                    s2.add(s1.pop());</span><br><span class="line">                &#125;</span><br><span class="line">                s1.pop();<span class="comment">//!!!!将 &quot;(&quot; 弹出s1栈，消除小括号</span></span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//当item的优先级小于等于s1栈顶的运算符，将s1栈顶的运算符弹出并加入到s2中，再次转到（4.1）与s1中新的栈顶运算符相比较</span></span><br><span class="line">                <span class="comment">//缺少一个比较运算符优先级高低的方法</span></span><br><span class="line">                <span class="keyword">while</span> (s1.size()!=<span class="number">0</span> &amp;&amp; Operation.getValue(s1.peek())&gt;=Operation.getValue(item))&#123;</span><br><span class="line">                    s2.add(s1.pop());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//最后需要将item压入栈中</span></span><br><span class="line">                s1.push(item);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将s1中剩余的运算符依次弹出并加入s2</span></span><br><span class="line">        <span class="keyword">while</span> (s1.size()!=<span class="number">0</span>)&#123;</span><br><span class="line">            s2.add(s1.pop());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s2;<span class="comment">//注意因为是存放到List，因此按循序输出就是后缀表达式对应的list</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//将中缀表达式转换成对应的list</span></span><br><span class="line">    <span class="comment">//   即1+((2+3)*4)-5 =&gt; ArrayList[1,+,(,(,2,+,3,),*,4,),-,5]</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">toInfixExpressionList</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">        <span class="comment">//定义一个list，存放中缀表达式对应的内容</span></span><br><span class="line">        List&lt;String&gt; ls=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;<span class="comment">//这是一个指针，用于遍历 中缀表达式字符串</span></span><br><span class="line">        String str;<span class="comment">//对多位数的拼接</span></span><br><span class="line">        <span class="keyword">char</span> c;<span class="comment">//每遍历一个字符，就放入c</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="comment">//如果 c 是一个非数字，需要加入到ls</span></span><br><span class="line">            <span class="keyword">if</span>((c=s.charAt(i))&lt;<span class="number">48</span>||(c=s.charAt(i))&gt;<span class="number">57</span>)&#123;</span><br><span class="line">                ls.add(<span class="string">&quot;&quot;</span>+c);</span><br><span class="line">                i++;<span class="comment">//i需要后移</span></span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//如果是一个数，需要考虑多位数问题</span></span><br><span class="line">                str=<span class="string">&quot;&quot;</span>;<span class="comment">//先将str 置成 &quot;&quot; &#x27;0&#x27;[48] -&gt; &#x27;9&#x27;[57]</span></span><br><span class="line">                <span class="keyword">while</span> (i&lt;s.length() &amp;&amp; (c=s.charAt(i))&gt;=<span class="number">48</span> &amp;&amp; (c=s.charAt(i))&lt;=<span class="number">57</span>)&#123;</span><br><span class="line">                    str+=c;<span class="comment">//拼接</span></span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">                ls.add(str);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">while</span> (i&lt;s.length());</span><br><span class="line">        <span class="keyword">return</span> ls;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将一个逆波兰表达式，依次将数据和运算符放入到ArrayList中</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">getListString</span><span class="params">(String suffixExpression)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//将suffixExpression分割</span></span><br><span class="line">        String[] split = suffixExpression.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String ele : split) &#123;</span><br><span class="line">            list.add(ele);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//完成对逆波兰表达式的运算</span></span><br><span class="line">    <span class="comment">/*  (3+4)×5-6 对应的后缀表达式就是 3 4 + 5 × 6 - , 针对后缀表达式求值步骤如下:</span></span><br><span class="line"><span class="comment">        1.从左至右扫描，将3和4压入堆栈；</span></span><br><span class="line"><span class="comment">        2.遇到+运算符，因此弹出4和3（4为栈顶元素，3为次顶元素），计算出3+4的值，得7，再将7入栈；</span></span><br><span class="line"><span class="comment">        3.将5入栈；</span></span><br><span class="line"><span class="comment">        4.接下来是×运算符，因此弹出5和7，计算出7×5=35，将35入栈；</span></span><br><span class="line"><span class="comment">        5.将6入栈；</span></span><br><span class="line"><span class="comment">        6.最后是-运算符，计算出35-6的值，即29，由此得出最终结果</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">calculate</span><span class="params">(List&lt;String&gt; ls)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建给栈，只需一个栈即可</span></span><br><span class="line">        Stack&lt;String&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="comment">//遍历 ls</span></span><br><span class="line">        <span class="keyword">for</span> (String item : ls) &#123;</span><br><span class="line">            <span class="comment">//这里使用正则表达式来取出数</span></span><br><span class="line">            <span class="keyword">if</span> (item.matches(<span class="string">&quot;\\d+&quot;</span>)) &#123;<span class="comment">//匹配的是多位数</span></span><br><span class="line">                <span class="comment">//入栈</span></span><br><span class="line">                stack.push(item);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//pop出两个数，并运算，再入栈</span></span><br><span class="line">                <span class="keyword">int</span> num2 = Integer.parseInt(stack.pop());</span><br><span class="line">                <span class="keyword">int</span> num1 = Integer.parseInt(stack.pop());</span><br><span class="line">                <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (item.equals(<span class="string">&quot;+&quot;</span>)) &#123;</span><br><span class="line">                    res = num1 + num2;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (item.equals(<span class="string">&quot;-&quot;</span>)) &#123;</span><br><span class="line">                    res = num1 - num2;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (item.equals(<span class="string">&quot;*&quot;</span>)) &#123;</span><br><span class="line">                    res = num1 * num2;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (item.equals(<span class="string">&quot;/&quot;</span>)) &#123;</span><br><span class="line">                    res = num1 / num2;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span>  RuntimeException(<span class="string">&quot;运算符有误&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//把res 入栈</span></span><br><span class="line">                stack.push(res+<span class="string">&quot;&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//最后留在stack中的数便是运算结果</span></span><br><span class="line">        <span class="keyword">return</span> Integer.parseInt(stack.pop());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//编写一个类Operation 可以返回一个运算符，对应的优先级</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Operation</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> ADD = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> SUB = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> MUL = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> DIV = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//写一个方法，返回对应的优先级数字</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getValue</span><span class="params">(String operation)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result =<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">switch</span> (operation)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;+&quot;</span>:</span><br><span class="line">                result=ADD;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;-&quot;</span>:</span><br><span class="line">                result=SUB;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;*&quot;</span>:</span><br><span class="line">                result=MUL;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;/&quot;</span>:</span><br><span class="line">                result=DIV;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;不存在该运算符&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="完整代码实现包含小数点"><a class="markdownIt-Anchor" href="#完整代码实现包含小数点">#</a> 完整代码实现，包含小数点</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.reversepolishcal;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"><span class="keyword">import</span> java.util.regex.Pattern;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReversePolishMultiCalc</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	 <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 匹配 + - * / ( ) 运算符</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String SYMBOL = <span class="string">&quot;\\+|-|\\*|/|\\(|\\)&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String LEFT = <span class="string">&quot;(&quot;</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String RIGHT = <span class="string">&quot;)&quot;</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String ADD = <span class="string">&quot;+&quot;</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String MINUS= <span class="string">&quot;-&quot;</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String TIMES = <span class="string">&quot;*&quot;</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String DIVISION = <span class="string">&quot;/&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 加減 + -</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> LEVEL_01 = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 乘除 * /</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> LEVEL_02 = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 括号</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> LEVEL_HIGH = Integer.MAX_VALUE;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> Stack&lt;String&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="keyword">static</span> List&lt;String&gt; data = Collections.synchronizedList(<span class="keyword">new</span> ArrayList&lt;String&gt;());</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 去除所有空白符</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">replaceAllBlank</span><span class="params">(String s )</span></span>&#123;</span><br><span class="line">        <span class="comment">// \\s+ 匹配任何空白字符，包括空格、制表符、换页符等等, 等价于[ \f\n\r\t\v]</span></span><br><span class="line">        <span class="keyword">return</span> s.replaceAll(<span class="string">&quot;\\s+&quot;</span>,<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断是不是数字 int double long float</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isNumber</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">        Pattern pattern = Pattern.compile(<span class="string">&quot;^[-\\+]?[.\\d]*$&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> pattern.matcher(s).matches();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断是不是运算符</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isSymbol</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s.matches(SYMBOL);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 匹配运算等级</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">calcLevel</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">&quot;+&quot;</span>.equals(s) || <span class="string">&quot;-&quot;</span>.equals(s))&#123;</span><br><span class="line">            <span class="keyword">return</span> LEVEL_01;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">&quot;*&quot;</span>.equals(s) || <span class="string">&quot;/&quot;</span>.equals(s))&#123;</span><br><span class="line">            <span class="keyword">return</span> LEVEL_02;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> LEVEL_HIGH;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 匹配</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">doMatch</span> <span class="params">(String s)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s == <span class="keyword">null</span> || <span class="string">&quot;&quot;</span>.equals(s.trim())) <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;data is empty&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(!isNumber(s.charAt(<span class="number">0</span>)+<span class="string">&quot;&quot;</span>)) <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;data illeagle,start not with a number&quot;</span>);</span><br><span class="line"></span><br><span class="line">        s = replaceAllBlank(s);</span><br><span class="line"></span><br><span class="line">        String each;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(isSymbol(s.charAt(i)+<span class="string">&quot;&quot;</span>))&#123;</span><br><span class="line">                each = s.charAt(i)+<span class="string">&quot;&quot;</span>;</span><br><span class="line">                <span class="comment">//栈为空，(操作符，或者 操作符优先级大于栈顶优先级 &amp;&amp; 操作符优先级不是( )的优先级 及是 ) 不能直接入栈</span></span><br><span class="line">                <span class="keyword">if</span>(stack.isEmpty() || LEFT.equals(each)</span><br><span class="line">                        || ((calcLevel(each) &gt; calcLevel(stack.peek())) &amp;&amp; calcLevel(each) &lt; LEVEL_HIGH))&#123;</span><br><span class="line">                    stack.push(each);</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>( !stack.isEmpty() &amp;&amp; calcLevel(each) &lt;= calcLevel(stack.peek()))&#123;</span><br><span class="line">                    <span class="comment">//栈非空，操作符优先级小于等于栈顶优先级时出栈入列，直到栈为空，或者遇到了(，最后操作符入栈</span></span><br><span class="line">                    <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; calcLevel(each) &lt;= calcLevel(stack.peek()) )&#123;</span><br><span class="line">                        <span class="keyword">if</span>(calcLevel(stack.peek()) == LEVEL_HIGH)&#123;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        data.add(stack.pop());</span><br><span class="line">                    &#125;</span><br><span class="line">                    stack.push(each);</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(RIGHT.equals(each))&#123;</span><br><span class="line">                    <span class="comment">// ) 操作符，依次出栈入列直到空栈或者遇到了第一个)操作符，此时)出栈</span></span><br><span class="line">                    <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; LEVEL_HIGH &gt;= calcLevel(stack.peek()))&#123;</span><br><span class="line">                        <span class="keyword">if</span>(LEVEL_HIGH == calcLevel(stack.peek()))&#123;</span><br><span class="line">                            stack.pop();</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        data.add(stack.pop());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                start = i ;    <span class="comment">//前一个运算符的位置</span></span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>( i == s.length()-<span class="number">1</span> || isSymbol(s.charAt(i+<span class="number">1</span>)+<span class="string">&quot;&quot;</span>) )&#123;</span><br><span class="line">                each = start == <span class="number">0</span> ? s.substring(start,i+<span class="number">1</span>) : s.substring(start+<span class="number">1</span>,i+<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span>(isNumber(each)) &#123;</span><br><span class="line">                    data.add(each);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;data not match number&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果栈里还有元素，此时元素需要依次出栈入列，可以想象栈里剩下栈顶为/，栈底为+，应该依次出栈入列，可以直接翻转整个stack 添加到队列</span></span><br><span class="line">        Collections.reverse(stack);</span><br><span class="line">        data.addAll(<span class="keyword">new</span> ArrayList&lt;&gt;(stack));</span><br><span class="line"></span><br><span class="line">        System.out.println(data);</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 算出结果</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> list</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Double <span class="title">doCalc</span><span class="params">(List&lt;String&gt; list)</span></span>&#123;</span><br><span class="line">        Double d = <span class="number">0d</span>;</span><br><span class="line">        <span class="keyword">if</span>(list == <span class="keyword">null</span> || list.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (list.size() == <span class="number">1</span>)&#123;</span><br><span class="line">            System.out.println(list);</span><br><span class="line">            d = Double.valueOf(list.get(<span class="number">0</span>));</span><br><span class="line">            <span class="keyword">return</span> d;</span><br><span class="line">        &#125;</span><br><span class="line">        ArrayList&lt;String&gt; list1 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">            list1.add(list.get(i));</span><br><span class="line">            <span class="keyword">if</span>(isSymbol(list.get(i)))&#123;</span><br><span class="line">                Double d1 = doTheMath(list.get(i - <span class="number">2</span>), list.get(i - <span class="number">1</span>), list.get(i));</span><br><span class="line">                list1.remove(i);</span><br><span class="line">                list1.remove(i-<span class="number">1</span>);</span><br><span class="line">                list1.set(i-<span class="number">2</span>,d1+<span class="string">&quot;&quot;</span>);</span><br><span class="line">                list1.addAll(list.subList(i+<span class="number">1</span>,list.size()));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        doCalc(list1);</span><br><span class="line">        <span class="keyword">return</span> d;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 运算</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s1</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s2</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> symbol</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Double <span class="title">doTheMath</span><span class="params">(String s1,String s2,String symbol)</span></span>&#123;</span><br><span class="line">        Double result ;</span><br><span class="line">        <span class="keyword">switch</span> (symbol)&#123;</span><br><span class="line">            <span class="keyword">case</span> ADD : result = Double.valueOf(s1) + Double.valueOf(s2); <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> MINUS : result = Double.valueOf(s1) - Double.valueOf(s2); <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> TIMES : result = Double.valueOf(s1) * Double.valueOf(s2); <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> DIVISION : result = Double.valueOf(s1) / Double.valueOf(s2); <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span> : result = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//String math = &quot;9+(3-1)*3+10/2&quot;;</span></span><br><span class="line">        String math = <span class="string">&quot;12.8 + (2 - 3.55)*4+10/5.0&quot;</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            doCalc(doMatch(math));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>05.栈</category>
      </categories>
      <tags>
        <tag>算法与数据结构</tag>
        <tag>栈</tag>
        <tag>(后缀表达式)逆波兰表达式</tag>
      </tags>
  </entry>
  <entry>
    <title>排序算法</title>
    <url>/2021/07/07/07.%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h2 id="排序算法"><a class="markdownIt-Anchor" href="#排序算法">#</a> 排序算法</h2>
<h3 id="概念"><a class="markdownIt-Anchor" href="#概念">#</a> 概念</h3>
<p>排序也称排序算法 (Sort Algorithm)，排序是将一组数据，依指定的顺序进行排列的过程。</p>
<h3 id="排序的分类"><a class="markdownIt-Anchor" href="#排序的分类">#</a> 排序的分类</h3>
<h4 id="内部排序"><a class="markdownIt-Anchor" href="#内部排序">#</a> 内部排序</h4>
<p>指将需要处理的所有数据都加载到 ** 内部存储器 (内存)** 中进行排序。</p>
<h4 id="外部排序法"><a class="markdownIt-Anchor" href="#外部排序法">#</a> 外部排序法</h4>
<p>数据量过大，无法全部加载到内存中，需要借助 ** 外部存储 (文件等)** 进行排序。</p>
<p><a href="https://imgtu.com/i/R7VESf"><img src="https://z3.ax1x.com/2021/07/06/R7VESf.png" alt="R7VESf.png"></a></p>
<h3 id="算法的时间复杂度"><a class="markdownIt-Anchor" href="#算法的时间复杂度">#</a> 算法的时间复杂度</h3>
<h4 id="度量一个程序算法执行时间的两种方法"><a class="markdownIt-Anchor" href="#度量一个程序算法执行时间的两种方法">#</a> 度量一个程序 (算法) 执行时间的两种方法</h4>
<ol>
<li>
<p>事后统计的方法</p>
<ul>
<li>这种方法可行，但是有两个问题 ：</li>
<li>一是要想对设计的算法的运行性能进行评测，需要实际运行该程序；</li>
<li>二是所得时间的统计量依赖于计算机的硬件、软件等环境因素，<strong>这种方式，要在同一台计算机的相同状态下运行，才能比较那个算法速度更快</strong>。</li>
</ul>
</li>
<li>
<p>事前估算的方法</p>
<ul>
<li>通过分析某个算法的<strong>时间复杂度</strong>来判断哪个算法更优.</li>
</ul>
</li>
</ol>
<h4 id="时间频度"><a class="markdownIt-Anchor" href="#时间频度">#</a> 时间频度</h4>
<p>一个算法花费的时间与算法中语句的执行次数成正比例，哪个算法中语句执行次数多，它花费时间就多。<strong>一个算法中的语句执行次数称为语句频度或时间频度</strong>。记为 T (n)。</p>
<h5 id="1忽略常数项"><a class="markdownIt-Anchor" href="#1忽略常数项">#</a> &lt;1&gt; 忽略常数项</h5>
<p><a href="https://imgtu.com/i/R7Vuwj"><img src="https://z3.ax1x.com/2021/07/06/R7Vuwj.png" alt="R7Vuwj.png"></a></p>
<h5 id="2忽略低次项"><a class="markdownIt-Anchor" href="#2忽略低次项">#</a> &lt;2&gt; 忽略低次项</h5>
<p><a href="https://imgtu.com/i/R7VQkn"><img src="https://z3.ax1x.com/2021/07/06/R7VQkn.png" alt="R7VQkn.png"></a></p>
<h5 id="3忽略系数"><a class="markdownIt-Anchor" href="#3忽略系数">#</a> &lt;3&gt; 忽略系数</h5>
<p><a href="https://imgtu.com/i/R7VlYq"><img src="https://z3.ax1x.com/2021/07/06/R7VlYq.png" alt="R7VlYq.png"></a></p>
<h3 id="时间复杂度"><a class="markdownIt-Anchor" href="#时间复杂度">#</a> 时间复杂度</h3>
<h4 id="概念-2"><a class="markdownIt-Anchor" href="#概念-2">#</a> 概念</h4>
<ol>
<li>
<p>一般情况下，算法中的基本操作语句的重复执行次数是问题规模 n 的某个函数，用 T (n) 表示，若有某个辅助函数 f (n)，使得当 n 趋近于无穷大时，T (n) /f (n) 的极限值为不等于零的常数，则称 f (n) 是 T (n) 的同数量级函数。记作 T (n)=Ｏ( f (n) )，称Ｏ( f (n) ) 为算法的渐进时间复杂度，简称时间复杂度。</p>
</li>
<li>
<p>T (n) 不同，但时间复杂度可能相同。 如：T (n)=n²+7n+6 与 T (n)=3n²+2n+2 它们的 T (n) 不同，但时间复杂度相同，都为 O (n²)。</p>
</li>
</ol>
<h4 id="计算时间复杂度的方法"><a class="markdownIt-Anchor" href="#计算时间复杂度的方法">#</a> 计算时间复杂度的方法：</h4>
<ol>
<li>
<p>用常数 1 代替运行时间中的所有加法常数 T (n)=n²+7n+6 =&gt; T (n)=n²+7n+1</p>
</li>
<li>
<p>修改后的运行次数函数中，只保留最高阶项 T (n)=n²+7n+1 =&gt; T (n) = n²</p>
</li>
<li>
<p>去除最高阶项的系数 T (n) = n² =&gt;  T (n) = n² =&gt; O (n²)</p>
</li>
</ol>
<h4 id="常见的时间复杂度"><a class="markdownIt-Anchor" href="#常见的时间复杂度">#</a> 常见的时间复杂度</h4>
<p><a href="https://imgtu.com/i/R7VGlT"><img src="https://z3.ax1x.com/2021/07/06/R7VGlT.png" alt="R7VGlT.png"></a></p>
<h4 id="平均时间复杂度和最坏时间复杂度"><a class="markdownIt-Anchor" href="#平均时间复杂度和最坏时间复杂度">#</a> 平均时间复杂度和最坏时间复杂度</h4>
<ol>
<li>
<p>平均时间复杂度是指所有可能的输入实例均以等概率出现的情况下，该算法的运行时间。</p>
</li>
<li>
<p>最坏情况下的时间复杂度称最坏时间复杂度。一般讨论的时间复杂度均是最坏情况下的时间复杂度。 这样做的原因是：最坏情况下的时间复杂度是算法在任何输入实例上运行时间的界限，这就保证了算法的运行时间不会比最坏情况更长。</p>
</li>
<li>
<p>平均时间复杂度和最坏时间复杂度是否一致，和算法有关</p>
</li>
</ol>
<p><a href="https://imgtu.com/i/R7Vgne"><img src="https://z3.ax1x.com/2021/07/06/R7Vgne.png" alt="R7Vgne.png"></a></p>
<h3 id="空间复杂度"><a class="markdownIt-Anchor" href="#空间复杂度">#</a> 空间复杂度</h3>
<h4 id="简单介绍"><a class="markdownIt-Anchor" href="#简单介绍">#</a> 简单介绍</h4>
<ul>
<li>类似于时间复杂度的讨论，一个算法的空间复杂度 (Space Complexity) 定义为该算法所耗费的存储空间，它也是问题规模 n 的函数。</li>
<li>空间复杂度 (Space Complexity) 是对一个算法在运行过程中临时占用存储空间大小的量度。有的算法需要占用的临时工作单元数与解决问题的规模 n 有关，它随着 n 的增大而增大，当 n 较大时，将占用较多的存储单元，例如快速排序和归并排序算法就属于这种情况</li>
<li>在做算法分析时，<strong>主要讨论的是时间复杂度</strong>。从用户使用体验上看，更看重的程序执行的速度。一些缓存产品 (redis, memcache) 和算法 (基数排序) 本质就是<strong>用空间换时间</strong>.</li>
</ul>
<h1 id="八种基本排序算法"><a class="markdownIt-Anchor" href="#八种基本排序算法">#</a> 八种基本排序算法</h1>
<h2 id="1-冒泡排序"><a class="markdownIt-Anchor" href="#1-冒泡排序">#</a> 1、冒泡排序</h2>
<h3 id="思路分析"><a class="markdownIt-Anchor" href="#思路分析">#</a> 思路分析</h3>
<p><a href="https://imgtu.com/i/R7VfAA"><img src="https://z3.ax1x.com/2021/07/06/R7VfAA.png" alt="R7VfAA.png"></a></p>
<h3 id="代码实现"><a class="markdownIt-Anchor" href="#代码实现">#</a> 代码实现</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> demo1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BubbleSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//int[] arr = &#123;3, 9, -1, 10, 9&#125;;</span></span><br><span class="line">        <span class="comment">//System.out.println(&quot;排序前&quot;);</span></span><br><span class="line">        <span class="comment">//System.out.println(Arrays.toString(arr));</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] arr=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">80000</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">80000</span>; i++) &#123;</span><br><span class="line">            arr[i]=(<span class="keyword">int</span>)(Math.random() * <span class="number">80000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Date date=<span class="keyword">new</span> Date();</span><br><span class="line">        SimpleDateFormat simpleDateFormat = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">        String format = simpleDateFormat.format(date);</span><br><span class="line">        System.out.println(<span class="string">&quot;排序前时间：&quot;</span>+format);</span><br><span class="line"></span><br><span class="line">        bubbleSort(arr);</span><br><span class="line">        Date date1=<span class="keyword">new</span> Date();</span><br><span class="line">        String format1 = simpleDateFormat.format(date1);</span><br><span class="line">        System.out.println(<span class="string">&quot;排序后时间：&quot;</span>+format1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//System.out.println(&quot;排序后&quot;);</span></span><br><span class="line">        <span class="comment">//System.out.println(Arrays.toString(arr));</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        //为了容易理解，我们把冒泡排序的演变过程，展示出来</span></span><br><span class="line"><span class="comment">        //第一趟排序，就是将最大的数排在最后</span></span><br><span class="line"><span class="comment">        int temp=0;//临时变量</span></span><br><span class="line"><span class="comment">        for (int i = 0; i &lt; arr.length-1; i++) &#123;</span></span><br><span class="line"><span class="comment">            //如果前面的数比后面的数大，则交换</span></span><br><span class="line"><span class="comment">            if(arr[i]&gt;arr[i+1])&#123;</span></span><br><span class="line"><span class="comment">                temp=arr[i];</span></span><br><span class="line"><span class="comment">                arr[i]=arr[i+1];</span></span><br><span class="line"><span class="comment">                arr[i+1]=temp;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        System.out.println(&quot;第一次排序后的数组&quot;);</span></span><br><span class="line"><span class="comment">        System.out.println(Arrays.toString(arr));</span></span><br><span class="line"><span class="comment">        //第二趟排序，就是将第二大的数排在倒数第二位</span></span><br><span class="line"><span class="comment">        for (int i = 0; i &lt; arr.length-2; i++) &#123;</span></span><br><span class="line"><span class="comment">            //如果前面的数比后面的数大，则交换</span></span><br><span class="line"><span class="comment">            if(arr[i]&gt;arr[i+1])&#123;</span></span><br><span class="line"><span class="comment">                temp=arr[i];</span></span><br><span class="line"><span class="comment">                arr[i]=arr[i+1];</span></span><br><span class="line"><span class="comment">                arr[i+1]=temp;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        System.out.println(&quot;第二次排序后的数组&quot;);</span></span><br><span class="line"><span class="comment">        System.out.println(Arrays.toString(arr));</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        //第三趟排序，就是将第三大的数排在倒数第三位</span></span><br><span class="line"><span class="comment">        for (int i = 0; i &lt; arr.length-3; i++) &#123;</span></span><br><span class="line"><span class="comment">            //如果前面的数比后面的数大，则交换</span></span><br><span class="line"><span class="comment">            if(arr[i]&gt;arr[i+1])&#123;</span></span><br><span class="line"><span class="comment">                temp=arr[i];</span></span><br><span class="line"><span class="comment">                arr[i]=arr[i+1];</span></span><br><span class="line"><span class="comment">                arr[i+1]=temp;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        System.out.println(&quot;第三次排序后的数组&quot;);</span></span><br><span class="line"><span class="comment">        System.out.println(Arrays.toString(arr));</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        //第四趟排序，就是将第四大的数排在倒数第四位</span></span><br><span class="line"><span class="comment">        for (int i = 0; i &lt; arr.length-4; i++) &#123;</span></span><br><span class="line"><span class="comment">            //如果前面的数比后面的数大，则交换</span></span><br><span class="line"><span class="comment">            if(arr[i]&gt;arr[i+1])&#123;</span></span><br><span class="line"><span class="comment">                temp=arr[i];</span></span><br><span class="line"><span class="comment">                arr[i]=arr[i+1];</span></span><br><span class="line"><span class="comment">                arr[i+1]=temp;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        System.out.println(&quot;第四次排序后的数组&quot;);</span></span><br><span class="line"><span class="comment">        System.out.println(Arrays.toString(arr));</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">        <span class="comment">//冒泡排序的时间复杂度O(n^2)</span></span><br><span class="line">        <span class="keyword">int</span> temp = <span class="number">0</span>;<span class="comment">//临时变量</span></span><br><span class="line">        <span class="keyword">boolean</span> flag=<span class="keyword">false</span>;<span class="comment">//标识变量，标识是否进行交换</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; arr.length - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">                <span class="comment">//如果前面的数比后面的数大，则交换</span></span><br><span class="line">                <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                    flag=<span class="keyword">true</span>;</span><br><span class="line">                    temp = arr[j];</span><br><span class="line">                    arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">                    arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//System.out.println(&quot;第&quot;+(i+1)+&quot;次排序后的数组&quot;);</span></span><br><span class="line">            <span class="comment">//System.out.println(Arrays.toString(arr));</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(!flag)&#123;  <span class="comment">//在一趟排序中，一次交换都没有发生过</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                flag=<span class="keyword">false</span>;<span class="comment">//重置flag，进行下次判断</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="2-选择排序"><a class="markdownIt-Anchor" href="#2-选择排序">#</a> 2、选择排序</h2>
<h3 id="思路分析-2"><a class="markdownIt-Anchor" href="#思路分析-2">#</a> 思路分析</h3>
<p>选择排序（select sorting）也是一种简单的排序方法。</p>
<p>它的<strong>基本思想</strong>是：</p>
<p>第一次从 arr [0]~arr [n-1] 中选取最小值，与 arr [0] 交换，</p>
<p>第二次从 arr [1]~arr [n-1] 中选取最小值，与 arr [1] 交换，</p>
<p>第三次从 arr [2]~arr [n-1] 中选取最小值，与 arr [2] 交换，…，</p>
<p>第 i 次从 arr [i-1]~arr [n-1] 中选取最小值，与 arr [i-1] 交换，…,</p>
<p>第 n-1 次从 arr [n-2]~arr [n-1] 中选取最小值，与 arr [n-2] 交换，</p>
<p>总共通过 n-1 次，得到一个按排序码从小到大排列的有序序列。</p>
<p><a href="https://imgtu.com/i/R7VTc8"><img src="https://z3.ax1x.com/2021/07/06/R7VTc8.png" alt="R7VTc8.png"></a></p>
<p><a href="https://imgtu.com/i/R7VXAs"><img src="https://z3.ax1x.com/2021/07/06/R7VXAs.png" alt="R7VXAs.png"></a></p>
<h3 id="代码实现-2"><a class="markdownIt-Anchor" href="#代码实现-2">#</a> 代码实现</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> demo2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SelectSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] arr=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">80000</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">80000</span>; i++) &#123;</span><br><span class="line">            arr[i]=(<span class="keyword">int</span>)(Math.random() * <span class="number">80000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Date date=<span class="keyword">new</span> Date();</span><br><span class="line">        SimpleDateFormat simpleDateFormat = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">        String format = simpleDateFormat.format(date);</span><br><span class="line">        System.out.println(<span class="string">&quot;排序前时间：&quot;</span>+format);</span><br><span class="line"></span><br><span class="line">        slelctSort(arr);</span><br><span class="line">        Date date1=<span class="keyword">new</span> Date();</span><br><span class="line">        String format1 = simpleDateFormat.format(date1);</span><br><span class="line">        System.out.println(<span class="string">&quot;排序后时间：&quot;</span>+format1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//选择排序</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">slelctSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">        <span class="comment">//选择排序的时间复杂度O(n^2)</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length-<span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> minIndex = i;</span><br><span class="line">            <span class="keyword">int</span> min=arr[i];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; arr.length ; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(min&gt;arr[j])&#123;<span class="comment">//说明假定的最小值，并不是最小</span></span><br><span class="line">                    min=arr[j];<span class="comment">//重置min</span></span><br><span class="line">                    minIndex=j;<span class="comment">//重置minIndex</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (minIndex!=i)&#123;</span><br><span class="line">                arr[minIndex]=arr[i];</span><br><span class="line">                arr[i]=min;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        //使用逐步推导的方式来，讲解选择排序</span></span><br><span class="line"><span class="comment">        //第一轮</span></span><br><span class="line"><span class="comment">        //原始数组：101,34,119,1</span></span><br><span class="line"><span class="comment">        //第一轮排序：1,34,119,101</span></span><br><span class="line"><span class="comment">        //算法，先简单 --&gt;再复杂，就是可以把一个复杂的算法，拆分成简单的问题 --&gt;逐步解决</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        //第一轮</span></span><br><span class="line"><span class="comment">        int minIndex = 0;</span></span><br><span class="line"><span class="comment">        int min=arr[0];</span></span><br><span class="line"><span class="comment">        for(int j = 0+1;j&lt;arr.length;j++)&#123;</span></span><br><span class="line"><span class="comment">            if(min&gt;arr[j])&#123;//说明假定的最小值，并不是最小</span></span><br><span class="line"><span class="comment">                min=arr[j];//重置min</span></span><br><span class="line"><span class="comment">                minIndex=j;//重置minIndex</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        //将最小值，放在arr[0],即交换</span></span><br><span class="line"><span class="comment">        if(minIndex!=0)&#123;</span></span><br><span class="line"><span class="comment">            arr[minIndex]=arr[0];</span></span><br><span class="line"><span class="comment">            arr[0]=min;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        System.out.println(&quot;第一轮后···&quot;);</span></span><br><span class="line"><span class="comment">        System.out.println(Arrays.toString(arr));</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        //第二轮</span></span><br><span class="line"><span class="comment">        minIndex = 1;</span></span><br><span class="line"><span class="comment">        min=arr[1];</span></span><br><span class="line"><span class="comment">        for(int j = 1+1;j&lt;arr.length;j++)&#123;</span></span><br><span class="line"><span class="comment">            if(min&gt;arr[j])&#123;//说明假定的最小值，并不是最小</span></span><br><span class="line"><span class="comment">                min=arr[j];//重置min</span></span><br><span class="line"><span class="comment">                minIndex=j;//重置minIndex</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        //将最小值，放在arr[1],即交换</span></span><br><span class="line"><span class="comment">        if (minIndex != 1) &#123;</span></span><br><span class="line"><span class="comment">            arr[minIndex]=arr[1];</span></span><br><span class="line"><span class="comment">            arr[1]=min;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        System.out.println(&quot;第二轮后···&quot;);</span></span><br><span class="line"><span class="comment">        System.out.println(Arrays.toString(arr));</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        //第三轮</span></span><br><span class="line"><span class="comment">        minIndex = 2;</span></span><br><span class="line"><span class="comment">        min=arr[2];</span></span><br><span class="line"><span class="comment">        for(int j = 2+1;j&lt;arr.length;j++)&#123;</span></span><br><span class="line"><span class="comment">            if(min&gt;arr[j])&#123;//说明假定的最小值，并不是最小</span></span><br><span class="line"><span class="comment">                min=arr[j];//重置min</span></span><br><span class="line"><span class="comment">                minIndex=j;//重置minIndex</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        //将最小值，放在arr[2],即交换</span></span><br><span class="line"><span class="comment">        if (minIndex != 2) &#123;</span></span><br><span class="line"><span class="comment">            arr[minIndex]=arr[2];</span></span><br><span class="line"><span class="comment">            arr[2]=min;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        System.out.println(&quot;第三轮后···&quot;);</span></span><br><span class="line"><span class="comment">        System.out.println(Arrays.toString(arr));</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-插入排序"><a class="markdownIt-Anchor" href="#3-插入排序">#</a> 3、插入排序</h2>
<h3 id="思路分析-3"><a class="markdownIt-Anchor" href="#思路分析-3">#</a> 思路分析</h3>
<p>插入排序（Insertion Sorting）的<strong>基本思想</strong>是：</p>
<p>把 n 个待排序的元素看成为一个有序表和一个无序表，</p>
<p>开始时有序表中只包含一个元素，无序表中包含有 n-1 个元素，</p>
<p>排序过程中每次从无序表中取出第一个元素，</p>
<p>把它的排序码依次与有序表元素的排序码进行比较，将它插入到有序表中的适当位置，</p>
<p>使之成为新的有序表。</p>
<h3 id="r7vjnnpng"><a class="markdownIt-Anchor" href="#r7vjnnpng">#</a> <a href="https://imgtu.com/i/R7VjNn"><img src="https://z3.ax1x.com/2021/07/06/R7VjNn.png" alt="R7VjNn.png"></a> 代码实现</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> demo3;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InsertSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//        int[] arr = &#123;101, 34, 119, 1, -1, 88&#125;;</span></span><br><span class="line"><span class="comment">//        insertSort(arr);</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] arr=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">80000</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">80000</span>; i++) &#123;</span><br><span class="line">            arr[i]=(<span class="keyword">int</span>)(Math.random() * <span class="number">80000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Date date=<span class="keyword">new</span> Date();</span><br><span class="line">        SimpleDateFormat simpleDateFormat = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">        String format = simpleDateFormat.format(date);</span><br><span class="line">        System.out.println(<span class="string">&quot;排序前时间：&quot;</span>+format);</span><br><span class="line"></span><br><span class="line">        insertSort(arr);</span><br><span class="line"></span><br><span class="line">        Date date1=<span class="keyword">new</span> Date();</span><br><span class="line">        String format1 = simpleDateFormat.format(date1);</span><br><span class="line">        System.out.println(<span class="string">&quot;排序后时间：&quot;</span>+format1);</span><br><span class="line"></span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//插入排序</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> insertVal = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> insertIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//使用for循环简化代码</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//定义待插入的数</span></span><br><span class="line">            insertVal = arr[i];</span><br><span class="line">            insertIndex = i - <span class="number">1</span>;<span class="comment">//即arr[1]的前面这个数的下标</span></span><br><span class="line">            <span class="comment">//给insertVal找到插入队伍</span></span><br><span class="line">            <span class="comment">//说明</span></span><br><span class="line">            <span class="comment">//1.insertIndex &gt;= 0 保证在给insertVal找插入位置，不越界</span></span><br><span class="line">            <span class="comment">//2.insertVal &lt; arr[insertIndex] 待插入的数，还没找到插入的位置</span></span><br><span class="line">            <span class="comment">//3.就需要将arr[insertIndex] 后移</span></span><br><span class="line">            <span class="keyword">while</span> (insertIndex &gt;= <span class="number">0</span> &amp;&amp; insertVal &lt; arr[insertIndex]) &#123;</span><br><span class="line">                arr[insertIndex + <span class="number">1</span>] = arr[insertIndex];</span><br><span class="line">                insertIndex--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//当退出while循环时,说明插入的位置找到，insertIndex+1</span></span><br><span class="line">            <span class="comment">//这里判断是否需要赋值</span></span><br><span class="line">            <span class="keyword">if</span>(insertIndex+<span class="number">1</span>!=i)&#123;</span><br><span class="line">                arr[insertIndex + <span class="number">1</span>] = insertVal;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//System.out.printf(&quot;第%d轮插入&quot;,i);</span></span><br><span class="line">            <span class="comment">//System.out.println(Arrays.toString(arr));</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        //使用逐步推导的方式来讲解，便于理解</span></span><br><span class="line"><span class="comment">        //第一轮&#123;101,34,119,1&#125; =》&#123;34,101,119,1&#125;</span></span><br><span class="line"><span class="comment">        //定义待插入的数</span></span><br><span class="line"><span class="comment">        int insertVal = arr[1];</span></span><br><span class="line"><span class="comment">        int insertIndex = 1 - 1;//即arr[1]的前面这个数的下标</span></span><br><span class="line"><span class="comment">        //给insertVal找到插入队伍</span></span><br><span class="line"><span class="comment">        //说明</span></span><br><span class="line"><span class="comment">        //1.insertIndex &gt;= 0 保证在给insertVal找插入位置，不越界</span></span><br><span class="line"><span class="comment">        //2.insertVal &lt; arr[insertIndex] 待插入的数，还没找到插入的位置</span></span><br><span class="line"><span class="comment">        //3.就需要将arr[insertIndex] 后移</span></span><br><span class="line"><span class="comment">        while (insertIndex &gt;= 0 &amp;&amp; insertVal &lt; arr[insertIndex]) &#123;</span></span><br><span class="line"><span class="comment">            arr[insertIndex + 1] = arr[insertIndex];</span></span><br><span class="line"><span class="comment">            insertIndex--;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        //当退出while循环时,说明插入的位置找到，insertIndex+1</span></span><br><span class="line"><span class="comment">        arr[insertIndex + 1] = insertVal;</span></span><br><span class="line"><span class="comment">        System.out.printf(&quot;第1轮插入&quot;);</span></span><br><span class="line"><span class="comment">        System.out.println(Arrays.toString(arr));</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        //第2轮</span></span><br><span class="line"><span class="comment">        insertVal = arr[2];</span></span><br><span class="line"><span class="comment">        insertIndex = 2 - 1;</span></span><br><span class="line"><span class="comment">        while (insertIndex &gt;= 0 &amp;&amp; insertVal &lt; arr[insertIndex]) &#123;</span></span><br><span class="line"><span class="comment">            arr[insertIndex + 1] = arr[insertIndex];</span></span><br><span class="line"><span class="comment">            insertIndex--;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        arr[insertIndex + 1] = insertVal;</span></span><br><span class="line"><span class="comment">        System.out.printf(&quot;第2轮插入&quot;);</span></span><br><span class="line"><span class="comment">        System.out.println(Arrays.toString(arr));</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        //第3轮</span></span><br><span class="line"><span class="comment">        insertVal = arr[3];</span></span><br><span class="line"><span class="comment">        insertIndex = 3 - 1;</span></span><br><span class="line"><span class="comment">        while (insertIndex &gt;= 0 &amp;&amp; insertVal &lt; arr[insertIndex]) &#123;</span></span><br><span class="line"><span class="comment">            arr[insertIndex + 1] = arr[insertIndex];</span></span><br><span class="line"><span class="comment">            insertIndex--;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        arr[insertIndex + 1] = insertVal;</span></span><br><span class="line"><span class="comment">        System.out.printf(&quot;第3轮插入&quot;);</span></span><br><span class="line"><span class="comment">        System.out.println(Arrays.toString(arr));</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="4-希尔排序"><a class="markdownIt-Anchor" href="#4-希尔排序">#</a> 4、希尔排序</h2>
<h3 id="希尔排序法介绍"><a class="markdownIt-Anchor" href="#希尔排序法介绍">#</a> 希尔排序法介绍</h3>
<p>希尔排序是希尔（Donald Shell）于 1959 年提出的一种排序算法。希尔排序也是一种<strong>插入排序</strong>，它是简单插入排序经过改进之后的一个<strong>更高效的版本</strong>，也称为<strong>缩小增量排序</strong>。</p>
<h3 id="思路分析-4"><a class="markdownIt-Anchor" href="#思路分析-4">#</a> 思路分析</h3>
<p><strong>希尔排序法基本思想</strong></p>
<p>希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至 1 时，整个文件恰被分成一组，算法便终止</p>
<p><a href="https://imgtu.com/i/R7ZpcT"><img src="https://z3.ax1x.com/2021/07/06/R7ZpcT.png" alt="R7ZpcT.png"></a></p>
<p><a href="https://imgtu.com/i/R7Vz90"><img src="https://z3.ax1x.com/2021/07/06/R7Vz90.png" alt="R7Vz90.png"></a></p>
<h3 id="代码实现两种方法"><a class="markdownIt-Anchor" href="#代码实现两种方法">#</a> 代码实现 (两种方法)</h3>
<h4 id="交换法"><a class="markdownIt-Anchor" href="#交换法">#</a> 交换法</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> demo4;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShellSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//int[] arr = &#123;8, 9, 1, 7, 2, 3, 5, 4, 6, 0&#125;;</span></span><br><span class="line">        <span class="comment">//shellSort(arr);</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] arr=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">80000</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">80000</span>; i++) &#123;</span><br><span class="line">            arr[i]=(<span class="keyword">int</span>)(Math.random() * <span class="number">80000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Date date=<span class="keyword">new</span> Date();</span><br><span class="line">        SimpleDateFormat simpleDateFormat = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">        String format = simpleDateFormat.format(date);</span><br><span class="line">        System.out.println(<span class="string">&quot;排序前时间：&quot;</span>+format);</span><br><span class="line"></span><br><span class="line">        shellSort(arr);</span><br><span class="line"></span><br><span class="line">        Date date1=<span class="keyword">new</span> Date();</span><br><span class="line">        String format1 = simpleDateFormat.format(date1);</span><br><span class="line">        System.out.println(<span class="string">&quot;排序后时间：&quot;</span>+format1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//System.out.println(Arrays.toString(arr));</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shellSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//循环处理</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> gap = arr.length / <span class="number">2</span>; gap &gt; <span class="number">0</span>; gap /= <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = gap; i &lt; arr.length; i++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = i - gap; j &gt;= <span class="number">0</span>; j -= gap) &#123;</span><br><span class="line">                    <span class="comment">//如果当前元素大于加上步长后的那个元素，说明交换</span></span><br><span class="line">                    <span class="keyword">if</span> (arr[j] &gt; arr[j + gap]) &#123;</span><br><span class="line">                        temp = arr[j];</span><br><span class="line">                        arr[j] = arr[j + gap];</span><br><span class="line">                        arr[j + gap] = temp;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//System.out.println(&quot;第&quot; + (++count) + &quot;轮后&quot; + Arrays.toString(arr));</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        //使用逐步推导的方式逐步说明</span></span><br><span class="line"><span class="comment">        int temp = 0;</span></span><br><span class="line"><span class="comment">        //第一轮</span></span><br><span class="line"><span class="comment">        //因为第一轮排序是将10个数据分成了5组</span></span><br><span class="line"><span class="comment">        for (int i = 5; i &lt; arr.length; i++) &#123;</span></span><br><span class="line"><span class="comment">            //遍历各组中所有的元素（共5组，每组两个元素）</span></span><br><span class="line"><span class="comment">            for (int j = i - 5; j &gt;= 0; j -= 5) &#123;</span></span><br><span class="line"><span class="comment">                //如果当前元素大于加上步长后的那个元素，说明交换</span></span><br><span class="line"><span class="comment">                if (arr[j] &gt; arr[j + 5]) &#123;</span></span><br><span class="line"><span class="comment">                    temp = arr[j];</span></span><br><span class="line"><span class="comment">                    arr[j] = arr[j + 5];</span></span><br><span class="line"><span class="comment">                    arr[j + 5] = temp;</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        System.out.println(&quot;第1轮后&quot;+ Arrays.toString(arr));</span></span><br><span class="line"><span class="comment">        //第二轮排序</span></span><br><span class="line"><span class="comment">        //因为第二轮排序是将10个数据分成了2组</span></span><br><span class="line"><span class="comment">        for (int i = 2; i &lt; arr.length; i++) &#123;</span></span><br><span class="line"><span class="comment">            //遍历各组中所有的元素（共5组，每组两个元素）</span></span><br><span class="line"><span class="comment">            for (int j = i - 2; j &gt;= 0; j -= 2) &#123;</span></span><br><span class="line"><span class="comment">                //如果当前元素大于加上步长后的那个元素，说明交换</span></span><br><span class="line"><span class="comment">                if (arr[j] &gt; arr[j + 2]) &#123;</span></span><br><span class="line"><span class="comment">                    temp = arr[j];</span></span><br><span class="line"><span class="comment">                    arr[j] = arr[j + 2];</span></span><br><span class="line"><span class="comment">                    arr[j + 2] = temp;</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        System.out.println(&quot;第2轮后&quot;+ Arrays.toString(arr));</span></span><br><span class="line"><span class="comment">        //第三轮排序</span></span><br><span class="line"><span class="comment">        //因为第三轮排序是将10个数据分成了2/2=1组</span></span><br><span class="line"><span class="comment">        for (int i = 1; i &lt; arr.length; i++) &#123;</span></span><br><span class="line"><span class="comment">            //遍历各组中所有的元素（共5组，每组两个元素）</span></span><br><span class="line"><span class="comment">            for (int j = i - 1; j &gt;= 0; j -= 1) &#123;</span></span><br><span class="line"><span class="comment">                //如果当前元素大于加上步长后的那个元素，说明交换</span></span><br><span class="line"><span class="comment">                if (arr[j] &gt; arr[j + 1]) &#123;</span></span><br><span class="line"><span class="comment">                    temp = arr[j];</span></span><br><span class="line"><span class="comment">                    arr[j] = arr[j + 1];</span></span><br><span class="line"><span class="comment">                    arr[j + 1] = temp;</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        System.out.println(&quot;第3轮后&quot;+ Arrays.toString(arr));</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="移位法"><a class="markdownIt-Anchor" href="#移位法">#</a> 移位法</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> demo4;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShellSort1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//int[] arr = &#123;8, 9, 1, 7, 2, 3, 5, 4, 6, 0&#125;;</span></span><br><span class="line">        <span class="comment">//shellSort(arr);</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] arr=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">80000</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">80000</span>; i++) &#123;</span><br><span class="line">            arr[i]=(<span class="keyword">int</span>)(Math.random() * <span class="number">80000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Date date=<span class="keyword">new</span> Date();</span><br><span class="line">        SimpleDateFormat simpleDateFormat = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">        String format = simpleDateFormat.format(date);</span><br><span class="line">        System.out.println(<span class="string">&quot;排序前时间：&quot;</span>+format);</span><br><span class="line"></span><br><span class="line">        shellSort(arr);</span><br><span class="line"></span><br><span class="line">        Date date1=<span class="keyword">new</span> Date();</span><br><span class="line">        String format1 = simpleDateFormat.format(date1);</span><br><span class="line">        System.out.println(<span class="string">&quot;排序后时间：&quot;</span>+format1);</span><br><span class="line"></span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//对交换式的希尔排序进行优化 -&gt; 移位法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shellSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//常量gap，并逐渐的缩小常量</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> gap = arr.length / <span class="number">2</span>; gap &gt; <span class="number">0</span>; gap /= <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="comment">//从第gap个元素，逐个对其所在的组进行直接插入排序</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = gap; i &lt; arr.length; i++) &#123;</span><br><span class="line">                <span class="keyword">int</span> j=i;</span><br><span class="line">                <span class="keyword">int</span> temp =arr[j];</span><br><span class="line">                <span class="keyword">if</span>(arr[j]&lt;arr[j-gap])&#123;</span><br><span class="line">                    <span class="keyword">while</span> (j-gap&gt;=<span class="number">0</span>&amp;&amp;temp&lt;arr[j-gap])&#123;</span><br><span class="line">                        <span class="comment">//移动</span></span><br><span class="line">                        arr[j]=arr[j-gap];</span><br><span class="line">                        j-=gap;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//当退出while后，就给temp找到插入的位置</span></span><br><span class="line">                    arr[j]=temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="5-快速排序"><a class="markdownIt-Anchor" href="#5-快速排序">#</a> 5、快速排序</h2>
<h3 id="思路分析-5"><a class="markdownIt-Anchor" href="#思路分析-5">#</a> 思路分析</h3>
<p>** 快速排序（Quicksort）是对冒泡排序的一种改进。** 基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列</p>
<p><a href="https://imgtu.com/i/R7Zt8P"><img src="https://z3.ax1x.com/2021/07/06/R7Zt8P.jpg" alt="R7Zt8P.jpg"></a></p>
<h3 id="代码实现-3"><a class="markdownIt-Anchor" href="#代码实现-3">#</a> 代码实现</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> demo5;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuickSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//        int[] arr = &#123;-9, 78, 0, 23, -567, 70,-5,54,899,-155&#125;;</span></span><br><span class="line"><span class="comment">//        quickSort(arr, 0, arr.length - 1);</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;arr=&quot; + Arrays.toString(arr));</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] arr=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">80000</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">80000</span>; i++) &#123;</span><br><span class="line">            arr[i]=(<span class="keyword">int</span>)(Math.random() * <span class="number">80000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Date date=<span class="keyword">new</span> Date();</span><br><span class="line">        SimpleDateFormat simpleDateFormat = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">        String format = simpleDateFormat.format(date);</span><br><span class="line">        System.out.println(<span class="string">&quot;排序前时间：&quot;</span>+format);</span><br><span class="line"></span><br><span class="line">        quickSort(arr,<span class="number">0</span>,arr.length-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        Date date1=<span class="keyword">new</span> Date();</span><br><span class="line">        String format1 = simpleDateFormat.format(date1);</span><br><span class="line">        System.out.println(<span class="string">&quot;排序后时间：&quot;</span>+format1);</span><br><span class="line"></span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = left;   <span class="comment">//左小标</span></span><br><span class="line">        <span class="keyword">int</span> r = right;  <span class="comment">//右下标</span></span><br><span class="line">        <span class="comment">//pivot 中轴值</span></span><br><span class="line">        <span class="keyword">int</span> pivot = arr[(left + right) / <span class="number">2</span>];</span><br><span class="line">        <span class="keyword">int</span> temp = <span class="number">0</span>;<span class="comment">//临时变量，交换时使用</span></span><br><span class="line">        <span class="comment">//while循环的目的是让比pivot值小的放到左边</span></span><br><span class="line">        <span class="comment">//比pivot大的值放到右边</span></span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="comment">//在pivot的左边一直找，找到大于等于pivot值，才退出</span></span><br><span class="line">            <span class="keyword">while</span> (arr[l] &lt; pivot) &#123;</span><br><span class="line">                l += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//在pivot的右边一直找，找到小于等于pivot值，才退出</span></span><br><span class="line">            <span class="keyword">while</span> (arr[r] &gt; pivot) &#123;</span><br><span class="line">                r -= <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果 l &gt;= r 说明pivot 的左右两边的值，已经按照左边全部是小于等于pivot的值，右边全部是大于等于pivot的值</span></span><br><span class="line">            <span class="keyword">if</span> (l &gt;= r) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//交换</span></span><br><span class="line">            temp = arr[l];</span><br><span class="line">            arr[l] = arr[r];</span><br><span class="line">            arr[r] = temp;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//如果交换完后，发现这个arr[l]==pivot 值，相当于 r--，前移</span></span><br><span class="line">            <span class="keyword">if</span> (arr[l] == pivot) &#123;</span><br><span class="line">                r -= <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果交换完后，发现这个arr[r]==pivot 值，相当于 l++，前移</span></span><br><span class="line">            <span class="keyword">if</span> (arr[r] == pivot) &#123;</span><br><span class="line">                l += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果l==r,必须l++,r--,否则出现栈溢出</span></span><br><span class="line">        <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">            l += <span class="number">1</span>;</span><br><span class="line">            r -= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//向左递归</span></span><br><span class="line">        <span class="keyword">if</span> (left &lt; r) &#123;</span><br><span class="line">            quickSort(arr, left, r);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//向右递归</span></span><br><span class="line">        <span class="keyword">if</span> (right &gt; l) &#123;</span><br><span class="line">            quickSort(arr, l, right);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="6-归并排序"><a class="markdownIt-Anchor" href="#6-归并排序">#</a> 6、归并排序</h2>
<h3 id="思路分析-6"><a class="markdownIt-Anchor" href="#思路分析-6">#</a> 思路分析</h3>
<p><strong>归并排序思想示意图 1:</strong></p>
<p>归并排序（MERGE-SORT）是利用归并的思想实现的排序方法，该算法采用经典的分治（divide-and-conquer）策略（分治法将问题分 (divide) 成一些小的问题然后递归求解，而治 (conquer) 的阶段则将分的阶段得到的各答案 &quot;修补&quot; 在一起，即分而治之)。</p>
<p><a href="https://imgtu.com/i/R7ZdKS"><img src="https://z3.ax1x.com/2021/07/06/R7ZdKS.png" alt="R7ZdKS.png"></a></p>
<p><strong>可以看到这种结构很像一棵完全二叉树，本文的归并排序我们采用递归去实现（也可采用迭代的方式去实现）。分阶段可以理解为就是递归拆分子序列的过程。</strong></p>
<p><strong>归并排序思想示意图 2:</strong></p>
<p><strong>再来看看治阶段，我们需要将两个已经有序的子序列合并成一个有序序列，比如上图中的最后一次合并，要将 [4,5,7,8] 和 [1,2,3,6] 两个已经有序的子序列，合并为最终序列 [1,2,3,4,5,6,7,8]，来看下实现步骤</strong></p>
<p><a href="https://imgtu.com/i/R7Z6Cq"><img src="https://z3.ax1x.com/2021/07/06/R7Z6Cq.png" alt="R7Z6Cq.png"></a></p>
<p><a href="https://imgtu.com/i/R7ZWKU"><img src="https://z3.ax1x.com/2021/07/06/R7ZWKU.png" alt="R7ZWKU.png"></a></p>
<h3 id="代码实现-4"><a class="markdownIt-Anchor" href="#代码实现-4">#</a> 代码实现</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> demo6;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MergetSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//int[] arr = &#123;8, 4, 5, 7, 1, 3, 6, 2&#125;;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] arr=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">80000</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">80000</span>; i++) &#123;</span><br><span class="line">            arr[i]=(<span class="keyword">int</span>)(Math.random() * <span class="number">80000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Date date=<span class="keyword">new</span> Date();</span><br><span class="line">        SimpleDateFormat simpleDateFormat = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">        String format = simpleDateFormat.format(date);</span><br><span class="line">        System.out.println(<span class="string">&quot;排序前时间：&quot;</span>+format);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] temp=<span class="keyword">new</span> <span class="keyword">int</span>[arr.length];<span class="comment">//归并排序需要一个额外空间</span></span><br><span class="line">        mergeSort(arr,<span class="number">0</span>,arr.length-<span class="number">1</span>,temp);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Date date1=<span class="keyword">new</span> Date();</span><br><span class="line">        String format1 = simpleDateFormat.format(date1);</span><br><span class="line">        System.out.println(<span class="string">&quot;排序后时间：&quot;</span>+format1);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;归并排序后=&quot;</span>+ Arrays.toString(arr));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//分+合方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span>[] temp)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;<span class="comment">//中间索引</span></span><br><span class="line">            <span class="comment">//向左递归进行分解</span></span><br><span class="line">            mergeSort(arr, left, mid, temp);</span><br><span class="line">            <span class="comment">//向右递归进行分际</span></span><br><span class="line">            mergeSort(arr, mid+<span class="number">1</span>, right, temp);</span><br><span class="line">            <span class="comment">//合并</span></span><br><span class="line">            merge(arr,left,mid,right,temp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 合并的方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr   排序的原始数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> left  左边有序序列的初始索引</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> mid   中间索引</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> right 右边有序序列的初始索引</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> temp  做中转的数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> mid, <span class="keyword">int</span> right, <span class="keyword">int</span>[] temp)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//System.out.println(&quot;=========================&quot;);</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> i = left;<span class="comment">//初始化 i,左边有序序列的初始索引</span></span><br><span class="line">        <span class="keyword">int</span> j = mid + <span class="number">1</span>;<span class="comment">//初始化 j,右边有序序列的初始索引</span></span><br><span class="line">        <span class="keyword">int</span> t = <span class="number">0</span>; <span class="comment">//指向temp数组的当前索引</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//（一）</span></span><br><span class="line">        <span class="comment">//先把左右两边（有序）的数据按照规则填充到temp数组</span></span><br><span class="line">        <span class="comment">//直到左右两边的有序序列，有一边处理完毕</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= right) &#123;<span class="comment">//继续</span></span><br><span class="line">            <span class="comment">//如果左边的有序序列的当前元素，小于等于右边有序序列的当前元素</span></span><br><span class="line">            <span class="comment">//即将左边的当前元素，填充到temp数组</span></span><br><span class="line">            <span class="keyword">if</span> (arr[i] &lt;= arr[j]) &#123;</span><br><span class="line">                temp[t] = arr[i];</span><br><span class="line">                t += <span class="number">1</span>;</span><br><span class="line">                i += <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;<span class="comment">//反之，将右边有序序列的当前元素，填充到temp数组中</span></span><br><span class="line">                temp[t] = arr[j];</span><br><span class="line">                t += <span class="number">1</span>;</span><br><span class="line">                j += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//（二）</span></span><br><span class="line">        <span class="comment">//把有剩余数据的一边的数据依次全部填充到temp</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt;= mid) &#123;<span class="comment">//左边的有序序列还有剩余的元素，就全部填充到temp</span></span><br><span class="line">            temp[t] = arr[i];</span><br><span class="line">            t += <span class="number">1</span>;</span><br><span class="line">            i += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (j &lt;= right) &#123;<span class="comment">//右边的有序序列还有剩余的元素，就全部填充到temp</span></span><br><span class="line">            temp[t] = arr[j];</span><br><span class="line">            t += <span class="number">1</span>;</span><br><span class="line">            j += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//（三）</span></span><br><span class="line">        <span class="comment">//将temp数组的元素拷贝到arr</span></span><br><span class="line">        <span class="comment">//注意：并不是每次都拷贝数组中所有的元素</span></span><br><span class="line">        t = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> templeft = left;</span><br><span class="line">        <span class="comment">//第一次合并 templeft = 0，right = 1；</span></span><br><span class="line">        <span class="comment">//第二次合并 templeft = 2，right = 3；</span></span><br><span class="line">        <span class="comment">//第三次合并 templeft = 0，right = 3；</span></span><br><span class="line">        <span class="comment">// . . .</span></span><br><span class="line">        <span class="comment">//最后一次合并 templeft = 0，right = 7；</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//System.out.println(&quot;templeft=&quot;+templeft+&quot;,right&quot;+right);</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (templeft &lt;= right) &#123;</span><br><span class="line"></span><br><span class="line">            arr[templeft] = temp[t];</span><br><span class="line">            t += <span class="number">1</span>;</span><br><span class="line">            templeft += <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="7-基数排序桶排序的扩展"><a class="markdownIt-Anchor" href="#7-基数排序桶排序的扩展">#</a> 7、基数排序 (桶排序的扩展)</h2>
<h3 id="思路分析-7"><a class="markdownIt-Anchor" href="#思路分析-7">#</a> 思路分析</h3>
<ol>
<li>
<p><strong>基数排序</strong>（radix sort）属于 “分配式排序”（distribution sort），又称 “桶子法”（bucket sort）或 bin sort，顾名思义，它是通过键值的各个位的值，将要排序的<strong>元素分配</strong>至某些 “桶” 中，达到排序的作用</p>
</li>
<li>
<p>基数排序法是属于稳定性的排序，基数排序法的是效率高的稳定性排序法</p>
</li>
<li>
<p>基数排序 (Radix Sort) 是<strong>桶排序</strong>的扩展</p>
</li>
<li>
<p>基数排序是 1887 年赫尔曼・何乐礼发明的。它是这样实现的：将整数按位数切割成不同的数字，然后按每个位数分别比较。</p>
</li>
</ol>
<p><strong>基本思想</strong></p>
<ul>
<li>将所有待比较数值统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序，这样从最低位排序一直到最高位排序完成以后，数列就变成一个有序序列</li>
</ul>
<p><strong>图文解释</strong></p>
<p><a href="https://imgtu.com/i/R7ZIa9"><img src="https://z3.ax1x.com/2021/07/06/R7ZIa9.png" alt="R7ZIa9.png"></a></p>
<p><strong>基数排序的说明</strong></p>
<ol>
<li>
<p>基数排序是对传统桶排序的扩展，速度很快.</p>
</li>
<li>
<p>基数排序是经典的空间换时间的方式，占用内存很大，当对海量数据排序时，容易造成 OutOfMemoryError 。</p>
</li>
<li>
<p>基数排序时稳定的。[注：假定在待排序的记录序列中，存在多个具有相同的关键字的记录，若经过排序，这些记录的相对次序保持不变，即在原序列中，r [i]=r [j]，且 r [i] 在 r [j] 之前，而在排序后的序列中，r [i] 仍在 r [j] 之前，<strong>则称这种排序算法是稳定的；否则称为不稳定的</strong>]</p>
</li>
<li>
<p><strong>有负数的数组，我们不用基数排序来进行排序</strong> **,** <strong>如果要支持负数，参考</strong> **😗* <strong><a href="https://code.i-harness.com/zh-CN/q/e98fa9">https://code.i-harness.com/zh-CN/q/e98fa9</a></strong></p>
</li>
</ol>
<h3 id="代码实现-5"><a class="markdownIt-Anchor" href="#代码实现-5">#</a> 代码实现</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> demo7;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RadixSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//int[] arr = &#123;53, 3, 542, 748, 14, 214&#125;;</span></span><br><span class="line">        <span class="comment">//radixSort(arr);</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//80000 * 11 *4</span></span><br><span class="line">        <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">80000</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">80000</span>; i++) &#123;</span><br><span class="line">            arr[i] = (<span class="keyword">int</span>) (Math.random() * <span class="number">80000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Date date = <span class="keyword">new</span> Date();</span><br><span class="line">        SimpleDateFormat simpleDateFormat = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">        String format = simpleDateFormat.format(date);</span><br><span class="line">        System.out.println(<span class="string">&quot;排序前时间：&quot;</span> + format);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        radixSort(arr);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Date date1 = <span class="keyword">new</span> Date();</span><br><span class="line">        String format1 = simpleDateFormat.format(date1);</span><br><span class="line">        System.out.println(<span class="string">&quot;排序后时间：&quot;</span> + format1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//System.out.println(&quot;arr=&quot;+Arrays.toString(arr));</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//基数排序方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">radixSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//根据前面的推导过程，我们可以得到最终的基数排序代码</span></span><br><span class="line">        <span class="comment">//1.得到数组中最大的数的位数</span></span><br><span class="line">        <span class="keyword">int</span> max = arr[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] &gt; arr[<span class="number">0</span>]) &#123;</span><br><span class="line">                max = arr[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//得到最大数是几位数</span></span><br><span class="line">        <span class="keyword">int</span> maxLength = (max + <span class="string">&quot;&quot;</span>).length();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//定义一个二维数组，表示10个桶，每个桶都是一个一维数组</span></span><br><span class="line">        <span class="comment">//说明</span></span><br><span class="line">        <span class="comment">//1. 二维数组包含10个一维数组</span></span><br><span class="line">        <span class="comment">//2. 为了防止在放入数的时候，数据溢出，则每一个一维数组（桶），大小定为arr.length</span></span><br><span class="line">        <span class="comment">//3.明确，基数排序是使用空间换时间的经典算法</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[][] bucket = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>][arr.length];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//为了记录每个桶中，实际存放了多少个数据，我们定义一个一维数组来记录各个桶的每次放入的数据个数</span></span><br><span class="line">        <span class="comment">//可以这样理解</span></span><br><span class="line">        <span class="comment">//比如：buckerElementCounts[0]，记录的就是 bucket[0] 桶的放入数据个数</span></span><br><span class="line">        <span class="keyword">int</span>[] buckerElementCounts = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, n = <span class="number">1</span>; i &lt; maxLength; i++, n *= <span class="number">10</span>) &#123;</span><br><span class="line">            <span class="comment">//（针对每个元素对应的位进行排序处理），第一次是个位，第二次是十位，第三次是百位 依次类推</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">                <span class="comment">//取出每个元素对应位数的值</span></span><br><span class="line">                <span class="keyword">int</span> digitOfElement = arr[j] / n % <span class="number">10</span>;</span><br><span class="line">                <span class="comment">//放入到对应的桶中</span></span><br><span class="line">                bucket[digitOfElement][buckerElementCounts[digitOfElement]] = arr[j];</span><br><span class="line">                buckerElementCounts[digitOfElement]++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//按照这个桶的顺序（一维数组的下标依次取出数据，放回原来数组）</span></span><br><span class="line">            <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">//遍历每一个桶，并将桶中的数据，放回原来的数组中</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; buckerElementCounts.length; k++) &#123;</span><br><span class="line">                <span class="comment">//如果桶中，有数据，我们才放入到原数组中</span></span><br><span class="line">                <span class="keyword">if</span> (buckerElementCounts[k] != <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">//循环该桶即第k个桶（即第看个一维数组），放入</span></span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">0</span>; l &lt; buckerElementCounts[k]; l++) &#123;</span><br><span class="line">                        <span class="comment">//取出元素放入到arr</span></span><br><span class="line">                        arr[index++] = bucket[k][l];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//第 i+1 轮处理后需要将每个buckerElementCounts[k] 置零</span></span><br><span class="line">                buckerElementCounts[k] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//System.out.println(&quot;第&quot;+(i+1)+&quot;轮，对个位的排序处理arr = &quot; + Arrays.toString(arr));</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        //第一轮排序（针对每个元素的个位进行排序处理）</span></span><br><span class="line"><span class="comment">        //定义一个二维数组，表示10个桶，每个桶都是一个一维数组</span></span><br><span class="line"><span class="comment">        //说明</span></span><br><span class="line"><span class="comment">        //1. 二维数组包含10个一维数组</span></span><br><span class="line"><span class="comment">        //2. 为了防止在放入数的时候，数据溢出，则每一个一维数组（桶），大小定为arr.length</span></span><br><span class="line"><span class="comment">        //3.明确，基数排序是使用空间换时间的经典算法</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        int[][] bucket = new int[10][arr.length];</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        //为了记录每个桶中，实际存放了多少个数据，我们定义一个一维数组来记录各个桶的每次放入的数据个数</span></span><br><span class="line"><span class="comment">        //可以这样理解</span></span><br><span class="line"><span class="comment">        //比如：buckerElementCounts[0]，记录的就是 bucket[0] 桶的放入数据个数</span></span><br><span class="line"><span class="comment">        int[] buckerElementCounts = new int[10];</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        //第一轮（针对每个元素的个位进行排序处理）</span></span><br><span class="line"><span class="comment">        for (int j = 0; j &lt; arr.length; j++) &#123;</span></span><br><span class="line"><span class="comment">            //取出每个元素的个位的值</span></span><br><span class="line"><span class="comment">            int digitOfElement = arr[j] / 1 % 10;</span></span><br><span class="line"><span class="comment">            //放入到对应的桶中</span></span><br><span class="line"><span class="comment">            bucket[digitOfElement][buckerElementCounts[digitOfElement]] = arr[j];</span></span><br><span class="line"><span class="comment">            buckerElementCounts[digitOfElement]++;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        //按照这个桶的顺序（一维数组的下标依次取出数据，放回原来数组）</span></span><br><span class="line"><span class="comment">        int index = 0;</span></span><br><span class="line"><span class="comment">        //遍历每一个桶，并将桶中的数据，放回原来的数组中</span></span><br><span class="line"><span class="comment">        for (int k = 0; k &lt; buckerElementCounts.length; k++) &#123;</span></span><br><span class="line"><span class="comment">            //如果桶中，有数据，我们才放入到原数组中</span></span><br><span class="line"><span class="comment">            if (buckerElementCounts[k] != 0) &#123;</span></span><br><span class="line"><span class="comment">                //循环该桶即第k个桶（即第看个一维数组），放入</span></span><br><span class="line"><span class="comment">                for (int l = 0; l &lt; buckerElementCounts[k]; l++) &#123;</span></span><br><span class="line"><span class="comment">                    //取出元素放入到arr</span></span><br><span class="line"><span class="comment">                    arr[index++] = bucket[k][l];</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">            //第一轮处理后需要将每个buckerElementCounts[k] 置零</span></span><br><span class="line"><span class="comment">            buckerElementCounts[k] = 0;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        System.out.println(&quot;第一轮，对个位的排序处理arr = &quot; + Arrays.toString(arr));</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        //---------------------------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        //第二轮（针对每个元素的十位进行排序处理）</span></span><br><span class="line"><span class="comment">        for (int j = 0; j &lt; arr.length; j++) &#123;</span></span><br><span class="line"><span class="comment">            //取出每个元素的十位的值</span></span><br><span class="line"><span class="comment">            int digitOfElement = arr[j] / 10 % 10;</span></span><br><span class="line"><span class="comment">            //放入到对应的桶中</span></span><br><span class="line"><span class="comment">            bucket[digitOfElement][buckerElementCounts[digitOfElement]] = arr[j];</span></span><br><span class="line"><span class="comment">            buckerElementCounts[digitOfElement]++;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        //按照这个桶的顺序（一维数组的下标依次取出数据，放回原来数组）</span></span><br><span class="line"><span class="comment">        index = 0;</span></span><br><span class="line"><span class="comment">        //遍历每一个桶，并将桶中的数据，放回原来的数组中</span></span><br><span class="line"><span class="comment">        for (int k = 0; k &lt; buckerElementCounts.length; k++) &#123;</span></span><br><span class="line"><span class="comment">            //如果桶中，有数据，我们才放入到原数组中</span></span><br><span class="line"><span class="comment">            if (buckerElementCounts[k] != 0) &#123;</span></span><br><span class="line"><span class="comment">                //循环该桶即第k个桶（即第看个一维数组），放入</span></span><br><span class="line"><span class="comment">                for (int l = 0; l &lt; buckerElementCounts[k]; l++) &#123;</span></span><br><span class="line"><span class="comment">                    //取出元素放入到arr</span></span><br><span class="line"><span class="comment">                    arr[index++] = bucket[k][l];</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">            //第二轮处理后需要将每个buckerElementCounts[k] 置零</span></span><br><span class="line"><span class="comment">            buckerElementCounts[k] = 0;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        System.out.println(&quot;第二轮，对十位的排序处理arr = &quot; + Arrays.toString(arr));</span></span><br><span class="line"><span class="comment">        //---------------------------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        //第三轮（针对每个元素的百位进行排序处理）</span></span><br><span class="line"><span class="comment">        for (int j = 0; j &lt; arr.length; j++) &#123;</span></span><br><span class="line"><span class="comment">            //取出每个元素的百位的值</span></span><br><span class="line"><span class="comment">            int digitOfElement = arr[j] / 100 % 10;</span></span><br><span class="line"><span class="comment">            //放入到对应的桶中</span></span><br><span class="line"><span class="comment">            bucket[digitOfElement][buckerElementCounts[digitOfElement]] = arr[j];</span></span><br><span class="line"><span class="comment">            buckerElementCounts[digitOfElement]++;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        //按照这个桶的顺序（一维数组的下标依次取出数据，放回原来数组）</span></span><br><span class="line"><span class="comment">        index = 0;</span></span><br><span class="line"><span class="comment">        //遍历每一个桶，并将桶中的数据，放回原来的数组中</span></span><br><span class="line"><span class="comment">        for (int k = 0; k &lt; buckerElementCounts.length; k++) &#123;</span></span><br><span class="line"><span class="comment">            //如果桶中，有数据，我们才放入到原数组中</span></span><br><span class="line"><span class="comment">            if (buckerElementCounts[k] != 0) &#123;</span></span><br><span class="line"><span class="comment">                //循环该桶即第k个桶（即第看个一维数组），放入</span></span><br><span class="line"><span class="comment">                for (int l = 0; l &lt; buckerElementCounts[k]; l++) &#123;</span></span><br><span class="line"><span class="comment">                    //取出元素放入到arr</span></span><br><span class="line"><span class="comment">                    arr[index++] = bucket[k][l];</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">            //第三轮处理后需要将每个buckerElementCounts[k] 置零</span></span><br><span class="line"><span class="comment">            buckerElementCounts[k] = 0;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        System.out.println(&quot;第三轮，对百个位的排序处理arr = &quot; + Arrays.toString(arr));</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="8-堆排序未讲解"><a class="markdownIt-Anchor" href="#8-堆排序未讲解">#</a> 8、堆排序（未讲解）</h2>
<h3 id="思路分析-8"><a class="markdownIt-Anchor" href="#思路分析-8">#</a> 思路分析</h3>
<h3 id="代码实现-6"><a class="markdownIt-Anchor" href="#代码实现-6">#</a> 代码实现</h3>
<h2 id="基本排序算法的比较"><a class="markdownIt-Anchor" href="#基本排序算法的比较">#</a> 基本排序算法的比较</h2>
<ol>
<li><a href="https://imgtu.com/i/R7Zzad"><img src="https://z3.ax1x.com/2021/07/06/R7Zzad.png" alt="R7Zzad.png"></a><strong> 稳定</strong>：如果 a 原本在 b 前面，而 a=b，排序之后 a 仍然在 b 的前面；</li>
<li><strong>不稳定</strong>：如果 a 原本在 b 的前面，而 a=b，排序之后 a 可能会出现在 b 的后面；</li>
<li><strong>内排序</strong>：所有排序操作都在内存中完成；</li>
<li><strong>外排序</strong>：由于数据太大，因此把数据放在磁盘中，而排序通过磁盘和内存的数据传输才能进行；</li>
<li><strong>时间复杂度：</strong> 一个算法执行所耗费的时间。</li>
<li><strong>空间复杂度</strong>：运行完一个程序所需内存的大小。</li>
<li><strong>n:</strong> 数据规模</li>
<li><strong>k:</strong> “桶” 的个数</li>
<li><strong>In-place:</strong>  不占用额外内存</li>
<li><strong>Out-place:</strong> 占用额外内存</li>
</ol>
]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>07.排序算法</category>
      </categories>
      <tags>
        <tag>算法与数据结构</tag>
        <tag>排序算法</tag>
        <tag>冒泡排序</tag>
        <tag>时间复杂度</tag>
        <tag>选择排序</tag>
        <tag>插入排序</tag>
        <tag>希尔排序</tag>
        <tag>快速排序</tag>
        <tag>归并排序</tag>
        <tag>基数排序</tag>
        <tag>堆排序</tag>
      </tags>
  </entry>
  <entry>
    <title>树结构实际应用</title>
    <url>/2021/07/08/11.%E6%A0%91%E7%BB%93%E6%9E%84%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<h2 id="堆排序"><a class="markdownIt-Anchor" href="#堆排序">#</a> 堆排序</h2>
<h3 id="基本介绍"><a class="markdownIt-Anchor" href="#基本介绍">#</a> 基本介绍</h3>
<ol>
<li>
<p>堆排序是利用<strong>堆</strong>这种数据结构而设计的一种排序算法，堆排序是一种 ** 选择排序，** 它的最坏，最好，平均时间复杂度均为 O (nlogn)，它也是不稳定排序。</p>
</li>
<li>
<p>堆是具有以下性质的完全二叉树：每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆，<strong>注意</strong>：没有要求结点的左孩子的值和右孩子的值的大小关系。</p>
</li>
<li>
<p>每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆</p>
</li>
<li>
<p><strong>大顶堆</strong></p>
<p><a href="https://imgtu.com/i/R7nrUH"><img src="https://z3.ax1x.com/2021/07/06/R7nrUH.png" alt="R7nrUH.png"></a></p>
<p><a href="https://imgtu.com/i/R7Rm7V"><img src="https://z3.ax1x.com/2021/07/07/R7Rm7V.png" alt="R7Rm7V.png"></a></p>
<p><strong>大顶堆特点： arr [i]&gt;=arr [2 * i+1] &amp;&amp; arr [i] &gt;= arr [2 * i+2] //i 对应几个节点，i 从 0 开始编号</strong></p>
</li>
<li>
<p><strong>小顶堆</strong></p>
<p><a href="https://imgtu.com/i/R7RMhF"><img src="https://z3.ax1x.com/2021/07/07/R7RMhF.png" alt="R7RMhF.png"></a></p>
<p><strong>小顶堆特点： arr [i] &lt;= arr [2 * i+1] &amp;&amp; arr [i] &lt;= arr [2 * i+2] //i 对应几个节点，i 从 0 开始编号</strong></p>
</li>
<li>
<p><strong>一般升序采用大顶堆，降序采用小顶堆</strong></p>
</li>
</ol>
<ul>
<li>
<p>堆排序的基本思想是：</p>
<ul>
<li>
<p>将待排序序列构造成一个大顶堆</p>
</li>
<li>
<p>此时，整个序列的最大值就是堆顶的根节点。</p>
</li>
<li>
<p>将其与末尾元素进行交换，此时末尾就为最大值。</p>
</li>
<li>
<p>然后将剩余 n-1 个元素重新构造成一个堆，这样会得到 n 个元素的次小值。如此反复执行，便能得到一个有序序列了。</p>
</li>
</ul>
</li>
</ul>
<h3 id="思路分析"><a class="markdownIt-Anchor" href="#思路分析">#</a> 思路分析</h3>
<p><strong>步骤一 构造初始堆。将给定无序序列构造成一个大顶堆（一般升序采用大顶堆，降序采用小顶堆)。</strong></p>
<ol>
<li>. 假设给定无序序列结构如下</li>
</ol>
<p><a href="https://imgtu.com/i/R7RatO"><img src="https://z3.ax1x.com/2021/07/07/R7RatO.gif" alt="R7RatO.gif"></a></p>
<ol start="2">
<li>. 此时我们从最后一个非叶子结点开始（叶结点自然不用调整，第一个非叶子结点 arr.length/2-1=5/2-1=1，也就是下面的 6 结点），从左至右，从下至上进行调整。</li>
</ol>
<p><a href="https://imgtu.com/i/R7RdhD"><img src="https://z3.ax1x.com/2021/07/07/R7RdhD.gif" alt="R7RdhD.gif"></a></p>
<ol start="3">
<li>. 找到第二个非叶节点 4，由于 [4,9,8] 中 9 元素最大，4 和 9 交换。</li>
</ol>
<p><a href="https://imgtu.com/i/R7R09e"><img src="https://z3.ax1x.com/2021/07/07/R7R09e.gif" alt="R7R09e.gif"></a></p>
<ol start="4">
<li>这时，交换导致了子根 [4,5,6] 结构混乱，继续调整，[4,5,6] 中 6 最大，交换 4 和 6。</li>
</ol>
<p><a href="https://imgtu.com/i/R7RB1H"><img src="https://z3.ax1x.com/2021/07/07/R7RB1H.gif" alt="R7RB1H.gif"></a></p>
<p>此时，我们就将一个无序序列构造成了一个大顶堆。</p>
<p><strong>步骤二 将堆顶元素与末尾元素进行交换，使末尾元素最大。然后继续调整堆，再将堆顶元素与末尾元素交换，得到第二大元素。如此反复进行交换、重建、交换。</strong></p>
<ol>
<li>. 将堆顶元素 9 和末尾元素 4 进行交换</li>
</ol>
<p><a href="https://imgtu.com/i/R7R6Bt"><img src="https://z3.ax1x.com/2021/07/07/R7R6Bt.gif" alt="R7R6Bt.gif"></a></p>
<ol start="2">
<li>. 重新调整结构，使其继续满足堆定义</li>
</ol>
<p><a href="https://imgtu.com/i/R7R2Af"><img src="https://z3.ax1x.com/2021/07/07/R7R2Af.gif" alt="R7R2Af.gif"></a></p>
<ol start="3">
<li>. 再将堆顶元素 8 与末尾元素 5 进行交换，得到第二大元素 8.</li>
</ol>
<p><a href="https://imgtu.com/i/R7RRN8"><img src="https://z3.ax1x.com/2021/07/07/R7RRN8.gif" alt="R7RRN8.gif"></a>4) 后续过程，继续进行调整，交换，如此反复进行，最终使得整个序列有序</p>
<p><a href="https://imgtu.com/i/R7R43Q"><img src="https://z3.ax1x.com/2021/07/07/R7R43Q.gif" alt="R7R43Q.gif"></a></p>
<p><strong>再简单总结下堆排序的基本思路：</strong></p>
<p><strong>1). 将无序序列构建成一个堆，根据升序降序需求选择大顶堆或小顶堆；</strong></p>
<p><strong>2). 将堆顶元素与末尾元素交换，将最大元素 &quot;沉&quot; 到数组末端；</strong></p>
<p><strong>3). 重新调整结构，使其满足堆定义，然后继续交换堆顶元素与当前末尾元素，反复执行调整 + 交换步骤，直到整个序列有序。</strong></p>
<h3 id="代码展示"><a class="markdownIt-Anchor" href="#代码展示">#</a> 代码展示</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> demo06;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeapSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//要求将数组升序排序</span></span><br><span class="line">        <span class="keyword">int</span> arr[] = &#123;<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">5</span>,<span class="number">9</span>,-<span class="number">1</span>,<span class="number">44</span>,<span class="number">2</span>,<span class="number">7</span>&#125;;</span><br><span class="line"></span><br><span class="line">        heapSort(arr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//编写一个堆排序的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp=<span class="number">0</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;堆排序！！！&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//        分步完成</span></span><br><span class="line"><span class="comment">//        adjustHeap(arr,1,arr.length);</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;第一次&quot;+ Arrays.toString(arr));</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        adjustHeap(arr,0,arr.length);</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;第二次&quot;+ Arrays.toString(arr));</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//完成最终代码</span></span><br><span class="line">        <span class="comment">//1.将无序序列构建成一个堆，根据升序降序需求选择大顶堆或小顶堆</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = arr.length / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            adjustHeap(arr, i, arr.length);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.将堆顶元素与末尾交换，将最大元素 “沉” 到数组末端</span></span><br><span class="line">        <span class="comment">//3.重新调整结构，使其满足堆定义，然后继续交换堆顶元素与当前末尾元素，反复执行 2和3 两个步骤，直到整个序列有序</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = arr.length - <span class="number">1</span>; j &gt; <span class="number">0</span>; j--) &#123;</span><br><span class="line">            <span class="comment">//交换</span></span><br><span class="line">            temp=arr[j];</span><br><span class="line">            arr[j]=arr[<span class="number">0</span>];</span><br><span class="line">            arr[<span class="number">0</span>]=temp;</span><br><span class="line">            adjustHeap(arr,<span class="number">0</span>,j);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;数组=&quot;</span> + Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将一个数组（二叉树），调整成一个大顶堆</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 功能：完成 将以 i 指向的 i 对应的非叶子节点的树调整成大顶堆</span></span><br><span class="line"><span class="comment">     * 举例：int[] arr=&#123;4,6,8,5,9&#125; =&gt; i=1 =&gt; adjustHeap =&gt; 得到&#123;4,9,8,5,6&#125;</span></span><br><span class="line"><span class="comment">     * 如果我们再次调整 adjustHeap 传入的是 i=0 =&gt; 使 &#123;4,9,8,5,6&#125; =&gt; &#123;9,6,8,5,4 &#125;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr    待调整的数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i      表示非叶子节点在数组中的索引</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> length 表示对多少个元素进行调整，length 在逐渐的减小</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">adjustHeap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = arr[i];<span class="comment">//先取出当前元素的值，保存在临时变量</span></span><br><span class="line">        <span class="comment">//开始调整</span></span><br><span class="line">        <span class="comment">//说明</span></span><br><span class="line">        <span class="comment">//1. k=i*2+1  k是i的左子节点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = i * <span class="number">2</span> + <span class="number">1</span>; k &lt; length; k = k * <span class="number">2</span> + <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (k + <span class="number">1</span> &lt; length &amp;&amp; arr[k] &lt; arr[k + <span class="number">1</span>]) &#123;<span class="comment">//说明左子节点的值小于右子节点的值</span></span><br><span class="line">                k++; <span class="comment">//k指向 右子节点</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (arr[k] &gt; temp) &#123;  <span class="comment">//如果子节点大于父节点</span></span><br><span class="line">                arr[i] = arr[k]; <span class="comment">//把较大的值赋给当前节点</span></span><br><span class="line">                i = k;  <span class="comment">//!!!! i指向k 继续循环比较</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//当 for 循环结束后，我们已经将以 i 为父节点的树的最大值，放在了最顶（局部）</span></span><br><span class="line">        arr[i] = temp; <span class="comment">//将temp值放到调整后的位置</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="赫夫曼树"><a class="markdownIt-Anchor" href="#赫夫曼树">#</a> 赫夫曼树</h2>
<h3 id="基本介绍-2"><a class="markdownIt-Anchor" href="#基本介绍-2">#</a> 基本介绍</h3>
<ul>
<li>
<p>给定 n 个权值作为 n 个<a href="https://baike.baidu.com/item/%E5%8F%B6%E5%AD%90%E7%BB%93%E7%82%B9/3620239">叶子结点</a>，构造一棵二叉树，若该树的带权路径长度 (wpl) 达到最小，称这样的二叉树为<strong>最优二叉树</strong>，也称为<strong>哈夫曼树</strong> (Huffman Tree), 还有的书翻译为<strong>霍夫曼树</strong>。</p>
</li>
<li>
<p>赫夫曼树是带权路径长度最短的树，权值较大的结点离根较近。</p>
</li>
</ul>
<h3 id="几个概念"><a class="markdownIt-Anchor" href="#几个概念">#</a> 几个概念</h3>
<ul>
<li>
<p>路径和路径长度：在一棵树中，从一个结点往下可以达到的孩子或孙子结点之间的通路，称为路径。通路中分支的数目称为路径长度。若规定根结点的层数为 1，则从根结点到第 L 层结点的路径长度为 L-1</p>
</li>
<li>
<p>** 结点的权及带权路径长度：** 若将树中结点赋给一个有着某种含义的数值，则这个数值称为该结点的权。<strong>结点的带权路径长度</strong>为：从根结点到该结点之间的路径长度与该结点的权的乘积</p>
</li>
<li>
<p><strong>树的带权路径长度：<strong>树的带权路径长度规定为所有</strong>叶子结点</strong>的带权路径长度之和，记为 WPL (weighted path length) , 权值越大的结点离根结点越近的二叉树才是最优二叉树。</p>
</li>
<li>
<p><strong>WPL 最小的就是赫夫曼树</strong></p>
</li>
</ul>
<p><a href="https://imgtu.com/i/R7RTun"><img src="https://z3.ax1x.com/2021/07/07/R7RTun.png" alt="R7RTun.png"></a></p>
<h3 id="思路分析-2"><a class="markdownIt-Anchor" href="#思路分析-2">#</a> 思路分析</h3>
<p>构成赫夫曼树的步骤：</p>
<ul>
<li>
<p>从小到大进行排序，将每一个数据，每个数据都是一个节点 ， 每个节点可以看成是一颗最简单的二叉树</p>
</li>
<li>
<p>取出根节点权值最小的两颗二叉树</p>
</li>
<li>
<p>组成一颗新的二叉树，该新的二叉树的根节点的权值是前面两颗二叉树根节点权值的和</p>
</li>
<li>
<p>再将这颗新的二叉树，以根节点的权值大小 再次排序， 不断重复 1-2-3-4 的步骤，直到数列中，所有的数据都被处理，就得到一颗赫夫曼树</p>
</li>
</ul>
<p><a href="https://imgtu.com/i/R7R7Bq"><img src="https://z3.ax1x.com/2021/07/07/R7R7Bq.png" alt="R7R7Bq.png"></a></p>
<h3 id="代码分析"><a class="markdownIt-Anchor" href="#代码分析">#</a> 代码分析</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> demo01;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HuffmanTree</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">13</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">3</span>, <span class="number">29</span>, <span class="number">6</span>, <span class="number">1</span>&#125;;</span><br><span class="line">        Node root = createHuffmanTree(arr);</span><br><span class="line">        <span class="comment">//测试一把</span></span><br><span class="line">        preOrder(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(Node root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            root.preOrder();</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;该树为空树&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建赫夫曼树的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">createHuffmanTree</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//第一步为了操作方便</span></span><br><span class="line">        <span class="comment">//1.遍历 arr 数组</span></span><br><span class="line">        <span class="comment">//2.将 arr 的每个元素构成成一个Node</span></span><br><span class="line">        <span class="comment">//3.将 Node 放入到ArrayList中</span></span><br><span class="line">        List&lt;Node&gt; nodes = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> value : arr) &#123;</span><br><span class="line">            nodes.add(<span class="keyword">new</span> Node(value));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//我们处理的过程是一个循环的过程</span></span><br><span class="line">        <span class="keyword">while</span> (nodes.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">//排序 从小到大</span></span><br><span class="line">            Collections.sort(nodes);</span><br><span class="line">            System.out.println(nodes);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//取出根节点权值最小的两颗二叉树</span></span><br><span class="line">            <span class="comment">//(1) 取出权值最小的节点（二叉树）</span></span><br><span class="line">            Node leftNode = nodes.get(<span class="number">0</span>);</span><br><span class="line">            <span class="comment">//(1) 取出权值第二小的节点（二叉树）</span></span><br><span class="line">            Node rightNode = nodes.get(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//(3) 构建一颗新的二叉树</span></span><br><span class="line">            Node parent = <span class="keyword">new</span> Node(leftNode.value + rightNode.value);</span><br><span class="line">            parent.left = leftNode;</span><br><span class="line">            parent.right = rightNode;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//(4) 从ArrayList中删除处理过的二叉树</span></span><br><span class="line">            nodes.remove(leftNode);</span><br><span class="line">            nodes.remove(rightNode);</span><br><span class="line">            <span class="comment">//(5) 将parent 加入到nodes中</span></span><br><span class="line">            nodes.add(parent);</span><br><span class="line">            Collections.sort(nodes);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nodes.get(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建节点</span></span><br><span class="line"><span class="comment">//为了让Node 对象持续排序Collections集合排序</span></span><br><span class="line"><span class="comment">//让Node 实现Comparable 接口</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Node</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> value;   <span class="comment">//节点权值</span></span><br><span class="line">    Node left;   <span class="comment">//指向左子节点</span></span><br><span class="line">    Node right;  <span class="comment">//指向右子节点、</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Node&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;value=&quot;</span> + value +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Node o)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//升序 从小到大</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.value - o.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//写一个前序遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">this</span>.left.preOrder();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">this</span>.right.preOrder();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="赫夫曼编码"><a class="markdownIt-Anchor" href="#赫夫曼编码">#</a> 赫夫曼编码</h2>
<h3 id="基本介绍-3"><a class="markdownIt-Anchor" href="#基本介绍-3">#</a> 基本介绍</h3>
<ul>
<li>赫夫曼编码也叫哈夫曼编码又称霍夫曼编码，是一种编码方式，属于一种程序算法</li>
<li>赫夫曼编码是赫哈夫曼树在电讯通信中的经典的应用之一</li>
<li>赫夫曼编码广泛地用于数据文件压缩。其 ** 压缩率通常在 20%～90%** 之间</li>
<li>赫夫曼码是可变<a href="https://baike.baidu.com/item/%E5%AD%97%E9%95%BF/97660">字长</a>编码 (VLC) 的一种。Huffman 于 1952 年提出一种编码方法，称之为最佳编码</li>
</ul>
<h3 id="原理剖析"><a class="markdownIt-Anchor" href="#原理剖析">#</a> 原理剖析</h3>
<h4 id="1-定长编码"><a class="markdownIt-Anchor" href="#1-定长编码">#</a> 1、定长编码</h4>
<ul>
<li>
<p>i like like like java do you like a java    // 共 40 个字符 (包括空格) 《转换成 ACSII 码》</p>
</li>
<li>
<p>105 32 108 105 107 101 32 108 105 107 101 32 108 105 107 101 32 106 97 118 97 32 100 111 32 121 111 117 32 108 105 107 101 32 97 32 106 97 118 97 // 对应 Ascii 码</p>
</li>
<li>
<p>01101001 00100000 01101100 01101001 01101011 01100101 00100000 01101100 01101001 01101011 01100101 00100000 01101100 01101001 01101011 01100101 00100000 01101010 01100001 01110110 01100001 00100000 01100100 01101111 00100000 01111001 01101111 01110101 00100000 01101100 01101001 01101011 01100101 00100000 01100001 00100000 01101010 01100001 01110110 01100001 // 对应的二进制</p>
</li>
<li>
<p>按照二进制来传递信息，总的长度是 359  (包括空格)</p>
</li>
<li>
<p>在线转码 工具 ：<a href="https://www.mokuge.com/tool/asciito16/">https://www.mokuge.com/tool/asciito16/</a></p>
</li>
</ul>
<h4 id="2-变长编码"><a class="markdownIt-Anchor" href="#2-变长编码">#</a> 2、变长编码</h4>
<ul>
<li>
<p>i like like like java do you like a java    // 共 40 个字符 (包括空格)</p>
</li>
<li>
<p>d:1 y:1 u:1 j:2 v:2 o:2 l:4 k:4 e:4 i:5 a:5  :9 // 各个字符对应的个数</p>
</li>
<li>
<p>0=(空格)  , 1=a, 10=i, 11=e, 100=k, 101=l, 110=o, 111=v, 1000=j, 1001=u, 1010=y, 1011=d<br>
 说明：按照各个字符出现的次数进行编码，原则是出现次数越多的，则编码越小，比如 空格出现了 9 次， 编码为 0 , 其它依次类推.</p>
</li>
<li>
<p>按照上面给各个字符规定的编码，则我们在传输 “i like like like java do you like a java” 数据时，编码就是<br>
 10010110100…</p>
</li>
<li>
<p>字符的编码都不能是其他字符编码的前缀，符合此要求的编码叫做前缀编码， 即不能匹配到重复的编码</p>
</li>
</ul>
<h4 id="3-赫夫曼编码"><a class="markdownIt-Anchor" href="#3-赫夫曼编码">#</a> 3、赫夫曼编码</h4>
<ol>
<li>
<p>传输的字符串  i like like like java do you like a java</p>
</li>
<li>
<p>d:1、y:1、u:1、j:2、v:2、o:2、l:4、k:4、e:4、i:5、a:5、(空格):9 // 各个字符对应的个数</p>
</li>
<li>
<p>按照上面字符出现的次数构建一颗赫夫曼树，次数作为权值</p>
<ul>
<li>
<p>构成赫夫曼树的步骤：</p>
</li>
<li>
<p>从小到大进行排序，将每一个数据，每个数据都是一个节点 ， 每个节点可以看成是一颗最简单的二叉树</p>
</li>
<li>
<p>取出根节点权值最小的两颗二叉树</p>
</li>
<li>
<p>组成一颗新的二叉树，该新的二叉树的根节点的权值是前面两颗二叉树根节点权值的和</p>
</li>
<li>
<p>再将这颗新的二叉树，以根节点的权值大小 再次排序， 不断重复 1-2-3-4 的步骤，直到数列中，所有的数据都被处理，就得到一颗赫夫曼树</p>
</li>
</ul>
</li>
</ol>
<p><a href="https://imgtu.com/i/R7RqEV"><img src="https://z3.ax1x.com/2021/07/07/R7RqEV.png" alt="R7RqEV.png"></a></p>
<ol start="4">
<li>
<p>根据赫夫曼树，给各个字符，规定编码 (前缀编码)， 向左的路径为 0 向右的路径为 1 ， 编码如下:</p>
<p>o: 1000  u: 10010   d: 100110   y: 100111    i: 101     a : 110      k: 1110     e: 1111</p>
<p>j: 0000    v: 0001     l: 001         (空格) : 01</p>
</li>
<li>
<p>按照上面的赫夫曼编码，我们的 &quot;i like like like java do you like a java&quot;  字符串对应的编码为 (注意这里我们使用的无损压缩)</p>
<p><strong>101</strong>0100110111101111010011011110111101001101111011110100001100001110011001111000011001111000100100100110111101111011100100001100001110 通过赫夫曼编码处理 长度为 133</p>
</li>
<li>
<p>长度为 ： 133</p>
</li>
</ol>
<p><strong>说明：原来长度是 359 , 压缩了 (359-133) / 359 = 62.9%</strong></p>
<p><strong>此编码满足前缀编码，即字符的编码都不能是其他字符编码的前缀。不会造成匹配的多义性</strong></p>
<p><strong>赫夫曼编码是无损处理方案</strong></p>
<p>注：这个赫夫曼树根据排序方法不同，也可能不太一样，<strong>这样对应的赫夫曼编码也不完全一样</strong>，但是 wpl 是一样的，都是最小的，最后生成的赫夫曼编码的长度是一样的。比如：如果我们让每次生成的新的二叉树总是排在权值相同的二叉树的最后一个，则生成的二叉树为:</p>
<p><a href="https://imgtu.com/i/R7Rv34"><img src="https://z3.ax1x.com/2021/07/07/R7Rv34.png" alt="R7Rv34.png"></a></p>
<h2 id="赫夫曼树的应用"><a class="markdownIt-Anchor" href="#赫夫曼树的应用">#</a> 赫夫曼树的应用</h2>
<h3 id="实践操作"><a class="markdownIt-Anchor" href="#实践操作">#</a> 实践操作</h3>
<p><strong>数据压缩 (生成赫夫曼树)</strong>、</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">将给出的一段文本，比如 &quot;i like like like java do you like a java&quot; ， 根据前面的讲的赫夫曼编码原理，对其进行数据压缩处理 ，形式如 &quot;1010100110111101111010011011110111101001101111011110100001100001110011001111000011001111000100100100110111101111011100100001100001110</span><br><span class="line">&quot; </span><br><span class="line">步骤1：根据赫夫曼编码压缩数据的原理，需要创建 &quot;i like like like java do you like a java&quot; 对应的赫夫曼树.</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>数据压缩 (生成赫夫曼编码和赫夫曼编码后的数据)</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">我们已经生成了 赫夫曼树, 下面我们继续完成任务</span><br><span class="line">  1.生成赫夫曼树对应的赫夫曼编码  , 如下表:=01 a=100 d=11000 u=11001 e=1110 v=11011 i=101 y=11010 j=0010 k=1111 l=000 o=0011</span><br><span class="line">  2.使用赫夫曼编码来生成赫夫曼编码数据 ,即按照上面的赫夫曼编码，将&quot;i like like like java do you like a java&quot;   字符串生成对应的编码数据, 形式下.</span><br><span class="line">  1010100010111111110010001011111111001000101111111100100101001101110001110000011011101000111100101000101111111100110001001010011011100</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>数据解压 (使用赫夫曼编码解码)</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">使用赫夫曼编码来解码数据，具体要求是</span><br><span class="line">  1.前面我们得到了赫夫曼编码和对应的编码</span><br><span class="line">byte[] , 即:[-88, -65, -56, -65, -56, -65, -55, 77, -57, 6, -24, -14, -117, -4, -60, -90, 28]</span><br><span class="line">  2.现在要求使用赫夫曼编码， 进行解码，又重新得到原来的字符串&quot;i like like like java do you like a java&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>文件压缩</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">读取文件-&gt; 得到赫夫曼编码表 -&gt; 完成压缩</span><br></pre></td></tr></table></figure>
<p><strong>文件解压</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">读取压缩文件(数据和赫夫曼编码表)-&gt; 完成解压(文件恢复)</span><br></pre></td></tr></table></figure>
<p><strong>注意事项</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.如果文件本身就是经过压缩处理的，那么使用赫夫曼编码再压缩效率不会有明显变化, 比如视频,ppt 等等文件 </span><br><span class="line">2.赫夫曼编码是按字节来处理的，因此可以处理所有的文件(二进制文件、文本文件) </span><br><span class="line">3.如果一个文件中的内容，重复的数据不多，压缩效果也不会很明显. </span><br></pre></td></tr></table></figure>
<h3 id="代码实现"><a class="markdownIt-Anchor" href="#代码实现">#</a> 代码实现</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> demo01;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HuffmanCode</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        String content = &quot;i like like like java do you like a java&quot;;</span></span><br><span class="line"><span class="comment">        byte[] contentBytes = content.getBytes();</span></span><br><span class="line"><span class="comment">        System.out.println(contentBytes.length); //40</span></span><br><span class="line"><span class="comment">        //编码</span></span><br><span class="line"><span class="comment">        byte[] huffmanZipBytes = huffmanZip(contentBytes);</span></span><br><span class="line"><span class="comment">        System.out.println(Arrays.toString(huffmanZipBytes));</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        //如何将数据进行解压（解码）</span></span><br><span class="line"><span class="comment">        byte[] sourceBytes = decode(huffmanCodes, huffmanZipBytes);</span></span><br><span class="line"><span class="comment">        System.out.println(&quot;原来的字符串=&quot; + new String(sourceBytes));</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        //测试压缩文件</span></span><br><span class="line"><span class="comment">        String srcFile=&quot;F:\\alphonse.jpg&quot;;</span></span><br><span class="line"><span class="comment">        String dstFile=&quot;F:\\alphonse.zip&quot;;</span></span><br><span class="line"><span class="comment">        zipFile(srcFile,dstFile);</span></span><br><span class="line"><span class="comment">        System.out.println(&quot;压缩成功~~&quot;);</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//测试解压文件</span></span><br><span class="line">        String zipFile=<span class="string">&quot;F:\\alphonse.zip&quot;</span>;</span><br><span class="line">        String dstFile=<span class="string">&quot;F:\\alphonse1.jpg&quot;</span>;</span><br><span class="line">        unZipFile(zipFile,dstFile);</span><br><span class="line">        System.out.println(<span class="string">&quot;解压成功~~&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//编写一个方法,将一个文件进行压缩</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">zipFile</span><span class="params">(String srcFile, String dstFile)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建输出流</span></span><br><span class="line">        FileOutputStream os = <span class="keyword">null</span>;</span><br><span class="line">        ObjectOutputStream oos = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//创建文件的输入流</span></span><br><span class="line">        FileInputStream is = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            is = <span class="keyword">new</span> FileInputStream(srcFile);</span><br><span class="line">            <span class="comment">//创建一个和源文件大小一样的byte[]</span></span><br><span class="line">            <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[is.available()];</span><br><span class="line">            <span class="comment">//读取文件</span></span><br><span class="line">            is.read(b);</span><br><span class="line">            <span class="comment">//直接对源文件压缩</span></span><br><span class="line">            <span class="keyword">byte</span>[] huffmanZipBytes = huffmanZip(b);</span><br><span class="line">            <span class="comment">//创建文件的输出流，存放压缩文件</span></span><br><span class="line">            os = <span class="keyword">new</span> FileOutputStream(dstFile);</span><br><span class="line">            <span class="comment">//创建一个和文件输出流关联的ObjectOutputStream</span></span><br><span class="line">            oos = <span class="keyword">new</span> ObjectOutputStream(os);</span><br><span class="line">            <span class="comment">//把 赫夫曼编码后的字节数组写入压缩文件</span></span><br><span class="line">            oos.writeObject(huffmanZipBytes);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//这里我们以对象流的方式写入赫夫曼编码，是为了以后我们恢复源文件时使用</span></span><br><span class="line">            <span class="comment">//注意：一定要把赫夫曼编码写入压缩文件</span></span><br><span class="line">            oos.writeObject(huffmanCodes);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                is.close();</span><br><span class="line">                oos.close();</span><br><span class="line">                os.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//编写一个方法，对压缩文件解压</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> zipFile 准备解压的文件</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> dstFile 将文件解压到那个路径</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">unZipFile</span><span class="params">(String zipFile,String dstFile)</span></span>&#123;</span><br><span class="line">        <span class="comment">//定义文件的输入流</span></span><br><span class="line">        InputStream is =<span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//定义一个对象输入流</span></span><br><span class="line">        ObjectInputStream ois=<span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//定义文件的输出流</span></span><br><span class="line">        OutputStream os=<span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//创建文件输入流</span></span><br><span class="line">            is=<span class="keyword">new</span> FileInputStream(zipFile);</span><br><span class="line">            <span class="comment">//创建一个和 is 关联的对象输入流</span></span><br><span class="line">            ois = <span class="keyword">new</span> ObjectInputStream(is);</span><br><span class="line">            <span class="comment">//读取byte数组到huffmanBytes</span></span><br><span class="line">            <span class="keyword">byte</span>[] huffmanBytes=(<span class="keyword">byte</span>[])ois.readObject();</span><br><span class="line">            <span class="comment">//读取赫夫曼编码表</span></span><br><span class="line">            Map&lt;Byte,String&gt; huffmanCodes=(Map&lt;Byte,String&gt;)ois.readObject();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//解码</span></span><br><span class="line">            <span class="keyword">byte</span>[] decode = decode(huffmanCodes, huffmanBytes);</span><br><span class="line">            <span class="comment">//将bytes 数组写入到目标文件</span></span><br><span class="line">            os=<span class="keyword">new</span> FileOutputStream(dstFile);</span><br><span class="line">            <span class="comment">//写出数据到文件中</span></span><br><span class="line">            os.write(decode);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                os.close();</span><br><span class="line">                ois.close();</span><br><span class="line">                is.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//完成数据的解压</span></span><br><span class="line">    <span class="comment">//思路</span></span><br><span class="line">    <span class="comment">//1.将 [-88, -65, -56, -65, -56, -65, -55, 77, -57, 6, -24, -14, -117, -4, -60, -90, 28]</span></span><br><span class="line">    <span class="comment">//     先转成赫夫曼编码对应的二进制字符串&quot;101010011011110111101001101111011 ...&quot;</span></span><br><span class="line">    <span class="comment">//2.赫夫曼编码对应的二进制的字符串&quot;1010100110111101111010 ... &quot; =&gt; 对照 赫夫曼编码重新转成字符串 =&gt; &quot;i like like like java do you like a java&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将 一个byte 转成 一个二进制字符串</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> b 传入的byte</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回的是该 b 对应的二进制的字符串，（注意是按补码返回）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Param</span> flag 标志是否需要补高位，如果是true 表示需要补高位，如果是false 表示不补</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">byteToBitString</span><span class="params">(<span class="keyword">boolean</span> flag, <span class="keyword">byte</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//使用变量保存 b</span></span><br><span class="line">        <span class="keyword">int</span> temp = b;<span class="comment">//将 b 转成 int类型</span></span><br><span class="line">        <span class="comment">//如果是正数，我们还需要补高位</span></span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">            temp = temp | <span class="number">256</span>; <span class="comment">// 按位与256 1 0000 0000 | 0000 0001 =&gt; 1 0000 0001</span></span><br><span class="line">        &#125;</span><br><span class="line">        String str = Integer.toBinaryString(temp); <span class="comment">//返回的是 temp 对应的二进制的补码</span></span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">            <span class="keyword">return</span> str.substring(str.length() - <span class="number">8</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> str;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 编写一个方法，完成对压缩数据的解码</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> huffmanCodes 赫夫曼编码表 map</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> huffmanBytes 赫夫曼编码得到的字节数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 就是原来的字符串对应的数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] decode(Map&lt;Byte, String&gt; huffmanCodes, <span class="keyword">byte</span>[] huffmanBytes) &#123;</span><br><span class="line">        <span class="comment">//1.先得到 huffmanBytes 对应的二进制的字符串，如 1010100110111101111010 ...</span></span><br><span class="line">        StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="comment">//将byte数组转成二进制的字符串</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; huffmanBytes.length; i++) &#123;</span><br><span class="line">            <span class="keyword">byte</span> b = huffmanBytes[i];</span><br><span class="line">            <span class="comment">//判断是不是最后一个字节</span></span><br><span class="line">            <span class="keyword">boolean</span> flag = (i == huffmanBytes.length - <span class="number">1</span>);</span><br><span class="line">            stringBuilder.append(byteToBitString(!flag, b));</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(stringBuilder.toString());</span><br><span class="line">        <span class="comment">//把字符串按照指定的赫夫曼编码进行解码</span></span><br><span class="line">        <span class="comment">//把赫夫曼编码表进行调换，因为反向查询 a-&gt;100   100-&gt;a</span></span><br><span class="line">        Map&lt;String, Byte&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Byte, String&gt; entry : huffmanCodes.entrySet()) &#123;</span><br><span class="line">            map.put(entry.getValue(), entry.getKey());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建一个集合，存放byte</span></span><br><span class="line">        List&lt;Byte&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">//i 可以理解为索引,扫描 stringBuilder</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; stringBuilder.length(); ) &#123;</span><br><span class="line">            <span class="keyword">int</span> count = <span class="number">1</span>; <span class="comment">//小的计数器</span></span><br><span class="line">            <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">            Byte b = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">while</span> (flag) &#123;</span><br><span class="line">                <span class="comment">//1010100010111111110010001 ...</span></span><br><span class="line">                <span class="comment">//递增取出一个 &#x27;1&#x27;或&#x27;0&#x27;</span></span><br><span class="line">                String key = stringBuilder.substring(i, i + count); <span class="comment">// i不动，让count移动，指定匹配一个字符</span></span><br><span class="line">                b = map.get(key);</span><br><span class="line">                <span class="keyword">if</span> (b == <span class="keyword">null</span>) &#123;<span class="comment">//没有匹配到</span></span><br><span class="line">                    count++;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//匹配到</span></span><br><span class="line">                    flag = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            list.add(b);</span><br><span class="line">            i += count; <span class="comment">//让 i 直接移动到count位置</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//当for循环结束后，我们list中就存放了所有的字符</span></span><br><span class="line">        <span class="comment">//把list中的数据放到byte[] 并返回</span></span><br><span class="line">        <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[list.size()];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; b.length; i++) &#123;</span><br><span class="line">            b[i] = list.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用一个方法将前面的方法封装起来，便于调用</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> bytes 原始的字符串对应的字节数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 是经过 赫夫曼编码处理后的字节数组（压缩后的数组）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] huffmanZip(<span class="keyword">byte</span>[] bytes) &#123;</span><br><span class="line">        List&lt;Node&gt; nodes = getNodes(bytes);</span><br><span class="line">        <span class="comment">//根据 nodes 创建赫夫曼树</span></span><br><span class="line">        Node huffmanTreeRoot = createHuffmanTree(nodes);</span><br><span class="line">        <span class="comment">//根据赫夫曼树创建对应的 赫夫曼编码</span></span><br><span class="line">        Map&lt;Byte, String&gt; huffmanCodes = getCodes(huffmanTreeRoot);</span><br><span class="line">        <span class="comment">//根据生成的赫夫曼编码，压缩得到压缩后的赫夫曼编码字节数组</span></span><br><span class="line">        <span class="keyword">byte</span>[] huffmanCodeBytes = zip(bytes, huffmanCodes);</span><br><span class="line">        <span class="keyword">return</span> huffmanCodeBytes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//编写一个方法，将字符串对应的byte[] 数组，通过生成的赫夫曼编码表，返回一个赫夫曼编码压缩后的byte[]</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 例如：String content=&quot;i like like like java do you like a java&quot;; =》 byte[] contentBytes=content.getBytes();</span></span><br><span class="line"><span class="comment">     * 返回的是字符串 &quot;1010100110111101111010011011110111101001101111011110100001100001110011001111000011001111000100100100110111101111011100100001100001110&quot;</span></span><br><span class="line"><span class="comment">     * =&gt; 对应的byte[] huffmanCodeBytes,即8位对应一个byte，放入到huffmanCodeBytes</span></span><br><span class="line"><span class="comment">     * huffmanCodeBytes[0] = 10101001(补码) =&gt; byte [推导 10101001 =》 10101001 -1 =》10101000(反码) =》(符号位不变，其他为取反)11010111 = - 88]  第一位为符号位：0为正，1为负</span></span><br><span class="line"><span class="comment">     * huffmanCodeBytes[1] =-88</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> bytes        这是原始的字符串对应的byte[]</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> huffmanCodes huffmanCodes 生成的赫夫曼编码 map</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回赫夫曼编码处理后的byte[]</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] zip(<span class="keyword">byte</span>[] bytes, Map&lt;Byte, String&gt; huffmanCodes) &#123;</span><br><span class="line">        <span class="comment">//1.利用huffmanCodes 将 bytes 转成 赫夫曼编码对应的字符串</span></span><br><span class="line">        StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="comment">//遍历 bytes 数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">byte</span> b : bytes) &#123;</span><br><span class="line">            stringBuilder.append(huffmanCodes.get(b));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;测试 stringBuilder=&quot;</span> + stringBuilder.toString());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将 &quot;1010100110111101111010011011110 ... &quot;转成 byte[]</span></span><br><span class="line">        <span class="comment">//统计返回 byte[] huffmanCodes</span></span><br><span class="line">        <span class="comment">//一句话 int len = (stringBuilder.length() + 7)/8;</span></span><br><span class="line">        <span class="keyword">int</span> len;</span><br><span class="line">        <span class="keyword">if</span> (stringBuilder.length() % <span class="number">8</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            len = stringBuilder.length() / <span class="number">8</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            len = stringBuilder.length() / <span class="number">8</span> + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">byte</span>[] huffmanCodeBytes = <span class="keyword">new</span> <span class="keyword">byte</span>[len];</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;<span class="comment">//记录是第几个 byte</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; stringBuilder.length(); i += <span class="number">8</span>) &#123; <span class="comment">//因为是霉每8位对应一个byte，所以步长+8</span></span><br><span class="line">            String strByte;</span><br><span class="line">            <span class="keyword">if</span> (i + <span class="number">8</span> &gt; stringBuilder.length()) &#123;</span><br><span class="line">                strByte = stringBuilder.substring(i);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                strByte = stringBuilder.substring(i, i + <span class="number">8</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//将 strByte 转成一个byte放入到HuffmanCodeBytes</span></span><br><span class="line">            huffmanCodeBytes[index] = (<span class="keyword">byte</span>) Integer.parseInt(strByte, <span class="number">2</span>);</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> huffmanCodeBytes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//生成赫夫曼树对应的赫夫曼编码</span></span><br><span class="line">    <span class="comment">//思路</span></span><br><span class="line">    <span class="comment">//1.将赫夫曼编码表存放在 Map&lt;Byte,String&gt; 中形式</span></span><br><span class="line">    <span class="comment">//   &#123;32=01, 97=100, 100=11000, 117=11001, 101=1110, 118=11011, 105=101, 121=11010, 106=0010, 107=1111, 108=000, 111=0011&#125;</span></span><br><span class="line">    <span class="keyword">static</span> Map&lt;Byte, String&gt; huffmanCodes = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="comment">//2.在生成赫夫曼编码表时，需要拼接路径，定义一个StringBuild 存储某个叶子节点的路径</span></span><br><span class="line">    <span class="keyword">static</span> StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//为了调用方便，重载getCodes</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Map&lt;Byte, String&gt; <span class="title">getCodes</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//处理root的左子树</span></span><br><span class="line">        getCodes(root.left, <span class="string">&quot;0&quot;</span>, stringBuilder);</span><br><span class="line">        <span class="comment">//处理root的右子树</span></span><br><span class="line">        getCodes(root.right, <span class="string">&quot;1&quot;</span>, stringBuilder);</span><br><span class="line">        <span class="keyword">return</span> huffmanCodes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 功能：将传入的node节点的所有叶子节点的赫夫曼编码得到，并放入到HuffmanCode集合</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node          传入节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> code          路径：左子节点是 0，右子节点是 1</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> stringBuilder 用于拼接路径</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getCodes</span><span class="params">(Node node, String code, StringBuilder stringBuilder)</span> </span>&#123;</span><br><span class="line">        StringBuilder stringBuilder2 = <span class="keyword">new</span> StringBuilder(stringBuilder);</span><br><span class="line">        <span class="comment">//将code加入到stringBuilder2</span></span><br><span class="line">        stringBuilder2.append(code);</span><br><span class="line">        <span class="keyword">if</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//如果node等于null，不处理</span></span><br><span class="line">            <span class="comment">//判断当前node，是叶子节点还是非叶子节点</span></span><br><span class="line">            <span class="keyword">if</span> (node.data == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//递归处理</span></span><br><span class="line">                <span class="comment">//向左递归</span></span><br><span class="line">                getCodes(node.left, <span class="string">&quot;0&quot;</span>, stringBuilder2);</span><br><span class="line">                <span class="comment">//向右递归</span></span><br><span class="line">                getCodes(node.right, <span class="string">&quot;1&quot;</span>, stringBuilder2);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//说明是一个叶子结点</span></span><br><span class="line">                <span class="comment">//就表示找到某个叶子结点的最后</span></span><br><span class="line">                huffmanCodes.put(node.data, stringBuilder2.toString());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//前序遍历的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">            root.preOrder();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;赫夫曼树为空&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> bytes 接收字节数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回的是List  [Node&#123;data=32, weight=9&#125;, Node&#123;data=97, weight=5&#125;, ....]</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> List&lt;Node&gt; <span class="title">getNodes</span><span class="params">(<span class="keyword">byte</span>[] bytes)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1.创建一个ArrayList</span></span><br><span class="line">        ArrayList&lt;Node&gt; nodes = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">//2.遍历bytes,统计每一个bytes出现的次数 -&gt; map[key,value]</span></span><br><span class="line">        Map&lt;Byte, Integer&gt; counts = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">byte</span> b : bytes) &#123;</span><br><span class="line">            Integer count = counts.get(b);</span><br><span class="line">            <span class="keyword">if</span> (count == <span class="keyword">null</span>) &#123;<span class="comment">//此时，Map中还没有这个字符数据，第一次存放该数据</span></span><br><span class="line">                counts.put(b, <span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                counts.put(b, count + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//把每个键值对转成一个Node 对象，并加入到nodes集合中</span></span><br><span class="line">        <span class="comment">//遍历map</span></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Byte, Integer&gt; entry : counts.entrySet()) &#123;</span><br><span class="line">            nodes.add(<span class="keyword">new</span> Node(entry.getKey(), entry.getValue()));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nodes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过List 创建赫夫曼树</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Node <span class="title">createHuffmanTree</span><span class="params">(List&lt;Node&gt; nodes)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (nodes.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">//排序,从小到大</span></span><br><span class="line">            Collections.sort(nodes);</span><br><span class="line">            <span class="comment">//取出第一颗最小的二叉树</span></span><br><span class="line">            Node leftNode = nodes.get(<span class="number">0</span>);</span><br><span class="line">            Node rightNode = nodes.get(<span class="number">1</span>);</span><br><span class="line">            <span class="comment">//创建一棵新的二叉树，他的根节点没有data，只有权值</span></span><br><span class="line">            Node parent = <span class="keyword">new</span> Node(<span class="keyword">null</span>, leftNode.weight + rightNode.weight);</span><br><span class="line">            parent.left = leftNode;</span><br><span class="line">            parent.right = rightNode;</span><br><span class="line">            <span class="comment">//将已经处理的两颗二叉树从nodes 中删除</span></span><br><span class="line">            nodes.remove(leftNode);</span><br><span class="line">            nodes.remove(rightNode);</span><br><span class="line">            <span class="comment">//将新的节点，加入到nodes 中</span></span><br><span class="line">            nodes.add(parent);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//nodes 最后的节点解释赫夫曼树的根节点</span></span><br><span class="line">        <span class="keyword">return</span> nodes.get(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建Node，带数据和权值</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Node</span>&gt; </span>&#123;</span><br><span class="line">    Byte data; <span class="comment">//存放数据，比如&#x27;a&#x27; =&gt; 97, &#x27; &#x27;=&gt; 32</span></span><br><span class="line">    <span class="keyword">int</span> weight; <span class="comment">//存放权值,表示字符出现的次数</span></span><br><span class="line">    Node left;</span><br><span class="line">    Node right;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(Byte data, <span class="keyword">int</span> weight)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">        <span class="keyword">this</span>.weight = weight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Node o)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//从小到大排序</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.weight - o.weight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Node&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;data=&quot;</span> + data +</span><br><span class="line">                <span class="string">&quot;, weight=&quot;</span> + weight +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.left.preOrder();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.right.preOrder();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="二叉排序树"><a class="markdownIt-Anchor" href="#二叉排序树">#</a> 二叉排序树</h2>
<h3 id="需求分析"><a class="markdownIt-Anchor" href="#需求分析">#</a> 需求分析</h3>
<p>问题：给你一个数列 (7, 3, 10, 12, 5, 1, 9)，要求能够高效的完成对数据的查询和添加</p>
<h3 id="解决方案"><a class="markdownIt-Anchor" href="#解决方案">#</a> 解决方案</h3>
<p><strong>Ø 使用数组</strong></p>
<ol>
<li>
<p>数组未排序， 优点：直接在数组尾添加，速度快。 缺点：查找速度慢. [示意图]</p>
</li>
<li>
<p>数组排序，优点：可以使用二分查找，查找速度快，缺点：为了保证数组有序，在添加新数据时，找到插入位置后，后面的数据需整体移动，速度慢。[示意图]</p>
</li>
</ol>
<p><strong>Ø 使用链式存储 - 链表</strong></p>
<ul>
<li>不管链表是否有序，查找速度都慢，添加数据速度比数组快，不需要数据整体移动。[示意图]</li>
</ul>
<h3 id="简单介绍"><a class="markdownIt-Anchor" href="#简单介绍">#</a> 简单介绍</h3>
<p>二叉排序树：BST: (Binary Sort (Search) Tree), 对于二叉排序树的任何一个非叶子节点，要求左子节点的值比当前节点的值小，右子节点的值比当前节点的值大。</p>
<p><strong>特别说明</strong>：如果有相同的值，可以将该节点放在左子节点或右子节点</p>
<p>比如针对前面的数据 (7, 3, 10, 12, 5, 1, 9) ，对应的二叉排序树为：</p>
<p><a href="https://imgtu.com/i/R7WpuR"><img src="https://z3.ax1x.com/2021/07/07/R7WpuR.png" alt="R7WpuR.png"></a></p>
<h3 id="二叉排序树的创建和遍历"><a class="markdownIt-Anchor" href="#二叉排序树的创建和遍历">#</a> 二叉排序树的创建和遍历</h3>
<p><a href="https://imgtu.com/i/R7WCHx"><img src="https://z3.ax1x.com/2021/07/07/R7WCHx.png" alt="R7WCHx.png"></a></p>
<h3 id="二叉排序树的删除"><a class="markdownIt-Anchor" href="#二叉排序树的删除">#</a> 二叉排序树的删除</h3>
<p>二叉排序树的删除情况比较复杂，有下面三种情况需要考虑三种情况：</p>
<p><a href="https://imgtu.com/i/R7WFUK"><img src="https://z3.ax1x.com/2021/07/07/R7WFUK.png" alt="R7WFUK.png"></a></p>
<ul>
<li>
<p>第一种情况:</p>
<ul>
<li>
<p>删除叶子节点 (比如：2, 5, 9, 12)</p>
</li>
<li>
<p>思路</p>
</li>
<li>
<p>(1) 需求先去找到要删除的结点 targetNode</p>
</li>
<li>
<p>(2) 找到 targetNode 的 父结点 parent</p>
</li>
<li>
<p>(3) 确定 targetNode 是 parent 的左子结点 还是右子结点</p>
</li>
<li>
<p>(4) 根据前面的情况来对应删除</p>
</li>
<li>
<p>左子结点 parent.left = null</p>
</li>
<li>
<p>右子结点 parent.right = null;</p>
</li>
</ul>
</li>
<li>
<p>第二种情况: <strong>删除只有一颗子树的节点</strong> <strong>比如</strong> <strong>1</strong></p>
<ul>
<li>
<p>思路</p>
</li>
<li>
<p>(1) 需求先去找到要删除的结点 targetNode</p>
</li>
<li>
<p>(2) 找到 targetNode 的 父结点 parent</p>
</li>
<li>
<p>(3) 确定 targetNode 的子结点是左子结点还是右子结点</p>
</li>
<li>
<p>(4) targetNode 是 parent 的左子结点还是右子结点</p>
</li>
<li>
<p>(5) 如果 targetNode 有左子结点</p>
</li>
<li>
<p>5.1 如果 targetNode 是 parent 的左子结点</p>
</li>
<li>
<p>parent.left = targetNode.left;</p>
</li>
<li>
<p>5.2 如果 targetNode 是 parent 的右子结点</p>
</li>
<li>
<p>parent.right = targetNode.left;</p>
</li>
<li>
<p>(6) 如果 targetNode 有右子结点</p>
</li>
<li>
<p>6.1 如果 targetNode 是 parent 的左子结点</p>
</li>
<li>
<p>parent.left = targetNode.right;</p>
</li>
<li>
<p>6.2 如果 targetNode 是 parent 的右子结点</p>
</li>
<li>
<p>parent.right = targetNode.right</p>
</li>
</ul>
</li>
<li>
<p>情况三 ： 删除有两颗子树的节点. (比如：7, 3，<strong>10</strong> )</p>
<ul>
<li>
<p>思路</p>
</li>
<li>
<p>(1) 需求先去找到要删除的结点 targetNode</p>
</li>
<li>
<p>(2) 找到 targetNode 的 父结点 parent</p>
</li>
<li>
<p>(3) 从 targetNode 的右子树找到最小的结点</p>
</li>
<li>
<p>(4) 用一个临时变量，将 最小结点的值保存 temp = 11</p>
</li>
<li>
<p>(5) 删除该最小结点</p>
</li>
<li>
<p>(6) targetNode.value = temp</p>
</li>
</ul>
</li>
</ul>
<h3 id="代码展示-2"><a class="markdownIt-Anchor" href="#代码展示-2">#</a> 代码展示</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> demo01;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinarySortTreeDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">7</span>, <span class="number">3</span>, <span class="number">10</span>, <span class="number">12</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">9</span>, <span class="number">2</span>&#125;;</span><br><span class="line">        BinarySortTree binarySortTree = <span class="keyword">new</span> BinarySortTree();</span><br><span class="line">        <span class="comment">//循环的添加结点到二叉排序树</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            binarySortTree.add(<span class="keyword">new</span> Node(arr[i]));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//中序遍历二叉排序树</span></span><br><span class="line">        binarySortTree.infixOrder();<span class="comment">//1 3 5 7 9 10 12</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//测试删除叶子结点</span></span><br><span class="line">        binarySortTree.delNode(<span class="number">2</span>);</span><br><span class="line">        binarySortTree.delNode(<span class="number">5</span>);</span><br><span class="line">        binarySortTree.delNode(<span class="number">9</span>);</span><br><span class="line">        binarySortTree.delNode(<span class="number">2</span>);</span><br><span class="line">        binarySortTree.delNode(<span class="number">12</span>);</span><br><span class="line">        binarySortTree.delNode(<span class="number">7</span>);</span><br><span class="line">        binarySortTree.delNode(<span class="number">3</span>);</span><br><span class="line">        <span class="comment">//binarySortTree.delNode(10);</span></span><br><span class="line">        <span class="comment">//binarySortTree.delNode(1);</span></span><br><span class="line">        System.out.println(<span class="string">&quot;删除结点后&quot;</span>);</span><br><span class="line">        binarySortTree.infixOrder();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建二叉排序树</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinarySortTree</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Node root;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加结点方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            root = node; <span class="comment">//如果root为空，直接让root指向node</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            root.add(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查找要删除的结点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">search</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> root.search(value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查找要删除的父结点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">searchParent</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> root.searchParent(value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  编写方法</span></span><br><span class="line"><span class="comment">     *  1.返回 以 node 为根节点的二叉排序树的最小结点的值</span></span><br><span class="line"><span class="comment">     *  2.删除node为根节点的二叉排序树的最小结点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node 传入的结点（当前二叉排序树的根节点）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回 以 node 为根节点的二叉排序树的最小结点的值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">delRightTreeMin</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">        Node target=node;</span><br><span class="line">        <span class="comment">//循环的查找左子节点，就会找到最小值</span></span><br><span class="line">        <span class="keyword">while</span> (target.left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            target=target.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//这是target就指向了最小结点</span></span><br><span class="line">        <span class="comment">//删除最小结点</span></span><br><span class="line">        delNode(target.value);</span><br><span class="line">        <span class="keyword">return</span> target.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除结点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delNode</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//1.需要先去找到要删除的结点 targetNode</span></span><br><span class="line">            Node targetNode = search(value);</span><br><span class="line">            <span class="comment">//如果没有找到要删除的结点</span></span><br><span class="line">            <span class="keyword">if</span> (targetNode == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果我们发现当前这个二叉排序树只有一个结点</span></span><br><span class="line">            <span class="keyword">if</span> (root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">                root = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//去找到targetNode的父结点</span></span><br><span class="line">            Node parent = searchParent(value);</span><br><span class="line">            <span class="comment">//如果要删除的结点是叶子结点</span></span><br><span class="line">            <span class="keyword">if</span> (targetNode.left == <span class="keyword">null</span> &amp;&amp; targetNode.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//判断targetNode是父结点的左子结点还是右子结点</span></span><br><span class="line">                <span class="keyword">if</span> (parent.left != <span class="keyword">null</span> &amp;&amp; parent.left.value == value) &#123;<span class="comment">//说明targetNode是parent的左子结点</span></span><br><span class="line">                    parent.left = <span class="keyword">null</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (parent.right != <span class="keyword">null</span> &amp;&amp; parent.right.value == value) &#123;<span class="comment">//说明targetNode是parent的右子结点</span></span><br><span class="line">                    parent.right = <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (targetNode.left != <span class="keyword">null</span> &amp;&amp; targetNode.right != <span class="keyword">null</span>) &#123; <span class="comment">//删除有两颗子树的结点</span></span><br><span class="line">                <span class="keyword">int</span> minValue = delRightTreeMin(targetNode.right);</span><br><span class="line">                targetNode.value=minValue;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">//删除只有一颗子树的结点</span></span><br><span class="line">                <span class="comment">//如果要删除的结点有左子结点</span></span><br><span class="line">                <span class="keyword">if</span> (targetNode.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (parent!=<span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="comment">//如果targetNode 是parent的左子结点</span></span><br><span class="line">                        <span class="keyword">if</span> (parent.left.value == value) &#123;</span><br><span class="line">                            parent.left = targetNode.left;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123; <span class="comment">//说明targetNode是parent的右子结点</span></span><br><span class="line">                            parent.right = targetNode.left;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                        root=targetNode.left;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;<span class="comment">//如果要删除的结点有右子结点</span></span><br><span class="line">                    <span class="keyword">if</span> (parent!=<span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (parent.left.value == value) &#123; <span class="comment">//targetNode是parent的左子结点</span></span><br><span class="line">                            parent.left = targetNode.right;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123; <span class="comment">//targetNode是parent的右子结点</span></span><br><span class="line">                            parent.right = targetNode.right;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                        root=targetNode.right;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//中序遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">infixOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">            root.infixOrder();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;二叉排序树为null，无法遍历&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建Node结点</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    Node left;</span><br><span class="line">    Node right;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Node&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;value=&quot;</span> + value +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加结点</span></span><br><span class="line">    <span class="comment">//递归的形式添加结点，注意需要满足二叉排序树</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断传入结点的值，和当前子树的根结点的值的关系</span></span><br><span class="line">        <span class="keyword">if</span> (node.value &lt; <span class="keyword">this</span>.value) &#123;</span><br><span class="line">            <span class="comment">//判断当前结点的左子结点是否为 null</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.left == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">this</span>.left = node;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//递归的向左子树添加</span></span><br><span class="line">                <span class="keyword">this</span>.left.add(node);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">//添加结点的值大于当前结点的值</span></span><br><span class="line">            <span class="comment">//判断当前结点的右子结点是否为 null</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">this</span>.right = node;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//递归的向右子树添加</span></span><br><span class="line">                <span class="keyword">this</span>.right.add(node);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查找要删除的结点</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 希望删除的结点的值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 如果找到该结点，就返回该结点，否则返回null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">search</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (value == <span class="keyword">this</span>.value) &#123; <span class="comment">//找到就是该结点</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value &lt; <span class="keyword">this</span>.value) &#123; <span class="comment">//如果查找的值小于当前结点，向左子树递归查找</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.left == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.left.search(value);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">//如果查找的值不小于当前结点，向右子树递归查找</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.right.search(value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查找要删除结点的父结点</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 要找到的结点的值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回要删除结点的父结点，没有就返回null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">searchParent</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//如果当前结点就是要删除的结点的父结点，就反回</span></span><br><span class="line">        <span class="keyword">if</span> ((<span class="keyword">this</span>.left != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.left.value == value) || (<span class="keyword">this</span>.right != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.right.value == value)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//如果查找的值小于当前结点的值，并且当前结点的左子结点不为null</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.left != <span class="keyword">null</span> &amp;&amp; value &lt; <span class="keyword">this</span>.value) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>.left.searchParent(value);<span class="comment">//向左子树递归查找</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value &gt;= <span class="keyword">this</span>.value &amp;&amp; <span class="keyword">this</span>.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>.right.searchParent(value);<span class="comment">//向右子树递归查找</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//中序遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">infixOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.left.infixOrder();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.right.infixOrder();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="平衡二叉树"><a class="markdownIt-Anchor" href="#平衡二叉树">#</a> 平衡二叉树</h2>
<h3 id="引出概念"><a class="markdownIt-Anchor" href="#引出概念">#</a> 引出概念</h3>
<p><strong>看一个案例 (说明二叉排序树可能的问题)</strong></p>
<p>给你一个数列 {1,2,3,4,5,6}，要求创建一颗二叉排序树 (BST), 并分析问题所在.</p>
<p><strong>下方 BST 存在的问题分析</strong>:</p>
<p>1) 左子树全部为空，从形式上看，更像一个单链表.</p>
<p>2) 插入速度没有影响</p>
<p>3) 查询速度明显降低 (因为需要依次比较), 不能发挥 BST 的优势，因为每次还需要比较左子树，其查询速度比单链表还慢</p>
<p>4) 解决方案 - 平衡二叉树 (AVL)</p>
<p><a href="https://imgtu.com/i/R7WV8e"><img src="https://z3.ax1x.com/2021/07/07/R7WV8e.png" alt="R7WV8e.png"></a></p>
<h3 id="基本介绍-4"><a class="markdownIt-Anchor" href="#基本介绍-4">#</a> 基本介绍</h3>
<p>1) 平衡二叉树也叫平衡二叉搜索树（Self-balancing binary search tree）又被称为 AVL 树， 可以<strong>保证查询效率较高</strong>。</p>
<p>2) 具有以下<strong>特点</strong>：它是一 棵空树或它的左右两个子树的高度差的绝对值不超过 1，并且左右两个子树都是一棵平衡二叉树。平衡二叉树的常用实现方法有<a href="">红黑树</a>)、<a href="">AVL</a>、<a href="">替罪羊树</a>、<a href="">Treap</a>、<a href="">伸展树</a>等。</p>
<h3 id="左旋转"><a class="markdownIt-Anchor" href="#左旋转">#</a> 左旋转</h3>
<ul>
<li 4,3,6,5,7,8="">要求：给你一个数列，创建出对应的平衡二叉树。数列</li>
</ul>
<p><a href="https://imgtu.com/i/R7WQVP"><img src="https://z3.ax1x.com/2021/07/07/R7WQVP.png" alt="R7WQVP.png"></a></p>
<h3 id="右旋转"><a class="markdownIt-Anchor" href="#右旋转">#</a> 右旋转</h3>
<ul>
<li 10,12,="" 8,="" 9,="" 7,="" 6="">要求：给你一个数列，创建出对应的平衡二叉树。数列</li>
</ul>
<p><a href="https://imgtu.com/i/R7Wevd"><img src="https://z3.ax1x.com/2021/07/07/R7Wevd.png" alt="R7Wevd.png"></a></p>
<h3 id="双旋转"><a class="markdownIt-Anchor" href="#双旋转">#</a> 双旋转</h3>
<p>前面的两个数列，进行单旋转 (即一次旋转) 就可以将非平衡二叉树转成平衡二叉树，但是在某些情况下，单旋转不能完成平衡二叉树的转换。比如数列</p>
<p><strong>int[]</strong> <strong>arr</strong> <strong>= { 10, 11, 7, 6, 8, 9 };</strong> <strong>运行原来的代码可以看到，并没有转成</strong> <strong>AVL 树.</strong></p>
<p><strong>int[]</strong> <strong>arr</strong> <strong>= {2,1,6,5,7,3}; //</strong> <strong>运行原来的代码可以看到，并没有转成 AVL 树</strong></p>
<p><a href="https://imgtu.com/i/R7WwV0"><img src="https://z3.ax1x.com/2021/07/07/R7WwV0.png" alt="R7WwV0.png"></a></p>
<h3 id="代码展示-3"><a class="markdownIt-Anchor" href="#代码展示-3">#</a> 代码展示</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> demo01;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AVLTreeDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//int[] arr=&#123;4,3,6,5,7,8&#125;;</span></span><br><span class="line">        <span class="comment">//int[] arr=&#123;10,12,8,9,7,6&#125;;</span></span><br><span class="line">        <span class="keyword">int</span>[] arr=&#123;<span class="number">10</span>,<span class="number">11</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line">        <span class="comment">//创建一个AVLTree对象</span></span><br><span class="line">        AVLTree avlTree = <span class="keyword">new</span> AVLTree();</span><br><span class="line">        <span class="comment">//添加结点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            avlTree.add(<span class="keyword">new</span> Node(arr[i]));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//遍历</span></span><br><span class="line">        System.out.println(<span class="string">&quot;中序遍历&quot;</span>);</span><br><span class="line">        avlTree.infixOrder();</span><br><span class="line">        System.out.println(<span class="string">&quot;平衡处理后~~&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;树的高度&quot;</span>+avlTree.getRoot().height()); <span class="comment">//3</span></span><br><span class="line">        System.out.println(<span class="string">&quot;树的左子树高度&quot;</span>+avlTree.getRoot().leftHeight()); <span class="comment">//2</span></span><br><span class="line">        System.out.println(<span class="string">&quot;树的右子树高度&quot;</span>+avlTree.getRoot().rightHeight()); <span class="comment">//2</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;当前的根节点为&quot;</span>+avlTree.getRoot()); <span class="comment">//8</span></span><br><span class="line">        System.out.println(<span class="string">&quot;当前的根节点左子结点为&quot;</span>+avlTree.getRoot().left); <span class="comment">//7</span></span><br><span class="line">        System.out.println(<span class="string">&quot;当前的根节点右子结点为&quot;</span>+avlTree.getRoot().right); <span class="comment">//10</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建AVL树</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AVLTree</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> Node root;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">getRoot</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加结点方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            root = node; <span class="comment">//如果root为空，直接让root指向node</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            root.add(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查找要删除的结点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">search</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> root.search(value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查找要删除的父结点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">searchParent</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> root.searchParent(value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 编写方法</span></span><br><span class="line"><span class="comment">     * 1.返回 以 node 为根节点的二叉排序树的最小结点的值</span></span><br><span class="line"><span class="comment">     * 2.删除node为根节点的二叉排序树的最小结点</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node 传入的结点（当前二叉排序树的根节点）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回 以 node 为根节点的二叉排序树的最小结点的值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">delRightTreeMin</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        Node target = node;</span><br><span class="line">        <span class="comment">//循环的查找左子节点，就会找到最小值</span></span><br><span class="line">        <span class="keyword">while</span> (target.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            target = target.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//这是target就指向了最小结点</span></span><br><span class="line">        <span class="comment">//删除最小结点</span></span><br><span class="line">        delNode(target.value);</span><br><span class="line">        <span class="keyword">return</span> target.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除结点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delNode</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//1.需要先去找到要删除的结点 targetNode</span></span><br><span class="line">            Node targetNode = search(value);</span><br><span class="line">            <span class="comment">//如果没有找到要删除的结点</span></span><br><span class="line">            <span class="keyword">if</span> (targetNode == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果我们发现当前这个二叉排序树只有一个结点</span></span><br><span class="line">            <span class="keyword">if</span> (root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">                root = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//去找到targetNode的父结点</span></span><br><span class="line">            Node parent = searchParent(value);</span><br><span class="line">            <span class="comment">//如果要删除的结点是叶子结点</span></span><br><span class="line">            <span class="keyword">if</span> (targetNode.left == <span class="keyword">null</span> &amp;&amp; targetNode.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//判断targetNode是父结点的左子结点还是右子结点</span></span><br><span class="line">                <span class="keyword">if</span> (parent.left != <span class="keyword">null</span> &amp;&amp; parent.left.value == value) &#123;<span class="comment">//说明targetNode是parent的左子结点</span></span><br><span class="line">                    parent.left = <span class="keyword">null</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (parent.right != <span class="keyword">null</span> &amp;&amp; parent.right.value == value) &#123;<span class="comment">//说明targetNode是parent的右子结点</span></span><br><span class="line">                    parent.right = <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (targetNode.left != <span class="keyword">null</span> &amp;&amp; targetNode.right != <span class="keyword">null</span>) &#123; <span class="comment">//删除有两颗子树的结点</span></span><br><span class="line">                <span class="keyword">int</span> minValue = delRightTreeMin(targetNode.right);</span><br><span class="line">                targetNode.value = minValue;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">//删除只有一颗子树的结点</span></span><br><span class="line">                <span class="comment">//如果要删除的结点有左子结点</span></span><br><span class="line">                <span class="keyword">if</span> (targetNode.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="comment">//如果targetNode 是parent的左子结点</span></span><br><span class="line">                        <span class="keyword">if</span> (parent.left.value == value) &#123;</span><br><span class="line">                            parent.left = targetNode.left;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123; <span class="comment">//说明targetNode是parent的右子结点</span></span><br><span class="line">                            parent.right = targetNode.left;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        root = targetNode.left;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;<span class="comment">//如果要删除的结点有右子结点</span></span><br><span class="line">                    <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (parent.left.value == value) &#123; <span class="comment">//targetNode是parent的左子结点</span></span><br><span class="line">                            parent.left = targetNode.right;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123; <span class="comment">//targetNode是parent的右子结点</span></span><br><span class="line">                            parent.right = targetNode.right;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        root = targetNode.right;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//中序遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">infixOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">            root.infixOrder();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;二叉排序树为null，无法遍历&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建Node结点</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    Node left;</span><br><span class="line">    Node right;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Node&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;value=&quot;</span> + value +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回左子树的高度</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">leftHeight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left.height();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回右子树的高度</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rightHeight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (right == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> right.height();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回当前结点的高度，当前结点为根节点的树的高度</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">height</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Math.max(left == <span class="keyword">null</span> ? <span class="number">0</span> : left.height(), right == <span class="keyword">null</span> ? <span class="number">0</span> : right.height()) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//左旋转的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">leftRotate</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//创建新的结点，以当前根节点的值</span></span><br><span class="line">        Node newNode = <span class="keyword">new</span> Node(value);</span><br><span class="line">        <span class="comment">//把新的结点的左子树设置成当前结点的左子树</span></span><br><span class="line">        newNode.left=left;</span><br><span class="line">        <span class="comment">//把新的结点的右子树设置成当前结点的右子树的左子树</span></span><br><span class="line">        newNode.right=right.left;</span><br><span class="line">        <span class="comment">//把当前结点的值替换成右子结点的值</span></span><br><span class="line">        value=right.value;</span><br><span class="line">        <span class="comment">//把当前结点的右子树设置成当前结点的右子树的右子树</span></span><br><span class="line">        right=right.right;</span><br><span class="line">        <span class="comment">//把当前结点的左子树(左子节点)设置成新的结点</span></span><br><span class="line">        left=newNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//右旋转的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rightRotate</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//创建新的结点，以当前根节点的值</span></span><br><span class="line">        Node newNode = <span class="keyword">new</span> Node(value);</span><br><span class="line">        <span class="comment">//把新的结点的右子树设置成当前结点的右子树</span></span><br><span class="line">        newNode.right=right;</span><br><span class="line">        <span class="comment">//把新的结点的左子树设置成当前结点的左子树的右子树</span></span><br><span class="line">        newNode.left=left.right;</span><br><span class="line">        <span class="comment">//把当前结点的值替换成左子结点的值</span></span><br><span class="line">        value=left.value;</span><br><span class="line">        <span class="comment">//把当前结点的左子树设置成当前结点的左子树的左子树</span></span><br><span class="line">        left=left.left;</span><br><span class="line">        <span class="comment">//把当前结点的右子树(右子节点)设置成新的结点</span></span><br><span class="line">        right=newNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加结点</span></span><br><span class="line">    <span class="comment">//递归的形式添加结点，注意需要满足二叉排序树</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断传入结点的值，和当前子树的根结点的值的关系</span></span><br><span class="line">        <span class="keyword">if</span> (node.value &lt; <span class="keyword">this</span>.value) &#123;</span><br><span class="line">            <span class="comment">//判断当前结点的左子结点是否为 null</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.left == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">this</span>.left = node;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//递归的向左子树添加</span></span><br><span class="line">                <span class="keyword">this</span>.left.add(node);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">//添加结点的值大于当前结点的值</span></span><br><span class="line">            <span class="comment">//判断当前结点的右子结点是否为 null</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">this</span>.right = node;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//递归的向右子树添加</span></span><br><span class="line">                <span class="keyword">this</span>.right.add(node);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//双旋转</span></span><br><span class="line">        <span class="comment">//当添加完一个结点后，如果发现：(右子树高度 - 左子树高度) &gt; 1,实现左旋转</span></span><br><span class="line">        <span class="keyword">if</span> (rightHeight()-leftHeight()&gt;<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">//如果它的右子树的左子树的高度大于他的右子树的右子树高度</span></span><br><span class="line">            <span class="keyword">if</span> (right!=<span class="keyword">null</span> &amp;&amp; right.leftHeight()&gt;right.rightHeight())&#123;</span><br><span class="line">                <span class="comment">//先对他的右子结点(右子树)进行右旋转</span></span><br><span class="line">                right.leftRotate();</span><br><span class="line">                <span class="comment">//再对当前结点进行左旋转</span></span><br><span class="line">                leftRotate();</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//直接左旋转</span></span><br><span class="line">                leftRotate();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//必须要 ！！！！！！！！！！！！</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//双旋转</span></span><br><span class="line">        <span class="comment">//当添加完一个结点后，如果发现：(左子树高度 - 右子树高度) &gt; 1,实现右旋转</span></span><br><span class="line">        <span class="keyword">if</span> (leftHeight()-rightHeight()&gt;<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">//如果他的左子树的右子树高度大于它的左子树的左子树高度</span></span><br><span class="line">            <span class="keyword">if</span> (left!=<span class="keyword">null</span> &amp;&amp; left.rightHeight()&gt;left.leftHeight())&#123;</span><br><span class="line">                <span class="comment">//先对当前结点的左子结点(左子树)-&gt;左旋转</span></span><br><span class="line">                left.leftRotate();</span><br><span class="line">                <span class="comment">//再对当前结点进行右旋转</span></span><br><span class="line">                rightRotate();</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//直接进行右旋转即可</span></span><br><span class="line">                rightRotate();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查找要删除的结点</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 希望删除的结点的值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 如果找到该结点，就返回该结点，否则返回null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">search</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (value == <span class="keyword">this</span>.value) &#123; <span class="comment">//找到就是该结点</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value &lt; <span class="keyword">this</span>.value) &#123; <span class="comment">//如果查找的值小于当前结点，向左子树递归查找</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.left == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.left.search(value);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">//如果查找的值不小于当前结点，向右子树递归查找</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.right.search(value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查找要删除结点的父结点</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 要找到的结点的值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回要删除结点的父结点，没有就返回null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">searchParent</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//如果当前结点就是要删除的结点的父结点，就反回</span></span><br><span class="line">        <span class="keyword">if</span> ((<span class="keyword">this</span>.left != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.left.value == value) || (<span class="keyword">this</span>.right != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.right.value == value)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//如果查找的值小于当前结点的值，并且当前结点的左子结点不为null</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.left != <span class="keyword">null</span> &amp;&amp; value &lt; <span class="keyword">this</span>.value) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>.left.searchParent(value);<span class="comment">//向左子树递归查找</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value &gt;= <span class="keyword">this</span>.value &amp;&amp; <span class="keyword">this</span>.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>.right.searchParent(value);<span class="comment">//向右子树递归查找</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//中序遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">infixOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.left.infixOrder();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.right.infixOrder();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>11.树结构实际应用</category>
      </categories>
      <tags>
        <tag>算法与数据结构</tag>
        <tag>堆排序</tag>
        <tag>赫夫曼树</tag>
        <tag>赫夫曼编码</tag>
        <tag>二叉排序树</tag>
        <tag>平衡二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>常用10种算法</title>
    <url>/2021/07/08/14.%E7%A8%8B%E5%BA%8F%E5%91%98%E5%B8%B8%E7%94%A810%E7%A7%8D%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="1-二分查找算法非递归"><a class="markdownIt-Anchor" href="#1-二分查找算法非递归">#</a> 1、二分查找算法 (非递归)</h1>
<h2 id="简单介绍"><a class="markdownIt-Anchor" href="#简单介绍">#</a> 简单介绍</h2>
<ol>
<li>
<p>二分查找法只适用于从有序的数列中进行查找 (比如数字和字母等)，将数列排序后再进行查找</p>
</li>
<li>
<p>二分查找法的运行时间为对数时间 O (㏒₂n) ，即查找到需要的目标位置<strong>最多</strong>只需要㏒₂n 步，假设从 [0,99] 的队列 (100 个数，即 n=100) 中寻到目标数 30，则需要查找步数为㏒₂100 , 即<strong>最多</strong>需要查找 7 次 (2^6 &lt; 100 &lt; 2^7)</p>
</li>
</ol>
<h2 id="代码实现"><a class="markdownIt-Anchor" href="#代码实现">#</a> 代码实现</h2>
<ul>
<li>数组 {1,3, 8, 10, 11, 67, 100}, 编程实现二分查找， 要求使用非递归的方式完成.</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> demo01;</span><br><span class="line"></span><br><span class="line"><span class="comment">//二分查找算法的非递归实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinarySearchNoRecur</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//测试</span></span><br><span class="line">        <span class="keyword">int</span>[] arr=&#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">48</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">67</span>,<span class="number">100</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> index=binarySearch(arr,<span class="number">1</span>);</span><br><span class="line">        System.out.println(index);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 二分查找算法的非递归实现</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> target</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = arr.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123; <span class="comment">//满足该条件，可以继续查找</span></span><br><span class="line">            <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (arr[mid] == target) &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[mid] &gt; target) &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;<span class="comment">//需要向左查找</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;<span class="comment">//需要向右查找</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="2-分治算法"><a class="markdownIt-Anchor" href="#2-分治算法">#</a> 2、分治算法</h1>
<h2 id="简单介绍-2"><a class="markdownIt-Anchor" href="#简单介绍-2">#</a> 简单介绍</h2>
<p>1) 分治法是一种很重要的算法。字面上的解释是 “分而治之”，就是把一个复杂的问题分成两个或更多的相同或相似的子问题，再把子问题分成更小的子问题…… 直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并。这个技巧是很多高效算法的基础，如排序算法 (<a href="">快速排序</a>，<a href="">归并排序</a>)，傅立叶变换 (快速傅立叶变换)……</p>
<p>​	二分搜索			大整数乘法			棋盘覆盖			<a href="">合并排序</a>		<a href="">快速排序</a></p>
<p>​	线性时间选择	最接近点对问题	循环赛日程表	<strong>汉诺塔</strong></p>
<h3 id="基本步骤"><a class="markdownIt-Anchor" href="#基本步骤">#</a> 基本步骤</h3>
<p>1) 分解：将原问题分解为若干个规模较小，相互独立，与原问题形式相同的子问题</p>
<p>2) 解决：若子问题规模较小而容易被解决则直接解，否则递归地解各个子问题</p>
<p>3) 合并：将各个子问题的解合并为原问题的解。</p>
<p><strong>分治 (Divide-and-Conquer§) 算法设计模式如下</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> |P|≤<span class="function">n0</span></span><br><span class="line"><span class="function">   then <span class="title">return</span><span class="params">(ADHOC(P)</span>)</span></span><br><span class="line"><span class="function"><span class="comment">//将P分解为较小的子问题 P1 ,P2 ,…,Pk</span></span></span><br><span class="line"><span class="function"><span class="keyword">for</span> i←1 to k</span></span><br><span class="line"><span class="function"><span class="keyword">do</span> yi ← Divide-and-<span class="title">Conquer</span><span class="params">(Pi)</span>   递归解决Pi</span></span><br><span class="line"><span class="function">T ← <span class="title">MERGE</span><span class="params">(y1,y2,…,yk)</span>   合并子问题</span></span><br><span class="line"><span class="function"><span class="title">return</span><span class="params">(T)</span></span></span><br></pre></td></tr></table></figure>
<p>其中 | P | 表示问题 P 的规模；n0 为一阈值，表示当问题 P 的规模不超过 n0 时，问题已容易直接解出，不必再继续分解。ADHOC§ 是该分治法中的基本子算法，用于直接解小规模的问题 P。因此，当 P 的规模不超过 n0 时直接用算法 ADHOC§ 求解。算法 MERGE (y1,y2,…,yk) 是该分治法中的合并子算法，用于将 P 的子问题 P1 ,P2 ,…,Pk 的相应的解 y1,y2,…,yk 合并为 P 的解。</p>
<h2 id="代码实现-2"><a class="markdownIt-Anchor" href="#代码实现-2">#</a> 代码实现</h2>
<p>Ø 汉诺塔的传说</p>
<p>汉诺塔：汉诺塔（又称河内塔）问题是源于印度一个古老传说的益智玩具。大梵天创造世界的时候做了三根<a href="https://baike.baidu.com/item/%E9%87%91%E5%88%9A%E7%9F%B3/80698">金刚石</a>柱子，在一根柱子上从下往上按照大小顺序摞着 64 片黄金圆盘。大梵天命令婆罗门把圆盘从下面开始按大小顺序重新摆放在另一根柱子上。并且规定，在小圆盘上不能放大圆盘，在三根柱子之间一次只能移动一个圆盘。</p>
<p>假如每秒钟一次，共需多长时间呢？移完这些金片需要 5845.54 亿年以上，太阳系的预期寿命据说也就是数百亿年。真的过了 5845.54 亿年，地球上的一切生命，连同梵塔、庙宇等，都早已经灰飞烟灭。</p>
<p><strong>思路分析：</strong></p>
<ol>
<li>
<p>如果是有一个盘， A-&gt;C</p>
<p>​	如果我们有 n &gt;= 2 情况，我们总是可以看做是两个盘 1. 最下边的盘 2. 上面的盘</p>
</li>
<li>
<p>先把 最上面的盘 A-&gt;B</p>
</li>
<li>
<p>把最下边的盘 A-&gt;C</p>
</li>
<li>
<p>把 B 塔的所有盘 从 B-&gt;C</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> demo02;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//分治算法解决汉诺塔问题</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hanoitower</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        hanoiTower(<span class="number">5</span>,<span class="string">&#x27;A&#x27;</span>,<span class="string">&#x27;B&#x27;</span>,<span class="string">&#x27;C&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//汉诺塔的移动方法</span></span><br><span class="line">    <span class="comment">//使用分治算法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">hanoiTower</span><span class="params">(<span class="keyword">int</span> num, <span class="keyword">char</span> a, <span class="keyword">char</span> b, <span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//如果只有一个盘</span></span><br><span class="line">        <span class="keyword">if</span> (num == <span class="number">1</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;第1个盘从 &quot;</span> + a + <span class="string">&quot;-&gt;&quot;</span> + c);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//如果我们有n&gt;=2 情况，我们总是可以看做成两个盘 1.最下边一个盘 2.上面的所有盘</span></span><br><span class="line">            <span class="comment">//1.先把最上面的所有盘A-&gt;B,移动过程会使用到c</span></span><br><span class="line">            hanoiTower(num - <span class="number">1</span>, a, c, b);</span><br><span class="line">            <span class="comment">//2.把最下边的盘A-&gt;C</span></span><br><span class="line">            System.out.println(<span class="string">&quot;第&quot;</span> + num + <span class="string">&quot;个盘从 &quot;</span> + a + <span class="string">&quot;-&gt;&quot;</span> + c);</span><br><span class="line">            <span class="comment">//3.把B塔的所有盘从B-&gt;C，移动过程使用到a 塔</span></span><br><span class="line">            hanoiTower(num - <span class="number">1</span>, b, a, c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="3-动态规划算法"><a class="markdownIt-Anchor" href="#3-动态规划算法">#</a> 3、动态规划算法</h1>
<h2 id="简单介绍-3"><a class="markdownIt-Anchor" href="#简单介绍-3">#</a> 简单介绍</h2>
<ol>
<li>
<p>动态规划 (<strong>Dynamic Programming</strong>) 算法的核心思想是：将大问题划分为小问题进行解决，从而一步步获取最优解的处理算法</p>
</li>
<li>
<p>动态规划算法与分治算法类似，其基本思想也是将待求解问题分解成若干个子问题，先求解子问题，然后从这些子问题的解得到原问题的解。</p>
</li>
<li>
<p>与分治法不同的是，<strong>适合于用动态规划求解的问题，经分解得到子问题往往不是互相独立的。</strong> (即下一个子阶段的求解是建立在上一个子阶段的解的基础上，进行进一步的求解)</p>
</li>
<li>
<p>动态规划可以通过<strong>填表的方式</strong>来逐步推进，得到最优解.</p>
</li>
</ol>
<h2 id="应用场景"><a class="markdownIt-Anchor" href="#应用场景">#</a> 应用场景</h2>
<p><a href="https://imgtu.com/i/R7h11g"><img src="https://z3.ax1x.com/2021/07/07/R7h11g.png" alt="R7h11g.png"></a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 要求达到的目标为装入的背包的总价值最大，并且重量不超出</span><br><span class="line">2. 要求装入的物品不能重复</span><br><span class="line">3. 思路分析和图解</span><br><span class="line">   背包问题主要是指一个给定容量的背包、若干具有一定价值和重量的物品，如何选择物品放入背包使物品的价值最大。其中又分01背包和完全背包(完全背包指的是：每种物品都有无限件可用)</span><br><span class="line">   这里的问题属于01背包，即每个物品最多放一个。而无限背包可以转化为01背包</span><br><span class="line">4. 算法的主要思想，利用动态规划来解决。每次遍历到的第i个物品，根据w[i]和v[i]来确定是否需要将该物品放入背包中。即对于给定的n个物品，设v[i]、w[i]分别为第i个物品的价值和重量，C为背包的容量。再令v[i][j]表示在前i个物品中能够装入容量为j的背包中的最大价值。则我们有下面的结果：</span><br><span class="line">   1.  v[i][0]=v[0][j]=0; //表示 填入表 第一行和第一列是0</span><br><span class="line">   2. 当w[i]&gt; j 时：v[i][j]=v[i-1][j]   // 当准备加入新增的商品的容量大于 当前背包的容量时，就直接使用上一个单元格的装入策略</span><br><span class="line">   3. 当j&gt;=w[i]时： v[i][j]=max&#123;v[i-1][j], v[i]+v[i-1][j-w[i]]&#125;  </span><br><span class="line"></span><br><span class="line">      - 当准备加入的新增的商品的容量小于等于当前背包的容量,</span><br><span class="line">      - 装入的方式:</span><br><span class="line">      	- v[i-1][j]： 就是上一个单元格的装入的最大值</span><br><span class="line">      	- v[i] : 表示当前商品的价值 </span><br><span class="line">     	- v[i-1][j-w[i]] ： 装入i-1商品，到剩余空间j-w[i]的最大值</span><br><span class="line">      	- 当j&gt;=w[i]时： vi=max&#123;vi-1, v[i]+vi-1]&#125; :</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><a href="https://imgtu.com/i/R7haNV"><img src="https://z3.ax1x.com/2021/07/07/R7haNV.png" alt="R7haNV.png"></a></p>
<h2 id="代码展示"><a class="markdownIt-Anchor" href="#代码展示">#</a> 代码展示</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> demo03;</span><br><span class="line"></span><br><span class="line"><span class="comment">//动态规划算法   背包问题</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KnapsackProblem</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] w = &#123;<span class="number">1</span>, <span class="number">4</span>, <span class="number">3</span>&#125;;<span class="comment">//物品的重量</span></span><br><span class="line">        <span class="keyword">int</span>[] val = &#123;<span class="number">1500</span>, <span class="number">3000</span>, <span class="number">2000</span>&#125;;<span class="comment">//物品的价值 这里的val[i],就是v[i]</span></span><br><span class="line">        <span class="keyword">int</span> m = <span class="number">4</span>;<span class="comment">//背包的容量</span></span><br><span class="line">        <span class="keyword">int</span> n = val.length;<span class="comment">//物品的个数</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建二维数组</span></span><br><span class="line">        <span class="comment">//v[i][j],表示在前i个物品中能够转入容量为j的背包中的最大价值</span></span><br><span class="line">        <span class="keyword">int</span>[][] v = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>][m + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">//为了记录放入商品的情况，我们定义一个二维数组</span></span><br><span class="line">        <span class="keyword">int</span>[][] path = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>][m + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//初始化第一行和第一列，这里在本程序中可以不去处理，因为默认就是0</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v.length; i++) &#123;</span><br><span class="line">            v[i][<span class="number">0</span>] = <span class="number">0</span>;<span class="comment">//将第一列设置为0</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v[<span class="number">0</span>].length; i++) &#123;</span><br><span class="line">            v[<span class="number">0</span>][i] = <span class="number">0</span>;<span class="comment">//将第一行设置为0</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//根据前面的公式，动态规划处理</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; v.length; i++) &#123; <span class="comment">//不处理第一行 i是从1开始的</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; v[<span class="number">0</span>].length; j++) &#123; <span class="comment">//不处理第一列 j是从1开始的</span></span><br><span class="line">                <span class="comment">//公式</span></span><br><span class="line">                <span class="keyword">if</span> (w[i - <span class="number">1</span>] &gt; j) &#123; <span class="comment">//因为我们程序i 是从1开始的，因此我们原来公式中 w[i] 要修改为 w[i-1]</span></span><br><span class="line">                    v[i][j] = v[i - <span class="number">1</span>][j];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 因为i 是从1开始的</span></span><br><span class="line">                    <span class="comment">//v[i][j]=Math.max(v[i-1][j],val[i-1]+v[i-1][j-w[i-1]]);</span></span><br><span class="line">                    <span class="comment">//为了记录商品存放到背包的情况，不能直接使用上面的公式，要使用if-else来体现公式</span></span><br><span class="line">                    <span class="keyword">if</span> (v[i - <span class="number">1</span>][j] &lt; val[i - <span class="number">1</span>] + v[i - <span class="number">1</span>][j - w[i - <span class="number">1</span>]]) &#123;</span><br><span class="line">                        v[i][j] = val[i - <span class="number">1</span>] + v[i - <span class="number">1</span>][j - w[i - <span class="number">1</span>]];</span><br><span class="line">                        <span class="comment">//把当前的情况记录到path中</span></span><br><span class="line">                        path[i][j] = <span class="number">1</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        v[i][j] = v[i - <span class="number">1</span>][j];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//输出一下 v,看看目前的情况</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; v[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">                System.out.print(v[i][j] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//输出最后我们是放入了那些商品</span></span><br><span class="line">        <span class="comment">//遍历 path 这样输出会把所有的情况都得到，其实我们只需要最后放入的</span></span><br><span class="line"><span class="comment">//        for (int i = 0; i &lt; path.length; i++) &#123;</span></span><br><span class="line"><span class="comment">//            for (int j = 0; j &lt; path[i].length; j++) &#123;</span></span><br><span class="line"><span class="comment">//                if (path[i][j]==1) &#123;</span></span><br><span class="line"><span class="comment">//                    System.out.printf(&quot;第%d个商品放入到背包\n&quot;, i);</span></span><br><span class="line"><span class="comment">//                &#125;</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> i = path.length - <span class="number">1</span>;<span class="comment">//行的最大下标</span></span><br><span class="line">        <span class="keyword">int</span> j = path[<span class="number">0</span>].length - <span class="number">1</span>; <span class="comment">//列的最大下标</span></span><br><span class="line">        <span class="keyword">while</span> (i &gt; <span class="number">0</span> &amp;&amp; j &gt; <span class="number">0</span>) &#123; <span class="comment">//从path的最后开始找</span></span><br><span class="line">            <span class="keyword">if</span> (path[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                System.out.printf(<span class="string">&quot;第%d个商品放入到背包\n&quot;</span>, i);</span><br><span class="line">                j -= w[i - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            i--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="4-kmp算法"><a class="markdownIt-Anchor" href="#4-kmp算法">#</a> 4、KMP 算法</h1>
<h2 id="问题展示"><a class="markdownIt-Anchor" href="#问题展示">#</a> 问题展示</h2>
<p>字符串匹配问题：：</p>
<ol>
<li>
<p>有一个字符串 str1= ““硅硅谷 尚硅谷你尚硅 尚硅谷你尚硅谷你尚硅你好””，和一个子串 str2=“尚硅谷你尚硅你”</p>
</li>
<li>
<p><strong>现在要判断</strong> <strong>str1</strong> <strong>是否含有</strong> <strong>str2</strong>, 如果存在，就返回第一次出现的位置，如果没有，则返回 - 1</p>
</li>
</ol>
<h2 id="暴力匹配算法"><a class="markdownIt-Anchor" href="#暴力匹配算法">#</a> 暴力匹配算法</h2>
<h3 id="思路分析"><a class="markdownIt-Anchor" href="#思路分析">#</a> 思路分析</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">如果用暴力匹配的思路，并假设现在str1匹配到 i 位置，子串str2匹配到 j 位置，则有:</span><br><span class="line"></span><br><span class="line">	1. 如果当前字符匹配成功（即str1[i] == str2[j]），则i++，j++，继续匹配下一个字符</span><br><span class="line">	2. 如果失配（即str1[i]! = str2[j]），令i = i - (j - 1)，j = 0。相当于每次匹配失败时，i 回溯，j 被置为0。</span><br><span class="line">	3. 用暴力方法解决的话就会有大量的回溯，每次只移动一位，若是不匹配，移动到下一位接着判断，浪费了大量的时间。(不可行!)</span><br></pre></td></tr></table></figure>
<h3 id="代码实现-3"><a class="markdownIt-Anchor" href="#代码实现-3">#</a> 代码实现</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> demo04;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ViolenceMatch</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//测试暴力匹配算法</span></span><br><span class="line">        String s1=<span class="string">&quot;aaa d d da adad acar&quot;</span>;</span><br><span class="line">        String s2=<span class="string">&quot;d da&quot;</span>;</span><br><span class="line">        <span class="keyword">int</span> index = violenceMatch(s1, s2);</span><br><span class="line">        System.out.println(index);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//暴力匹配算法实现</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">violenceMatch</span><span class="params">(String str1, String str2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] s1 = str1.toCharArray();</span><br><span class="line">        <span class="keyword">char</span>[] s2 = str2.toCharArray();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> s1Length = s1.length;</span><br><span class="line">        <span class="keyword">int</span> s2Length = s2.length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>; <span class="comment">//i索引指向s1</span></span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>; <span class="comment">//j索引指向s2</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt; s1Length &amp;&amp; j &lt; s2Length) &#123;<span class="comment">//保证匹配时，不越界</span></span><br><span class="line">            <span class="keyword">if</span> (s1[i]==s2[j])&#123; <span class="comment">//匹配成功</span></span><br><span class="line">                i++;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//匹配失败 (即 str1[i] != str2[j]),令 i=i-(j-1),j=0</span></span><br><span class="line">                i=i-(j-<span class="number">1</span>);</span><br><span class="line">                j=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断是否匹配成功</span></span><br><span class="line">        <span class="keyword">if</span> (j==s2Length)&#123;</span><br><span class="line">            <span class="keyword">return</span> i-j;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="kmp算法"><a class="markdownIt-Anchor" href="#kmp算法">#</a> KMP 算法</h2>
<ul>
<li>
<p>KMP 是一个解决模式串在文本串是否出现过，如果出现过，最早出现的位置的经典算法</p>
</li>
<li>
<p>Knuth-Morris-Pratt <strong>字符串查找算法</strong>，简称为 “KMP 算法”，常用于在一个文本串 S 内查找一个模式串 P 的出现位置，这个算法由 Donald Knuth、Vaughan Pratt、James H. Morris 三人于 1977 年联合发表，故取这 3 人的姓氏命名此算法.</p>
</li>
<li>
<p>KMP 方法算法就利用之前判断过信息，通过一个 next 数组，保存模式串中前后最长公共子序列的长度，每次回溯时，通过 next 数组找到，前面匹配过的位置，省去了大量的计算时间</p>
</li>
</ul>
<p><strong>(详细了解 KMP 算法的运行【】涉及底层) 参考资料：<a href="https://www.cnblogs.com/ZuoAndFutureGirl/p/9028287.html">https://www.cnblogs.com/ZuoAndFutureGirl/p/9028287.html</a></strong></p>
<h3 id="kmp运行过程"><a class="markdownIt-Anchor" href="#kmp运行过程">#</a> KMP 运行过程</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">举例来说，有一个字符串 Str1 = “BBC ABCDAB ABCDABCDABDE”，判断，里面是否包含另一个字符串 Str2 = “ABCDABD”？ </span><br><span class="line">1.首先，用Str1的第一个字符和Str2的第一个字符去比较，不符合，关键词向后移动一位 </span><br></pre></td></tr></table></figure>
<p><a href="https://imgtu.com/i/R7hB3F"><img src="https://z3.ax1x.com/2021/07/07/R7hB3F.jpg" alt="R7hB3F.jpg"></a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2.重复第一步，还是不符合，再后移</span><br></pre></td></tr></table></figure>
<p><a href="https://imgtu.com/i/R7hrjJ"><img src="https://z3.ax1x.com/2021/07/07/R7hrjJ.jpg" alt="R7hrjJ.jpg"></a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3.一直重复，直到Str1有一个字符与Str2的第一个字符符合为止</span><br></pre></td></tr></table></figure>
<p><a href="https://imgtu.com/i/R7hyu9"><img src="https://z3.ax1x.com/2021/07/07/R7hyu9.jpg" alt="R7hyu9.jpg"></a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4.接着比较字符串和搜索词的下一个字符，还是符合。</span><br></pre></td></tr></table></figure>
<p><a href="https://imgtu.com/i/R7h6BR"><img src="https://z3.ax1x.com/2021/07/07/R7h6BR.jpg" alt="R7h6BR.jpg"></a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5.遇到Str1有一个字符与Str2对应的字符不符合。 </span><br></pre></td></tr></table></figure>
<p><a href="https://imgtu.com/i/R7hcH1"><img src="https://z3.ax1x.com/2021/07/07/R7hcH1.jpg" alt="R7hcH1.jpg"></a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">6.这时候，想到的是继续遍历Str1的下一个字符，重复第1步。(其实是很不明智的，因为此时BCD已经比较过了，没有必要再做重复的工作，一个基本事实是，当空格与D不匹配时，你其实知道前面六个字符是”ABCDAB”。KMP 算法的想法是，设法利用这个已知信息，不要把”搜索位置”移回已经比较过的位置，继续把它向后移，这样就提高了效率。) </span><br></pre></td></tr></table></figure>
<p><a href="https://imgtu.com/i/R7hh9O"><img src="https://z3.ax1x.com/2021/07/07/R7hh9O.jpg" alt="R7hh9O.jpg"></a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">7.怎么做到把刚刚重复的步骤省略掉？可以对Str2计算出一张《部分匹配表》，这张表的产生在后面介绍 </span><br></pre></td></tr></table></figure>
<p><a href="https://imgtu.com/i/RHSr0x"><img src="https://z3.ax1x.com/2021/07/07/RHSr0x.jpg" alt="RHSr0x.jpg"></a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">8.已知空格与D不匹配时，前面六个字符”ABCDAB”是匹配的。查表可知，最后一个匹配字符B对应的”部分匹配值”为2，因此按照下面的公式算出向后移动的位数： </span><br><span class="line"></span><br><span class="line">	移动位数 = 已匹配的字符数 - 对应的部分匹配值 </span><br><span class="line"></span><br><span class="line">	因为 6 - 2 等于4，所以将搜索词向后移动 4 位。 </span><br><span class="line"></span><br><span class="line">9.因为空格与Ｃ不匹配，搜索词还要继续往后移。这时，已匹配的字符数为2（”AB”），对应的”部分匹配值”为0。所以，移动位数 = 2 - 0，结果为 2，于是将搜索词向后移 2 位。</span><br></pre></td></tr></table></figure>
<p><a href="https://imgtu.com/i/RHSW1H"><img src="https://z3.ax1x.com/2021/07/07/RHSW1H.jpg" alt="RHSW1H.jpg"></a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">10.因为空格与A不匹配，继续后移一位。</span><br></pre></td></tr></table></figure>
<p><a href="https://imgtu.com/i/RHSfcd"><img src="https://z3.ax1x.com/2021/07/07/RHSfcd.jpg" alt="RHSfcd.jpg"></a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">11.逐位比较，直到发现C与D不匹配。于是，移动位数 = 6 - 2，继续将搜索词向后移动 4 位。</span><br></pre></td></tr></table></figure>
<p><a href="https://imgtu.com/i/RHSzBq"><img src="https://z3.ax1x.com/2021/07/07/RHSzBq.jpg" alt="RHSzBq.jpg"></a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">12.逐位比较，直到搜索词的最后一位，发现完全匹配，于是搜索完成。如果还要继续搜索（即找出全部匹配），移动位数 = 7 - 0，再将搜索词向后移动 7 位，这里就不再重复了。 </span><br></pre></td></tr></table></figure>
<p><a href="https://imgtu.com/i/RHpAgJ"><img src="https://z3.ax1x.com/2021/07/07/RHpAgJ.jpg" alt="RHpAgJ.jpg"></a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">13.介绍《部分匹配表》怎么产生的 </span><br><span class="line"></span><br><span class="line">	先介绍前缀，后缀是什么 </span><br></pre></td></tr></table></figure>
<p><a href="https://imgtu.com/i/RHpeD1"><img src="https://z3.ax1x.com/2021/07/07/RHpeD1.jpg" alt="RHpeD1.jpg"></a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">“部分匹配值”就是”前缀”和”后缀”的最长的共有元素的长度。以”ABCDABD”为例， </span><br><span class="line"></span><br><span class="line">	－”A”的前缀和后缀都为空集，共有元素的长度为0； </span><br><span class="line">	－”AB”的前缀为[A]，后缀为[B]，共有元素的长度为0； </span><br><span class="line">	－”ABC”的前缀为[A, AB]，后缀为[BC, C]，共有元素的长度0； </span><br><span class="line">	－”ABCD”的前缀为[A, AB, ABC]，后缀为[BCD, CD, D]，共有元素的长度为0； </span><br><span class="line">	－”ABCDA”的前缀为[A, AB, ABC, ABCD]，后缀为[BCDA, CDA, DA, A]，共有元素为”A”，长度为1； </span><br><span class="line">	－”ABCDAB”的前缀为[A, AB, ABC, ABCD, ABCDA]，后缀为[BCDAB, CDAB, DAB, AB, B]，共有元素为”AB”，长度为2； </span><br><span class="line">	－”ABCDABD”的前缀为[A, AB, ABC, ABCD, ABCDA, ABCDAB]，后缀为[BCDABD, CDABD, DABD, ABD, BD, D]，共有元素的长度为0。</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">14.”部分匹配”的实质是，有时候，字符串头部和尾部会有重复。比如，”ABCDAB”之中有两个”AB”，那么它的”部分匹配值”就是2（”AB”的长度）。搜索词移动的时候，第一个”AB”向后移动 4 位（字符串长度-部分匹配值），就可以来到第二个”AB”的位置。 </span><br><span class="line"></span><br><span class="line">	~~完毕~~</span><br></pre></td></tr></table></figure>
<p><a href="https://imgtu.com/i/RHpKUK"><img src="https://z3.ax1x.com/2021/07/07/RHpKUK.jpg" alt="RHpKUK.jpg"></a></p>
<h3 id="代码展示-2"><a class="markdownIt-Anchor" href="#代码展示-2">#</a> 代码展示</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> demo05;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KMPAlgonithm</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String str1=<span class="string">&quot;BBC ABCDAB ABCDABCDABDE&quot;</span>;</span><br><span class="line">        String str2=<span class="string">&quot;ABCDABD&quot;</span>;</span><br><span class="line">        <span class="keyword">int</span>[] next=kmpNext(str2);</span><br><span class="line">        System.out.println(Arrays.toString(next));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> index=kmpSearch(str1,str2,next);</span><br><span class="line">        System.out.println(index);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  写出kmp搜索算法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> str1  源字符串</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> str2  子串</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> next  部分匹配表，是子串对应的部分匹配表</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 如果是 -1就是没有匹配到，否则返回第一个匹配位置</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">kmpSearch</span><span class="params">(String str1,String str2,<span class="keyword">int</span>[] next)</span></span>&#123;</span><br><span class="line">        <span class="comment">//遍历</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>,j=<span class="number">0</span>; i &lt; str1.length(); i++) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//需要考虑str1.charAt(i)！=str2.charAt(j)，去调整 j的大小</span></span><br><span class="line">            <span class="comment">//kmp算法核心点 要了解如何运行，得看底层</span></span><br><span class="line">            <span class="keyword">while</span> (j&gt;<span class="number">0</span> &amp;&amp; str1.charAt(i) != str2.charAt(j))&#123;</span><br><span class="line">                j=next[j-<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (str1.charAt(i)==str2.charAt(j))&#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (j==str2.length())&#123; <span class="comment">//找到了</span></span><br><span class="line">                <span class="keyword">return</span> i-j+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取到一个字符串(子串) 的部分匹配值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">int</span>[] kmpNext(String dest)&#123;</span><br><span class="line">        <span class="comment">//创建一个next 数组保存部分匹配值</span></span><br><span class="line">        <span class="keyword">int</span>[] next=<span class="keyword">new</span> <span class="keyword">int</span>[dest.length()];</span><br><span class="line">        next[<span class="number">0</span>]=<span class="number">0</span>;<span class="comment">//如果字符串是长度为1，部分匹配值就是 0</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>,j=<span class="number">0</span>; i &lt; dest.length(); i++) &#123;</span><br><span class="line">            <span class="comment">//当 dest.charAt(i)!=dest.charAt(j),我们需要从next[j-1]获取新的j</span></span><br><span class="line">            <span class="comment">//直到我们发现 有 dest.charAt(i) == dest.charAt(j)成立才退出</span></span><br><span class="line">            <span class="comment">//这是kmp算法的核心点  要了解如何运行，得看底层</span></span><br><span class="line">            <span class="keyword">while</span> (j&gt;<span class="number">0</span> &amp;&amp; dest.charAt(i) != dest.charAt(j))&#123;</span><br><span class="line">                j=next[j-<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//当 dest.charAt(i)==dest.charAt(j) 满足时，部分匹配值就是 +1</span></span><br><span class="line">            <span class="keyword">if</span> (dest.charAt(i)==dest.charAt(j))&#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            next[i]=j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="5-贪心算法"><a class="markdownIt-Anchor" href="#5-贪心算法">#</a> 5、贪心算法</h1>
<h2 id="简单介绍-4"><a class="markdownIt-Anchor" href="#简单介绍-4">#</a> 简单介绍</h2>
<ol>
<li>
<p>贪婪算法 (贪心算法) 是指在对问题进行求解时，在每一步选择中都采取最好或者最优 (即最有利) 的选择，从而希望能够导致结果是最好或者最优的算法</p>
</li>
<li>
<p>贪婪算法所得到的结果<strong>不一定是最优的结果 (有时候会是最优解)</strong>，但是都是相对近似 (接近) 最优解的结果</p>
</li>
</ol>
<h2 id="应用场景-2"><a class="markdownIt-Anchor" href="#应用场景-2">#</a> 应用场景</h2>
<p>1) 假设存在如下表的需要付费的广播台，以及广播台信号可以覆盖的地区。 <strong>如何选择最少的广播台</strong>，让所有的地区都可以接收到信号</p>
<table>
<thead>
<tr>
<th>广播台</th>
<th>覆盖地区</th>
</tr>
</thead>
<tbody>
<tr>
<td>K1</td>
<td>“北京”, “上海”, “天津”</td>
</tr>
<tr>
<td>K2</td>
<td>“广州”, “北京”, “深圳”</td>
</tr>
<tr>
<td>K3</td>
<td>“成都”, “上海”, “杭州”</td>
</tr>
<tr>
<td>K4</td>
<td>“上海”, “天津”</td>
</tr>
<tr>
<td>K5</td>
<td>“杭州”, “大连”</td>
</tr>
</tbody>
</table>
<ol start="2">
<li>
<p>思路分析</p>
<ul>
<li>穷举法</li>
<li>使用穷举法实现，列出每个可能的广播台的集合，这被称为幂集。假设总的有 n 个广播台，则广播台的组合总共有 2ⁿ -1 个，假设每秒可以计算 10 个子集， 如图:</li>
</ul>
<table>
<thead>
<tr>
<th>广播台数量 n</th>
<th>子集总数 2ⁿ</th>
<th>需要的时间</th>
</tr>
</thead>
<tbody>
<tr>
<td>5</td>
<td>32</td>
<td>3.2 秒</td>
</tr>
<tr>
<td>10</td>
<td>1024</td>
<td>102.4 秒</td>
</tr>
<tr>
<td>32</td>
<td>4294967296</td>
<td>13.6 年</td>
</tr>
<tr>
<td>100</td>
<td>1.26*100³º</td>
<td>4x10²³ 年</td>
</tr>
</tbody>
</table>
<ul>
<li>
<p>Ø 贪婪算法，效率高:</p>
</li>
<li>
<p>目前并没有算法可以快速计算得到准备的值， 使用贪婪算法，则可以得到非常接近的解，并且效率高。选择策略上，因为需要覆盖全部地区的最小集合:</p>
<ol>
<li>
<p>遍历所有的广播电台，找到一个覆盖了最多<strong>未覆盖的地区</strong>的电台 (此电台可能包含一些已覆盖的地区，但没有关系）</p>
</li>
<li>
<p>将这个电台加入到一个集合中 (比如 ArrayList), 想办法把该电台覆盖的地区在下次比较时去掉。</p>
</li>
<li>
<p>重复第 1 步直到覆盖了全部的地区</p>
</li>
</ol>
</li>
</ul>
</li>
</ol>
<p><strong>注意事项：</strong></p>
<ul>
<li><strong>贪婪算法所得到的结果不一定是最优的结果 (有时候会是最优解)，但是都是相对近似 (接近) 最优解的结果</strong></li>
<li>* 比如上题的 ** 算法选出的是 K1, K2, K3, K5，符合覆盖了全部的地区</li>
<li>但是我们发现 K2, K3,K4,K5 也可以覆盖全部地区，如果 K2 的使用成本低于 K1, 那么我们上题的 K1, K2, K3, K5 虽然是满足条件，但是并不是最优的.</li>
</ul>
<h2 id="代码展示-3"><a class="markdownIt-Anchor" href="#代码展示-3">#</a> 代码展示</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> demo06;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GreedyAlgorithm</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建广播电台，放入到Map中</span></span><br><span class="line">        Map&lt;String, HashSet&lt;String&gt;&gt; broadcasts = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="comment">//将各个广播电台放入到broadcasts</span></span><br><span class="line">        HashSet&lt;String&gt; hashSet1=<span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        hashSet1.add(<span class="string">&quot;北京&quot;</span>);</span><br><span class="line">        hashSet1.add(<span class="string">&quot;上海&quot;</span>);</span><br><span class="line">        hashSet1.add(<span class="string">&quot;天津&quot;</span>);</span><br><span class="line"></span><br><span class="line">        HashSet&lt;String&gt; hashSet2=<span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        hashSet2.add(<span class="string">&quot;广州&quot;</span>);</span><br><span class="line">        hashSet2.add(<span class="string">&quot;北京&quot;</span>);</span><br><span class="line">        hashSet2.add(<span class="string">&quot;深圳&quot;</span>);</span><br><span class="line"></span><br><span class="line">        HashSet&lt;String&gt; hashSet3=<span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        hashSet3.add(<span class="string">&quot;成都&quot;</span>);</span><br><span class="line">        hashSet3.add(<span class="string">&quot;上海&quot;</span>);</span><br><span class="line">        hashSet3.add(<span class="string">&quot;杭州&quot;</span>);</span><br><span class="line"></span><br><span class="line">        HashSet&lt;String&gt; hashSet4=<span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        hashSet4.add(<span class="string">&quot;上海&quot;</span>);</span><br><span class="line">        hashSet4.add(<span class="string">&quot;天津&quot;</span>);</span><br><span class="line"></span><br><span class="line">        HashSet&lt;String&gt; hashSet5=<span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        hashSet5.add(<span class="string">&quot;杭州&quot;</span>);</span><br><span class="line">        hashSet5.add(<span class="string">&quot;大连&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//加入到Map</span></span><br><span class="line">        broadcasts.put(<span class="string">&quot;K1&quot;</span>,hashSet1);</span><br><span class="line">        broadcasts.put(<span class="string">&quot;K2&quot;</span>,hashSet2);</span><br><span class="line">        broadcasts.put(<span class="string">&quot;K3&quot;</span>,hashSet3);</span><br><span class="line">        broadcasts.put(<span class="string">&quot;K4&quot;</span>,hashSet4);</span><br><span class="line">        broadcasts.put(<span class="string">&quot;K5&quot;</span>,hashSet5);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//存放所有地区</span></span><br><span class="line">        HashSet&lt;String&gt; allAreas = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        allAreas.add(<span class="string">&quot;北京&quot;</span>);</span><br><span class="line">        allAreas.add(<span class="string">&quot;上海&quot;</span>);</span><br><span class="line">        allAreas.add(<span class="string">&quot;天津&quot;</span>);</span><br><span class="line">        allAreas.add(<span class="string">&quot;广州&quot;</span>);</span><br><span class="line">        allAreas.add(<span class="string">&quot;深圳&quot;</span>);</span><br><span class="line">        allAreas.add(<span class="string">&quot;成都&quot;</span>);</span><br><span class="line">        allAreas.add(<span class="string">&quot;杭州&quot;</span>);</span><br><span class="line">        allAreas.add(<span class="string">&quot;大连&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建ArrayList，存放选择的电台集合</span></span><br><span class="line">        ArrayList&lt;String&gt; selects=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//定义一个临时的集合，在遍历的过程中，存放遍历过程中的电台覆盖的地区和当前还没有覆盖的地区的交集</span></span><br><span class="line">        HashSet&lt;String&gt; tempSet=<span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//定义一个maxKey，保存在一次遍历中，能够覆盖最大未覆盖的的地区对应的电台key</span></span><br><span class="line">        <span class="comment">//如果maxKey 不为 null ，则会加入到selects</span></span><br><span class="line">        String maxKey=<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (allAreas.size()!=<span class="number">0</span>)&#123; <span class="comment">//如果allAreas不为0，则表示还没有覆盖到所有的地区</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//每进行一次while，需要将maxKey置空</span></span><br><span class="line">            maxKey=<span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//遍历broadcast，取出对应的key</span></span><br><span class="line">            <span class="keyword">for</span> (String key:broadcasts.keySet())&#123;</span><br><span class="line">                <span class="comment">//每进行一次for都需要将tempSet中的数据清除</span></span><br><span class="line">                tempSet.clear();</span><br><span class="line"></span><br><span class="line">                <span class="comment">//当前这个key能够覆盖的地区</span></span><br><span class="line">                HashSet&lt;String&gt; areas=broadcasts.get(key);</span><br><span class="line">                tempSet.addAll(areas);</span><br><span class="line">                <span class="comment">//求出tempSet和allAreas 集合的交集，交集会付给tempSet</span></span><br><span class="line">                <span class="comment">//tempSet.retainAll(allAreas); 把tempSet 和allAreas 共有的部分 取出来，赋给tempSet</span></span><br><span class="line">                tempSet.retainAll(allAreas);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//如果当前这个集合包含的未覆盖地区的数量，比maxKey指向的集合地区还多</span></span><br><span class="line">                <span class="comment">//就需要重置maxKey</span></span><br><span class="line">                <span class="comment">//tempSet.size()&gt;broadcasts.get(key).size() 体现出贪心算法的特点，每次都选择最优的</span></span><br><span class="line">                <span class="keyword">if</span> (tempSet.size()&gt;<span class="number">0</span>&amp;&amp;(maxKey==<span class="keyword">null</span>||tempSet.size()&gt;broadcasts.get(key).size()))&#123;</span><br><span class="line">                    maxKey=key;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//maxKey != null，就应该将maxKey加入到 selects</span></span><br><span class="line">            <span class="keyword">if</span> (maxKey!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                selects.add(maxKey);</span><br><span class="line">                <span class="comment">//将maxKey指向的广播电台覆盖的地区，从allAreas中去掉</span></span><br><span class="line">                allAreas.removeAll(broadcasts.get(maxKey));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;得到的结果是：&quot;</span>+selects);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="6-普利姆算法"><a class="markdownIt-Anchor" href="#6-普利姆算法">#</a> 6、普利姆算法</h1>
<h2 id="最小生成树"><a class="markdownIt-Anchor" href="#最小生成树">#</a> 最小生成树</h2>
<p><strong>最小生成树 (Minimum Cost Spanning Tree)，简称 MST。</strong></p>
<ol>
<li>
<p>给定一个带权的无向连通图，如何选取一棵生成树，使树上所有<strong>边上权的总和为最小</strong>，这叫最小生成树</p>
</li>
<li>
<p>N 个顶点，一定有 N-1 条边</p>
</li>
<li>
<p>包含全部顶点</p>
</li>
<li>
<p>N-1 条边都在图中</p>
</li>
</ol>
<p><a href="https://imgtu.com/i/RHpLa6"><img src="https://z3.ax1x.com/2021/07/07/RHpLa6.png" alt="RHpLa6.png"></a></p>
<p>求最小生成树的算法主要是<strong>普里姆算法</strong>和<strong>克鲁斯卡尔算法</strong></p>
<h2 id="简单介绍-5"><a class="markdownIt-Anchor" href="#简单介绍-5">#</a> 简单介绍</h2>
<p>1) 普利姆 (Prim) 算法求最小生成树，也就是在包含 n 个顶点的连通图中，找出只有 (n-1) 条边包含所有 n 个顶点的连通子图，也就是所谓的<strong>极小连通子图</strong></p>
<p>2) 普利姆的算法如下:</p>
<p>(1) 设 G=(V,E) 是连通网，T=(U,D) 是最小生成树，V,U 是顶点集合，E,D 是边的集合</p>
<p>(2) 若从顶点 u 开始构造最小生成树，则从集合 V 中取出顶点 u 放入集合 U 中，标记顶点 v 的 visited [u]=1</p>
<p>(3) 若集合 U 中顶点 ui 与集合 V-U 中的顶点 vj 之间存在边，则寻找这些边中权值最小的边，但不能构成回路，将顶点 vj 加入集合 U 中，将边（ui,vj）加入集合 D 中，标记 visited [vj]=1</p>
<p>(4) 重复步骤②，直到 U 与 V 相等，即所有顶点都被标记为访问过，此时 D 中有 n-1 条边</p>
<p><a href="https://imgtu.com/i/RH99sA"><img src="https://z3.ax1x.com/2021/07/07/RH99sA.png" alt="RH99sA.png"></a></p>
<h2 id="应用场景修理问题"><a class="markdownIt-Anchor" href="#应用场景修理问题">#</a> 应用场景 (修理问题)</h2>
<p><a href="https://imgtu.com/i/RH30vd"><img src="https://z3.ax1x.com/2021/07/07/RH30vd.png" alt="RH30vd.png"></a></p>
<p>1) 有胜利乡有 7 个村庄 (A, B, C, D, E, F, G) ，现在需要修路把 7 个村庄连通</p>
<p>2) 各个村庄的距离用边线表示 (权) ，比如 A – B 距离 5 公里</p>
<p>3) 问：如何修路保证各个村庄都能连通，并且总的修建公路总里程最短？</p>
<p>思路：将 10 条边，连接即可，但是总的里程数不是最小.</p>
<p><strong>正确的思路</strong>，就是尽可能的选择少的路线，并且每条路线最小，保证总里程数最少.</p>
<h2 id="代码展示-4"><a class="markdownIt-Anchor" href="#代码展示-4">#</a> 代码展示</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> demo07;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrimAlgorithm</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//测试看看图是否创建成功</span></span><br><span class="line">        <span class="keyword">char</span>[] data = <span class="keyword">new</span> <span class="keyword">char</span>[]&#123;<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;E&#x27;</span>, <span class="string">&#x27;F&#x27;</span>, <span class="string">&#x27;G&#x27;</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> verxs = data.length;</span><br><span class="line">        <span class="comment">//邻接矩阵的关系使用二维数组表示,10000这个大数，表示两个点不连通</span></span><br><span class="line">        <span class="keyword">int</span>[][] weight = <span class="keyword">new</span> <span class="keyword">int</span>[][]&#123;</span><br><span class="line">                &#123;<span class="number">10000</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">10000</span>, <span class="number">10000</span>, <span class="number">10000</span>, <span class="number">2</span>&#125;,</span><br><span class="line">                &#123;<span class="number">5</span>, <span class="number">10000</span>, <span class="number">10000</span>, <span class="number">9</span>, <span class="number">10000</span>, <span class="number">10000</span>, <span class="number">3</span>&#125;,</span><br><span class="line">                &#123;<span class="number">7</span>, <span class="number">10000</span>, <span class="number">10000</span>, <span class="number">10000</span>, <span class="number">8</span>, <span class="number">10000</span>, <span class="number">10000</span>&#125;,</span><br><span class="line">                &#123;<span class="number">10000</span>, <span class="number">9</span>, <span class="number">10000</span>, <span class="number">10000</span>, <span class="number">10000</span>, <span class="number">4</span>, <span class="number">10000</span>&#125;,</span><br><span class="line">                &#123;<span class="number">10000</span>, <span class="number">10000</span>, <span class="number">8</span>, <span class="number">10000</span>, <span class="number">10000</span>, <span class="number">5</span>, <span class="number">4</span>&#125;,</span><br><span class="line">                &#123;<span class="number">10000</span>, <span class="number">10000</span>, <span class="number">10000</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">10000</span>, <span class="number">6</span>&#125;,</span><br><span class="line">                &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">10000</span>, <span class="number">10000</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">10000</span>&#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//创建一个MGraph对象</span></span><br><span class="line">        MGraph graph=<span class="keyword">new</span> MGraph(verxs);</span><br><span class="line">        <span class="comment">//创建一个MinTree对象</span></span><br><span class="line">        MinTree minTree=<span class="keyword">new</span> MinTree();</span><br><span class="line">        minTree.createGraph(graph,verxs,data,weight);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//输出</span></span><br><span class="line">        minTree.showGraph(graph);</span><br><span class="line">        <span class="comment">//测试普利姆算法</span></span><br><span class="line">        minTree.prim(graph,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建最小生成树 -&gt; 村庄路线图</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinTree</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建图的邻接矩阵</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> graph  图对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> verxs  图对应的顶点个数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data   图的各个顶点的值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> weight 图的邻接矩阵</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createGraph</span><span class="params">(MGraph graph, <span class="keyword">int</span> verxs, <span class="keyword">char</span>[] data, <span class="keyword">int</span>[][] weight)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i, j;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; verxs; i++) &#123; <span class="comment">//顶点</span></span><br><span class="line">            graph.data[i] = data[i];</span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; verxs; j++) &#123;</span><br><span class="line">                graph.weight[i][j] = weight[i][j];</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//显示图的方法 就是显示图的邻接矩阵</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showGraph</span><span class="params">(MGraph graph)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] link : graph.weight) &#123;</span><br><span class="line">            System.out.println(Arrays.toString(link));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  编写Prim算法，生成最小生成树</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> graph  图</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v   表示从图的第几个顶点开始生成 &#x27;A&#x27;-0 &#x27;B&#x27;-1...</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">prim</span><span class="params">(MGraph graph,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">        <span class="comment">//visited[] 标记结点(顶点) 是否被访问过</span></span><br><span class="line">        <span class="keyword">int</span>[] visited=<span class="keyword">new</span> <span class="keyword">int</span>[graph.verxs];</span><br><span class="line">        <span class="comment">//visited[] 默认元素的值都是0，表示没有访问过</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; graph.verxs; i++) &#123;</span><br><span class="line">            visited[i]=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//把当前这个节点标记为已访问</span></span><br><span class="line">        visited[v] = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// h1 和 h2 记录两个顶点的下标</span></span><br><span class="line">        <span class="keyword">int</span> h1=-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> h2=-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> minWeight=<span class="number">10000</span>; <span class="comment">//将 minWeight 初始成一个大叔，后面遍历过程中，会被替换</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt; graph.verxs; k++) &#123; <span class="comment">// 因为有 graph.verxs 个顶点，普利姆算法结束后有 graph.verxs-1 条边</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//这个是确定每一次生成的子图，和那个结点的距离最近</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; graph.verxs; i++) &#123; <span class="comment">// i 结点表示被访问过的结点</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; graph.verxs; j++) &#123; <span class="comment">//j 结点表示没有被访问过的结点</span></span><br><span class="line">                    <span class="keyword">if</span> (visited[i] ==<span class="number">1</span> &amp;&amp; visited[j]==<span class="number">0</span>&amp;&amp;graph.weight[i][j]&lt;minWeight)&#123;</span><br><span class="line">                        <span class="comment">//替换minWeight (寻找已经访问过的结点和未访问过的结点的权值最小的边)</span></span><br><span class="line">                        minWeight=graph.weight[i][j];</span><br><span class="line">                        h1=i;</span><br><span class="line">                        h2=j;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//找到一条边是最小</span></span><br><span class="line">            System.out.println(<span class="string">&quot;边&lt;&quot;</span>+graph.data[h1]+<span class="string">&quot;,&quot;</span>+graph.data[h2]+<span class="string">&quot;&gt;权值为：&quot;</span>+minWeight);</span><br><span class="line">            <span class="comment">//将当前这个节点标记为已经访问</span></span><br><span class="line">            visited[h2] = <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// minWeight 重新设置为最大值 10000</span></span><br><span class="line">            minWeight=<span class="number">10000</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MGraph</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> verxs; <span class="comment">//表示图的节点个数</span></span><br><span class="line">    <span class="keyword">char</span>[] data; <span class="comment">//存放结点数据</span></span><br><span class="line">    <span class="keyword">int</span>[][] weight; <span class="comment">//存放边，就是邻接矩阵</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MGraph</span><span class="params">(<span class="keyword">int</span> verxs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.verxs = verxs;</span><br><span class="line">        data = <span class="keyword">new</span> <span class="keyword">char</span>[verxs];</span><br><span class="line">        weight = <span class="keyword">new</span> <span class="keyword">int</span>[verxs][verxs];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="7-克鲁斯卡尔算法"><a class="markdownIt-Anchor" href="#7-克鲁斯卡尔算法">#</a> 7、克鲁斯卡尔算法</h1>
<h2 id="简单介绍-6"><a class="markdownIt-Anchor" href="#简单介绍-6">#</a> 简单介绍</h2>
<p>1) 克鲁斯卡尔 (Kruskal) 算法，是用来求加权连通图的最小生成树的算法。</p>
<p>2)<strong> 基本思想</strong>：按照权值从小到大的顺序选择 n-1 条边，并保证这 n-1 条边不构成回路</p>
<p>3)<strong> 具体做法</strong>：首先构造一个只含 n 个顶点的森林，然后依权值从小到大从连通网中选择边加入到森林中，并使森林中不产生回路，直至森林变成一棵树为止</p>
<h2 id="思路分析1-最小生成树"><a class="markdownIt-Anchor" href="#思路分析1-最小生成树">#</a> 思路分析 1、最小生成树</h2>
<p>在含有 n 个顶点的连通图中选择 n-1 条边，构成一棵极小连通子图，并使该连通子图中 n-1 条边上权值之和达到最小，则称其为连通网的最小生成树。</p>
<p><a href="https://imgtu.com/i/RH8PIK"><img src="https://z3.ax1x.com/2021/07/07/RH8PIK.png" alt="RH8PIK.png"></a></p>
<p>例如，对于如上图 G4 所示的连通网可以有多棵权值总和不相同的生成树</p>
<p><a href="https://imgtu.com/i/RH8kGD"><img src="https://z3.ax1x.com/2021/07/07/RH8kGD.png" alt="RH8kGD.png"></a></p>
<h2 id="思路分析2-算法图解"><a class="markdownIt-Anchor" href="#思路分析2-算法图解">#</a> 思路分析 2、算法图解</h2>
<p>以上图 G4 为例，来对克鲁斯卡尔进行演示 (假设，用数组 R 保存最小生成树结果)。</p>
<p><a href="https://imgtu.com/i/RH8ARe"><img src="https://z3.ax1x.com/2021/07/07/RH8ARe.png" alt="RH8ARe.png"></a></p>
<p><strong>第 1 步</strong>：将边 &lt;E,F&gt; 加入 R 中。<br>
边 &lt;E,F&gt; 的权值最小，因此将它加入到最小生成树结果 R 中。<br>
<strong>第 2 步</strong>：将边 &lt;C,D&gt; 加入 R 中。<br>
上一步操作之后，边 &lt;C,D&gt; 的权值最小，因此将它加入到最小生成树结果 R 中。<br>
<strong>第 3 步</strong>：将边 &lt;D,E&gt; 加入 R 中。<br>
上一步操作之后，边 &lt;D,E&gt; 的权值最小，因此将它加入到最小生成树结果 R 中。<br>
<strong>第 4 步</strong>：将边 &lt;B,F&gt; 加入 R 中。<br>
上一步操作之后，边 &lt;C,E&gt; 的权值最小，但 &lt; C,E &gt; 会和已有的边构成回路；因此，跳过边 &lt; C,E&gt;。同理，跳过边 &lt; C,F&gt;。将边 &lt; B,F &gt; 加入到最小生成树结果 R 中。<br>
<strong>第 5 步</strong>：将边 &lt;E,G&gt; 加入 R 中。<br>
上一步操作之后，边 &lt;E,G&gt; 的权值最小，因此将它加入到最小生成树结果 R 中。<br>
<strong>第 6 步</strong>：将边 &lt;A,B&gt; 加入 R 中。<br>
上一步操作之后，边 &lt;F,G&gt; 的权值最小，但 &lt; F,G &gt; 会和已有的边构成回路；因此，跳过边 &lt; F,G&gt;。同理，跳过边 &lt; B,C&gt;。将边 &lt; A,B &gt; 加入到最小生成树结果 R 中。</p>
<p>此时，最小生成树构造完成！它包括的边依次是：<strong>&lt;E,F&gt; &lt;C,D&gt; &lt;D,E&gt; &lt;B,F&gt; &lt;E,G&gt; &lt;A,B&gt;</strong></p>
<h2 id="思路分析3-算法分析"><a class="markdownIt-Anchor" href="#思路分析3-算法分析">#</a> 思路分析 3、算法分析</h2>
<p>根据前面介绍的克鲁斯卡尔算法的基本思想和做法，我们能够了解到，克鲁斯卡尔算法重点需要解决的以下两个问题：<br>
<strong>问题一</strong> 对图的所有边按照权值大小进行排序。<br>
<strong>问题二</strong> 将边添加到最小生成树中时，怎么样判断是否形成了回路。</p>
<p>问题一很好解决，采用排序算法进行排序即可。</p>
<p>问题二，处理方式是：记录顶点在 &quot;最小生成树&quot; 中的终点，顶点的终点是 &quot;在最小生成树中与它连通的最大顶点&quot;。然后每次需要将一条边添加到最小生存树时，判断该边的两个顶点的终点是否重合，重合的话则会构成回路。</p>
<h2 id="思路分析4-判断是否构成回路"><a class="markdownIt-Anchor" href="#思路分析4-判断是否构成回路">#</a> 思路分析 4、判断是否构成回路</h2>
<p><a href="https://imgtu.com/i/RH8ExH"><img src="https://z3.ax1x.com/2021/07/07/RH8ExH.png" alt="RH8ExH.png"></a></p>
<p>在将 &lt;E,F&gt; &lt;C,D&gt; &lt;D,E &gt; 加入到最小生成树 R 中之后，这几条边的顶点就都有了终点：</p>
<p>​		<strong>(01)</strong> C 的终点是 F。<br>
<strong>(02)</strong> D 的终点是 F。<br>
<strong>(03)</strong> E 的终点是 F。<br>
​		<strong>(04)</strong> F 的终点是 F。</p>
<p>关于终点的说明：</p>
<ol>
<li>就是将所有顶点按照从小到大的顺序排列好之后；某个顶点的终点就是 &quot;与它连通的最大顶点&quot;。</li>
</ol>
<p>因此，接下来，虽然 &lt;C,E&gt; 是权值最小的边。但是 C 和 E 的终点都是 F，即它们的终点相同，因此，将 &lt; C,E &gt; 加入最小生成树的话，会形成回路。这就是判断回路的方式。也就是说，我们加入的<strong>边</strong>的<strong>两个顶点不能都指向同一个终点</strong>，否则将构成回路。【后面有代码说明】</p>
<h2 id="代码展示-5"><a class="markdownIt-Anchor" href="#代码展示-5">#</a> 代码展示</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> demo08;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">//克鲁斯卡尔算法 解决 公交问题</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KruskalCase</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> edgeNum; <span class="comment">//记录边的个数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">char</span>[] vertexs; <span class="comment">//顶点数组</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[][] matrix; <span class="comment">//邻接矩阵</span></span><br><span class="line">    <span class="comment">//使用 INF 表示两个顶点不能连通</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INF = Integer.MAX_VALUE;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] vertexs = &#123;<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;E&#x27;</span>, <span class="string">&#x27;F&#x27;</span>, <span class="string">&#x27;G&#x27;</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[][] matrix = &#123;</span><br><span class="line">                <span class="comment">/*A     B   C      D   E    F    G  */</span></span><br><span class="line">                <span class="comment">/* A */</span>   &#123;<span class="number">0</span>, <span class="number">12</span>, INF, INF, INF, <span class="number">16</span>, <span class="number">14</span>&#125;,</span><br><span class="line">                <span class="comment">/* B */</span>   &#123;<span class="number">12</span>, <span class="number">0</span>, <span class="number">10</span>, INF, INF, <span class="number">7</span>, INF&#125;,</span><br><span class="line">                <span class="comment">/* C */</span>   &#123;INF, <span class="number">10</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>, INF&#125;,</span><br><span class="line">                <span class="comment">/* D */</span>   &#123;INF, INF, <span class="number">3</span>, <span class="number">0</span>, <span class="number">4</span>, INF, INF&#125;,</span><br><span class="line">                <span class="comment">/* E */</span>   &#123;INF, INF, <span class="number">5</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">8</span>&#125;,</span><br><span class="line">                <span class="comment">/* F */</span>   &#123;<span class="number">16</span>, <span class="number">7</span>, <span class="number">6</span>, INF, <span class="number">2</span>, <span class="number">0</span>, <span class="number">9</span>&#125;,</span><br><span class="line">                <span class="comment">/* G */</span>   &#123;<span class="number">14</span>, INF, INF, INF, <span class="number">8</span>, <span class="number">9</span>, <span class="number">0</span>&#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建KruskalCase 对象实例</span></span><br><span class="line">        KruskalCase kruskalCase = <span class="keyword">new</span> KruskalCase(vertexs, matrix);</span><br><span class="line">        kruskalCase.print();</span><br><span class="line"></span><br><span class="line">        EDate[] edges = kruskalCase.getEdges();</span><br><span class="line">        <span class="comment">//未排序</span></span><br><span class="line">        System.out.println(Arrays.toString(edges));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//已排序</span></span><br><span class="line">        kruskalCase.sortEdge(edges);</span><br><span class="line">        System.out.println(Arrays.toString(edges));</span><br><span class="line"></span><br><span class="line">        kruskalCase.kruskal();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">kruskal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>; <span class="comment">//表示最后结果数组的索引</span></span><br><span class="line">        <span class="keyword">int</span>[] ends = <span class="keyword">new</span> <span class="keyword">int</span>[edgeNum]; <span class="comment">//用于保存 “已有最小生成树” 中的每个顶点在最小生成树中的终点</span></span><br><span class="line">        <span class="comment">//创建结果数组 保存最后的最小生成树</span></span><br><span class="line">        EDate[] rets = <span class="keyword">new</span> EDate[edgeNum];</span><br><span class="line">        <span class="comment">//先获取图中所有的边的集合</span></span><br><span class="line">        EDate[] edges = getEdges();</span><br><span class="line">        System.out.println(<span class="string">&quot;图的边的集合&quot;</span> + Arrays.toString(edges) + <span class="string">&quot;共&quot;</span> + edges.length + <span class="string">&quot;条边&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//按照边的权值大小进行排序（从小到大）</span></span><br><span class="line">        sortEdge(edges);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历 edges 数组，将边添加到最小生成树中时，判断准备加入的边是否构成回路，如果没有，就加入 rets,否则不能加入</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; edgeNum; i++) &#123;</span><br><span class="line">            <span class="comment">//获取到第 i 条边的第一个顶点（起点）</span></span><br><span class="line">            <span class="keyword">int</span> p1 = getPosition(edges[i].start); <span class="comment">//p1</span></span><br><span class="line">            <span class="comment">//获取第 i 条边的第2个顶点</span></span><br><span class="line">            <span class="keyword">int</span> p2 = getPosition(edges[i].end);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//获取p1这个顶点在已有最小生成树中的终点</span></span><br><span class="line">            <span class="keyword">int</span> m = getEnd(ends, p1);</span><br><span class="line">            <span class="comment">//取p1这个顶点在已有最小生成树中的终点</span></span><br><span class="line">            <span class="keyword">int</span> n = getEnd(ends, p2);</span><br><span class="line">            <span class="comment">//判断是否构成回路</span></span><br><span class="line">            <span class="keyword">if</span> (m != n) &#123;<span class="comment">//说明没有构成回路</span></span><br><span class="line">                ends[m] = n; <span class="comment">// 设置m在 “已有最小生成树” 中的终点 &lt;E,F&gt; [0,0,0,0,0,0,0,0,0,0,0,0]</span></span><br><span class="line">                rets[index++] = edges[i];<span class="comment">//有一条边 加入到</span></span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//统计并打印 “最小生成树” ，输出 rets</span></span><br><span class="line">        System.out.println(<span class="string">&quot;最小生成树为&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++) &#123;</span><br><span class="line">            System.out.println(rets[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">KruskalCase</span><span class="params">(<span class="keyword">char</span>[] vertexs, <span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//初始化顶点数和边的个数</span></span><br><span class="line">        <span class="keyword">int</span> vlen = vertexs.length;</span><br><span class="line">        <span class="comment">//初始化顶点,复制拷贝的方式</span></span><br><span class="line">        <span class="keyword">this</span>.vertexs = <span class="keyword">new</span> <span class="keyword">char</span>[vlen];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vertexs.length; i++) &#123;</span><br><span class="line">            <span class="keyword">this</span>.vertexs[i] = vertexs[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//初始化边,使用的是复制拷贝的方式</span></span><br><span class="line">        <span class="keyword">this</span>.matrix = <span class="keyword">new</span> <span class="keyword">int</span>[vlen][vlen];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vlen; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; vlen; j++) &#123;</span><br><span class="line">                <span class="keyword">this</span>.matrix[i][j] = matrix[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//统计边的条数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vlen; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; vlen; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">this</span>.matrix[i][j] != INF) &#123;</span><br><span class="line">                    edgeNum++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//打印邻接矩阵</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;邻接矩阵为：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vertexs.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; vertexs.length; j++) &#123;</span><br><span class="line">                System.out.printf(<span class="string">&quot;%12d\t&quot;</span>, matrix[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//换行处理</span></span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对边的权值进行排序处理冒泡排序</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> edges 边的集合</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sortEdge</span><span class="params">(EDate[] edges)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; edges.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; edges.length - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (edges[j].weight &gt; edges[j + <span class="number">1</span>].weight) &#123;<span class="comment">//交换</span></span><br><span class="line">                    EDate tmp = edges[j];</span><br><span class="line">                    edges[j] = edges[j + <span class="number">1</span>];</span><br><span class="line">                    edges[j + <span class="number">1</span>] = tmp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ch 顶点的值，比如&#x27;A&#x27; &#x27;B&#x27;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回 ch 顶点对应的下标，如果找不到，返回 -1</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getPosition</span><span class="params">(<span class="keyword">char</span> ch)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vertexs.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (vertexs[i] == ch) &#123; <span class="comment">//找到</span></span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//找不到 返回 -1</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 功能：获取图中边，放到EDate[] 数组中，后面我们需要遍历该数组</span></span><br><span class="line"><span class="comment">     * 是通过matrix 邻接矩阵来获取</span></span><br><span class="line"><span class="comment">     * EDate 形式[[&#x27;A&#x27;,&#x27;B&#x27;,12],[&#x27;B&#x27;,&#x27;F&#x27;,7]...]</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> EDate[] getEdges() &#123;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        EDate[] edges = <span class="keyword">new</span> EDate[edgeNum];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vertexs.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; vertexs.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (matrix[i][j] != INF) &#123;</span><br><span class="line">                    edges[index++] = <span class="keyword">new</span> EDate(vertexs[i], vertexs[j], matrix[i][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> edges;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取下标为 i 的顶点的终点，用于后面判断两个顶点的终点是否相同</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ends 数组就是记录了各个顶点对应的终点是哪个， ends 数组是在遍历过程中逐步形成的</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i    表示传入的顶点对应的下标</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回下标为 i的这个顶点对应的终点的下标</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getEnd</span><span class="params">(<span class="keyword">int</span>[] ends, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (ends[i] != <span class="number">0</span>) &#123;</span><br><span class="line">            i = ends[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个类EDate，它的对象实例就是一条边</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EDate</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> start; <span class="comment">//边的一个点</span></span><br><span class="line">    <span class="keyword">char</span> end;  <span class="comment">//边的另一个店</span></span><br><span class="line">    <span class="keyword">int</span> weight; <span class="comment">//边的权值</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">EDate</span><span class="params">(<span class="keyword">char</span> start, <span class="keyword">char</span> end, <span class="keyword">int</span> weight)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.start = start;</span><br><span class="line">        <span class="keyword">this</span>.end = end;</span><br><span class="line">        <span class="keyword">this</span>.weight = weight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重写toString方法，便于输出边</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;EDate&#123;&lt;&quot;</span> + start + <span class="string">&quot;,&quot;</span> + end + <span class="string">&quot;&gt; = &quot;</span> + weight + <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="8-迪杰斯特拉算法"><a class="markdownIt-Anchor" href="#8-迪杰斯特拉算法">#</a> 8、迪杰斯特拉算法</h1>
<h2 id="简单介绍-7"><a class="markdownIt-Anchor" href="#简单介绍-7">#</a> 简单介绍</h2>
<p>迪杰斯特拉 (Dijkstra) 算法是<strong>典型最短路径算法</strong>，用于计算一个结点到其他结点的最短路径。 它的主要特点是以起始点为中心向外层层扩展 (<strong>广度优先</strong>搜索思想)，直到扩展到终点为止</p>
<h2 id="思路分析-2"><a class="markdownIt-Anchor" href="#思路分析-2">#</a> 思路分析</h2>
<p>设置出发顶点为 v，顶点集合 V {v1,v2,vi…}，v 到 V 中各顶点的距离构成距离集合 Dis，Dis {d1,d2,di…}，Dis 集合记录着 v 到图中各顶点的距离 (到自身可以看作 0，v 到 vi 距离对应为 di)</p>
<p>1) 从 Dis 中选择值最小的 di 并移出 Dis 集合，同时移出 V 集合中对应的顶点 vi，此时的 v 到 vi 即为最短路径</p>
<p>2) 更新 Dis 集合，更新规则为：比较 v 到 V 集合中顶点的距离值，与 v 通过 vi 到 V 集合中顶点的距离值，保留值较小的一个 (同时也应该更新顶点的前驱节点为 vi，表明是通过 vi 到达的)</p>
<p>3) 重复执行两步骤，直到最短路径顶点为目标顶点即可结束</p>
<p><a href="https://imgtu.com/i/RH8KdP"><img src="https://z3.ax1x.com/2021/07/07/RH8KdP.png" alt="RH8KdP.png"></a></p>
<h2 id="应用场景-最短路径"><a class="markdownIt-Anchor" href="#应用场景-最短路径">#</a> 应用场景 - 最短路径</h2>
<p><a href="https://imgtu.com/i/RH30vd"><img src="https://z3.ax1x.com/2021/07/07/RH30vd.png" alt="RH30vd.png"></a></p>
<p>1) 战争时期，胜利乡有 7 个村庄 (A, B, C, D, E, F, G) ，现在有六个邮差，从 G 点出发，需要分别把邮件分别送到 A, B, C , D, E, F 六个村庄</p>
<p>2) 各个村庄的距离用边线表示 (权) ，比如 A – B 距离 5 公里</p>
<p>3) 问：如何计算出 G 村庄到 其它各个村庄的最短距离？</p>
<p>4) 如果从其它点出发到各个点的最短距离又是多少？</p>
<h2 id="代码展示-6"><a class="markdownIt-Anchor" href="#代码展示-6">#</a> 代码展示</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> demo09;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DijkstraAlforithm</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] vertex = <span class="keyword">new</span> <span class="keyword">char</span>[]&#123;<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;E&#x27;</span>, <span class="string">&#x27;F&#x27;</span>, <span class="string">&#x27;G&#x27;</span>&#125;;</span><br><span class="line">        <span class="comment">//邻接矩阵</span></span><br><span class="line">        <span class="keyword">int</span>[][] matrix = <span class="keyword">new</span> <span class="keyword">int</span>[vertex.length][vertex.length];</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> N = <span class="number">65535</span>;<span class="comment">//表示不可连接</span></span><br><span class="line">        matrix[<span class="number">0</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;N, <span class="number">5</span>, <span class="number">7</span>, N, N, N, <span class="number">2</span>&#125;;</span><br><span class="line">        matrix[<span class="number">1</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">5</span>, N, N, <span class="number">9</span>, N, N, <span class="number">3</span>&#125;;</span><br><span class="line">        matrix[<span class="number">2</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">7</span>, N, N, N, <span class="number">8</span>, N, N&#125;;</span><br><span class="line">        matrix[<span class="number">3</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;N, <span class="number">9</span>, N, N, N, <span class="number">4</span>, N&#125;;</span><br><span class="line">        matrix[<span class="number">4</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;N, N, <span class="number">8</span>, N, N, <span class="number">5</span>, <span class="number">4</span>&#125;;</span><br><span class="line">        matrix[<span class="number">5</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;N, N, N, <span class="number">4</span>, <span class="number">5</span>, N, <span class="number">6</span>&#125;;</span><br><span class="line">        matrix[<span class="number">6</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">2</span>, <span class="number">3</span>, N, N, <span class="number">4</span>, <span class="number">6</span>, N&#125;;</span><br><span class="line">        <span class="comment">//创建Graph对象</span></span><br><span class="line">        Graph graph = <span class="keyword">new</span> Graph(vertex, matrix);</span><br><span class="line">        <span class="comment">//测试，看看图的邻接矩阵是否OK</span></span><br><span class="line">        graph.show();</span><br><span class="line">        <span class="comment">//测试一把迪杰斯特拉算法</span></span><br><span class="line">        graph.dijkstra(<span class="number">6</span>);</span><br><span class="line">        graph.showDijkstra();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建图</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Graph</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">char</span>[] vertex;  <span class="comment">//顶点数组</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[][] matrix; <span class="comment">//邻接矩阵</span></span><br><span class="line">    <span class="keyword">private</span> VisitedVertex vv; <span class="comment">//已经访问的顶点的集合</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Graph</span><span class="params">(<span class="keyword">char</span>[] vertex, <span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.vertex = vertex;</span><br><span class="line">        <span class="keyword">this</span>.matrix = matrix;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//显示图</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] link : matrix) &#123;</span><br><span class="line">            System.out.println(Arrays.toString(link));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//迪杰斯特拉算法实现</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dijkstra</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        vv = <span class="keyword">new</span> VisitedVertex(vertex.length, index);</span><br><span class="line">        update(index); <span class="comment">//更新index顶点到周围顶点的距离和前驱顶点</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; vertex.length; j++) &#123;</span><br><span class="line">            index=vv.updateArr();<span class="comment">//选择并返回新的访问顶点</span></span><br><span class="line">            update(index); <span class="comment">//更新index顶点到周围顶点的距离和前驱顶点</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//更新index下标顶点到周围顶点的距离和中欧为顶点的前驱顶点</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//根据遍历我们的邻接矩阵 matrix[index]</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; matrix[index].length; j++) &#123;</span><br><span class="line">            <span class="comment">// len 含义是：出发顶点到index顶点的距离 + 从 index 到 j 顶点的距离的和</span></span><br><span class="line">            len = vv.getDis(index) + matrix[index][j];</span><br><span class="line">            <span class="comment">//如果 j 顶点没有被访问过，并且len 小于出发顶点到 j 顶点 的距离，就需要更新</span></span><br><span class="line">            <span class="keyword">if</span> (!vv.in(j) &amp;&amp; len &lt; vv.getDis(j)) &#123;</span><br><span class="line">                vv.updatePre(j, index); <span class="comment">//更新 j 顶点的前驱为 index 顶点</span></span><br><span class="line">                vv.updateDis(j, len);  <span class="comment">// 更新出发顶点到 j 顶点的距离</span></span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showDijkstra</span><span class="params">()</span></span>&#123;</span><br><span class="line">        vv.show();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//已访问顶点的集合</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VisitedVertex</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//记录各个顶点是否访问，1表示访问过，0未访问，会动态更新</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] already_arr;</span><br><span class="line">    <span class="comment">//每个下标对应的值为前一个顶点下标，会动态更新</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] pre_visited;</span><br><span class="line">    <span class="comment">//记录出发顶点到其他所有顶点的距离，比如 G 为出发顶点，就会记录G到其他顶点的距离，会动态更新，求出的最短距离就会记录到dis</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] dis;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造器</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> length 表示顶点的个数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index  表示出发顶点对应的下标 比如G顶点，下标就是6</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">VisitedVertex</span><span class="params">(<span class="keyword">int</span> length, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.already_arr = <span class="keyword">new</span> <span class="keyword">int</span>[length];</span><br><span class="line">        <span class="keyword">this</span>.pre_visited = <span class="keyword">new</span> <span class="keyword">int</span>[length];</span><br><span class="line">        <span class="keyword">this</span>.dis = <span class="keyword">new</span> <span class="keyword">int</span>[length];</span><br><span class="line">        <span class="comment">//初始化 dis 数组</span></span><br><span class="line">        Arrays.fill(dis, <span class="number">65535</span>);</span><br><span class="line">        <span class="keyword">this</span>.already_arr[index] = <span class="number">1</span>; <span class="comment">//设置出发订单被访问为1</span></span><br><span class="line">        <span class="keyword">this</span>.dis[index] = <span class="number">0</span>;<span class="comment">//设置出发顶点的访问距离为0</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断index顶点是否被访问过</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 如果被访问过，就返回true，否则返回false</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">in</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> already_arr[index] == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 更新出发顶点到index顶点的距离</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> len</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateDis</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">        dis[index] = len;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 更新pre这个顶点的前驱顶点为index顶点</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pre</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updatePre</span><span class="params">(<span class="keyword">int</span> pre, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        pre_visited[pre] = index;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回出发顶点到index顶点的距离</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getDis</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dis[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//继续选择并返回新的访问顶点，比如G点完后，就是A点作为新的访问顶点（注意不是出发顶点）</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">updateArr</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> min = <span class="number">65535</span>, index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; already_arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (already_arr[i] == <span class="number">0</span> &amp;&amp; dis[i] &lt; min) &#123;</span><br><span class="line">                min = dis[i];</span><br><span class="line">                index = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//更新index，顶点被访问过</span></span><br><span class="line">        already_arr[index]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//显示最后的结果</span></span><br><span class="line">    <span class="comment">//即将三个数组的情况输出</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println();</span><br><span class="line">        <span class="comment">//输出already_arr</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : already_arr) &#123;</span><br><span class="line">            System.out.print(i+<span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">        <span class="comment">//输出pre_visited</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : pre_visited)&#123;</span><br><span class="line">            System.out.print(i+<span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">        <span class="comment">//输出dis</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : dis)&#123;</span><br><span class="line">            System.out.print(i+<span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="9-弗洛伊德算法"><a class="markdownIt-Anchor" href="#9-弗洛伊德算法">#</a> 9、弗洛伊德算法</h1>
<h2 id="简单介绍-8"><a class="markdownIt-Anchor" href="#简单介绍-8">#</a> 简单介绍</h2>
<p>1、和 Dijkstra 算法一样，弗洛伊德 (Floyd) 算法也是一种用于寻找给定的加权图中顶点间最短路径的算法。该算法名称以创始人之一、1978 年图灵奖获得者、斯坦福大学计算机科学系教授<strong>罗伯特・弗洛伊德</strong>命名</p>
<p>2、弗洛伊德算法 (Floyd) 计算图中各个顶点之间的最短路径</p>
<p>3、迪杰斯特拉算法用于计算图中某一个顶点到其他顶点的最短路径。</p>
<p>4、<strong>弗洛伊德算法 VS 迪杰斯特拉算法</strong>：迪杰斯特拉算法通过<strong>选定的被访问顶点</strong>，求出从出<strong>发访问顶点到其他顶点的最短路径</strong>；弗洛伊德算法中<strong>每一个顶点都是出发访问点</strong>，所以需要将每一个顶点看做被访问顶点，求出从<strong>每一个顶点到其他顶点的最短路径</strong>。</p>
<h2 id="思路分析-3"><a class="markdownIt-Anchor" href="#思路分析-3">#</a> 思路分析</h2>
<p>1) 设置顶点 vi 到顶点 vk 的最短路径已知为 Lik，顶点 vk 到 vj 的最短路径已知为 Lkj，顶点 vi 到 vj 的路径为 Lij，则 vi 到 vj 的最短路径为：min ((Lik+Lkj),Lij)，vk 的取值为图中所有顶点，则可获得 vi 到 vj 的最短路径</p>
<p>2) 至于 vi 到 vk 的最短路径 Lik 或者 vk 到 vj 的最短路径 Lkj，是以同样的方式获得</p>
<p>3) 弗洛伊德 (Floyd) 算法图解分析 - 举例说明</p>
<p><a href="https://imgtu.com/i/RH83Rg"><img src="https://z3.ax1x.com/2021/07/07/RH83Rg.png" alt="RH83Rg.png"></a></p>
<h2 id="应用场景-3"><a class="markdownIt-Anchor" href="#应用场景-3">#</a> 应用场景</h2>
<p><a href="https://imgtu.com/i/RH30vd"><img src="https://z3.ax1x.com/2021/07/07/RH30vd.png" alt="RH30vd.png"></a></p>
<p>1) 战争时期，胜利乡有 7 个村庄 (A, B, C, D, E, F, G) ，现在有六个邮差，从 G 点出发，需要分别把邮件分别送到 A, B, C , D, E, F 六个村庄</p>
<p>2) 各个村庄的距离用边线表示 (权) ，比如 A – B 距离 5 公里</p>
<p>3) 问：如何计算出<strong>各村庄</strong>到 <strong>其它各村庄</strong>的最短距离？</p>
<h2 id="代码展示-7"><a class="markdownIt-Anchor" href="#代码展示-7">#</a> 代码展示</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> demo10;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">//弗洛伊德算法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FloydAlgorithm</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//测试看看图是否创建成功</span></span><br><span class="line">        <span class="keyword">char</span>[] vertex = &#123;<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;E&#x27;</span>, <span class="string">&#x27;F&#x27;</span>, <span class="string">&#x27;G&#x27;</span>&#125;;</span><br><span class="line">        <span class="comment">//创建邻接矩阵</span></span><br><span class="line">        <span class="keyword">int</span>[][] matrix = <span class="keyword">new</span> <span class="keyword">int</span>[vertex.length][vertex.length];</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> N = <span class="number">65535</span>;</span><br><span class="line">        matrix[<span class="number">0</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">0</span>, <span class="number">5</span>, <span class="number">7</span>, N, N, N, <span class="number">2</span>&#125;;</span><br><span class="line">        matrix[<span class="number">1</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">5</span>, <span class="number">0</span>, N, <span class="number">9</span>, N, N, <span class="number">3</span>&#125;;</span><br><span class="line">        matrix[<span class="number">2</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">7</span>, N, <span class="number">0</span>, N, <span class="number">8</span>, N, N&#125;;</span><br><span class="line">        matrix[<span class="number">3</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;N, <span class="number">9</span>, N, <span class="number">0</span>, N, <span class="number">4</span>, N&#125;;</span><br><span class="line">        matrix[<span class="number">4</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;N, N, <span class="number">8</span>, N, <span class="number">0</span>, <span class="number">5</span>, <span class="number">4</span>&#125;;</span><br><span class="line">        matrix[<span class="number">5</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;N, N, N, <span class="number">4</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">6</span>&#125;;</span><br><span class="line">        matrix[<span class="number">6</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">2</span>, <span class="number">3</span>, N, N, <span class="number">4</span>, <span class="number">6</span>, <span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建一个图对象</span></span><br><span class="line">        Graph graph = <span class="keyword">new</span> Graph(vertex.length, matrix, vertex);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//调用 floyd()</span></span><br><span class="line">        graph.floyd();</span><br><span class="line">        graph.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建图</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Graph</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">char</span>[] vertex; <span class="comment">//存放顶点数组</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[][] dis; <span class="comment">//保存从各个顶点出发到其他顶点的距离，最后结果也保存在该数组中</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[][] pre; <span class="comment">//保存到达目标顶点的前驱顶点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造器</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> length 大小</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> matrix 邻接矩阵</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> vertex 顶点数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Graph</span><span class="params">(<span class="keyword">int</span> length, <span class="keyword">int</span>[][] matrix, <span class="keyword">char</span>[] vertex)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.vertex = vertex;</span><br><span class="line">        <span class="keyword">this</span>.dis = matrix;</span><br><span class="line">        <span class="keyword">this</span>.pre = <span class="keyword">new</span> <span class="keyword">int</span>[length][length];</span><br><span class="line">        <span class="comment">//对pre数组初始化，存放的是前驱顶点的下标</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            Arrays.fill(pre[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//显示方法，显示dis数组和pre数组</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//为了便于查看</span></span><br><span class="line">        <span class="keyword">char</span>[] vertex = &#123;<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;E&#x27;</span>, <span class="string">&#x27;F&#x27;</span>, <span class="string">&#x27;G&#x27;</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; dis.length; k++) &#123;</span><br><span class="line">            <span class="comment">//先将pre数组输出的一行数据</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; dis.length; i++) &#123;</span><br><span class="line">                System.out.print(vertex[pre[k][i]] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//输出dis 的一行数据</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; dis.length; i++) &#123;</span><br><span class="line">                System.out.print(<span class="string">&quot;(&quot;</span> + vertex[k] + <span class="string">&quot;到&quot;</span> + vertex[i] + <span class="string">&quot;的最短路径是&quot;</span> + dis[k][i] + <span class="string">&quot;) &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//弗洛伊德算法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">floyd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>; <span class="comment">//变量保存距离</span></span><br><span class="line">        <span class="comment">//对中间顶点遍历，k就是中间顶点下标</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; dis.length; k++) &#123;</span><br><span class="line">            <span class="comment">//从 i 顶点开始出发 [&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;, &#x27;D&#x27;, &#x27;E&#x27;, &#x27;F&#x27;, &#x27;G&#x27;]</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; dis.length; i++) &#123;</span><br><span class="line">                <span class="comment">//到达终点 j [&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;, &#x27;D&#x27;, &#x27;E&#x27;, &#x27;F&#x27;, &#x27;G&#x27;]</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; dis.length; j++) &#123;</span><br><span class="line">                    len = dis[i][k] + dis[k][j]; <span class="comment">// =&gt; 求出从 i 顶点出发，经过k中间顶点，到达j顶点距离</span></span><br><span class="line">                    <span class="keyword">if</span> (len &lt; dis[i][j]) &#123; <span class="comment">//如果len 小于 dis[i][j]</span></span><br><span class="line">                        dis[i][j] = len; <span class="comment">// 更新距离</span></span><br><span class="line">                        pre[i][j] = pre[k][j]; <span class="comment">//更新前驱顶点</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="10-马踏棋盘算法"><a class="markdownIt-Anchor" href="#10-马踏棋盘算法">#</a> 10、马踏棋盘算法</h1>
<h2 id="游戏展示"><a class="markdownIt-Anchor" href="#游戏展示">#</a> 游戏展示</h2>
<p><strong>马踏棋盘算法介绍和游戏演示</strong></p>
<p>1) 马踏棋盘算法也被称为骑士周游问题</p>
<p>2) 将马随机放在国际象棋的 8×8 棋盘 Board [0～7][0～7] 的某个方格中，马按走棋规则 (<strong>马走日字</strong>) 进行移动。要求每个方格只进入一次，走遍棋盘上全部 64 个方格</p>
<p><a href="https://imgtu.com/i/RH8ad0"><img src="https://z3.ax1x.com/2021/07/07/RH8ad0.png" alt="RH8ad0.png"></a></p>
<h2 id="思路分析-4"><a class="markdownIt-Anchor" href="#思路分析-4">#</a> 思路分析</h2>
<p>1) 马踏棋盘问题 (骑士周游问题) 实际上是图的深度优先搜索 (DFS) 的应用。</p>
<p>2) 如果使用回溯（就是深度优先搜索）来解决，假如马儿踏了 53 个点，如图：走到了第 53 个，坐标（1,0），发现已经走到尽头，没办法，那就只能回退了，查看其他的路径，就在棋盘上不停的回溯…… ，思路分析 + 代码实现</p>
<p>3) 分析第一种方式的问题，并使用贪心算法（greedyalgorithm）进行优化。解决马踏棋盘问题.</p>
<p>使用前面的游戏来验证算法是否正确</p>
<h2 id="解决步骤"><a class="markdownIt-Anchor" href="#解决步骤">#</a> 解决步骤</h2>
<ol>
<li>创建棋盘 chessBoard , 是一个二维数组</li>
<li>将当前位置设置为已经访问，然后根据当前位置，计算马儿还能走哪些位置，并放入到一个集合中 (ArrayList), 最多有 8 个位置， 每走一步，就使用 step+1</li>
<li>遍历 ArrayList 中存放的所有位置，看看哪个可以走通，如果走通，就继续，走不通，就<strong>回溯</strong>.</li>
<li>判断马儿是否完成了任务，使用   step 和应该走的步数比较 ， 如果没有达到数量，则表示没有完成任务，将整个棋盘置 0</li>
</ol>
<p><strong>注意：马儿不同的走法（策略），会得到不同的结果，效率也会有影响 (优化)</strong></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">//创建一个Point</span><br><span class="line">Point p1 = new Point();</span><br><span class="line">if((p1.x = curPoint.x - 2) &gt;= 0 <span class="built_in">&amp;</span><span class="built_in">&amp;</span> (p1.y = curPoint.y -1) &gt;= 0) &#123;</span><br><span class="line">	ps.add(new Point(p1));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>使用贪心算法对原来的算法优化</strong></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">1. 我们获取当前位置，可以走的下一个位置的集合</span><br><span class="line">//获取当前位置可以走的下一个位置的集合 </span><br><span class="line">ArrayList&lt;Point&gt; ps = next(new Point(column, row));</span><br><span class="line">2. 我们需要对 ps 中所有的Point 的下一步的所有集合的数目，进行非递减排序,就ok ,  </span><br><span class="line">	9, 7, 6, 5, 3, 2, 1 //递减排序</span><br><span class="line">	1, 2, 3, 4, 5, 6, 10, //递增排序</span><br><span class="line"></span><br><span class="line">	1, 2, 2, 2, 3, 3, 4, 5, 6 // 非递减  递增，但有重复数</span><br><span class="line">	9, 7, 6, 6, 6, 5, 5, 3, 2, 1  //非递增  递减，但有重复数</span><br></pre></td></tr></table></figure>
<h2 id="代码展示-8"><a class="markdownIt-Anchor" href="#代码展示-8">#</a> 代码展示</h2>
<p><a href="https://imgtu.com/i/RH8ad0"><img src="https://z3.ax1x.com/2021/07/07/RH8ad0.png" alt="RH8ad0.png"></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> demo11;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.awt.*;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HorseChessborad</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> X; <span class="comment">//表示棋盘的列数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> Y; <span class="comment">//表示棋盘的行数</span></span><br><span class="line">    <span class="comment">//创建一个数组，标记棋盘的各个位置是否被访问过</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span>[] visited;</span><br><span class="line">    <span class="comment">//使用一个属性标记是否棋盘的所有位置都被标记</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> finished; <span class="comment">//如果为true,表示成功</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;骑士周游算法，开始执行~~&quot;</span>);</span><br><span class="line">        <span class="comment">//测试骑士周游算法是否正确</span></span><br><span class="line">        X=<span class="number">8</span>;</span><br><span class="line">        Y=<span class="number">8</span>;</span><br><span class="line">        <span class="keyword">int</span> row=<span class="number">1</span>; <span class="comment">//马儿初始位置的行，从1开始编号</span></span><br><span class="line">        <span class="keyword">int</span> column=<span class="number">1</span>; <span class="comment">//马儿初始位置的列，从1开始编号</span></span><br><span class="line">        <span class="comment">//创建棋盘</span></span><br><span class="line">        <span class="keyword">int</span>[][] chessboard=<span class="keyword">new</span> <span class="keyword">int</span>[X][Y];</span><br><span class="line">        visited=<span class="keyword">new</span> <span class="keyword">boolean</span>[X*Y];<span class="comment">// 初始值都是false</span></span><br><span class="line">        <span class="comment">//测试耗时</span></span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        traversalChessboard(chessboard,row-<span class="number">1</span>,column-<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;共耗时：&quot;</span>+(end-start)+<span class="string">&quot;毫秒&quot;</span>);</span><br><span class="line">        <span class="comment">//输出棋盘的最后情况</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] rows:chessboard)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> step:rows)&#123;</span><br><span class="line">                System.out.print(step+<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 完成骑士周游问题的算法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> chessboard 棋盘</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> row        马儿当前的位置的行 从0开始</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> column     马儿当前的位置的列 从0开始</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> step       是第几步，初始位置就是第一步</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">traversalChessboard</span><span class="params">(<span class="keyword">int</span>[][] chessboard, <span class="keyword">int</span> row, <span class="keyword">int</span> column, <span class="keyword">int</span> step)</span> </span>&#123;</span><br><span class="line">        chessboard[row][column] = step;</span><br><span class="line">        <span class="comment">//标记该位置已访问</span></span><br><span class="line">        visited[row * X + column] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">//获取当前位置可以走的下一个位置的集合</span></span><br><span class="line">        ArrayList&lt;Point&gt; points = next(<span class="keyword">new</span> Point(column, row));</span><br><span class="line">        <span class="comment">//对points进行排序，排序的规则就是对points的所有的Point对象的下一步的位置的数目，进行非递减排序</span></span><br><span class="line">        <span class="comment">//优化方法</span></span><br><span class="line">        sort(points);</span><br><span class="line">        <span class="comment">//遍历points</span></span><br><span class="line">        <span class="keyword">while</span> (!points.isEmpty()) &#123;</span><br><span class="line">            Point p = points.remove(<span class="number">0</span>);<span class="comment">//取出下一个可以走的位置</span></span><br><span class="line">            <span class="comment">//判断该点是否已经访问过</span></span><br><span class="line">            <span class="keyword">if</span> (!visited[p.y * X + p.x]) &#123;<span class="comment">//说明还没有访问过</span></span><br><span class="line">                traversalChessboard(chessboard, p.y, p.x, step + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断马儿是否完成任务，使用 step 和应该走的步数比较</span></span><br><span class="line">        <span class="comment">//如果没有达到数量，则表示没有完成任务，将整个棋盘置 0</span></span><br><span class="line">        <span class="comment">//说明</span></span><br><span class="line">        <span class="comment">//step &lt; X * Y 成立的情况有两种</span></span><br><span class="line">        <span class="comment">//1. 棋盘到目前位置，仍然没有走完</span></span><br><span class="line">        <span class="comment">//2. 棋盘处于一个回溯过程</span></span><br><span class="line">        <span class="keyword">if</span> (step &lt; X * Y &amp;&amp; !finished) &#123;</span><br><span class="line">            chessboard[row][column] = <span class="number">0</span>;</span><br><span class="line">            visited[row * X + column] = <span class="keyword">false</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            finished=<span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 功能：根据当前位置（Point），计算马儿还能走哪些位置（Point），并放入到一个集合中（ArrayList），最多有8个位置</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> curPoint</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ArrayList&lt;Point&gt; <span class="title">next</span><span class="params">(Point curPoint)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建一个ArrayList</span></span><br><span class="line">        ArrayList&lt;Point&gt; points = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">//创建一个Point</span></span><br><span class="line">        Point p1 = <span class="keyword">new</span> Point();</span><br><span class="line">        <span class="comment">//判断马儿能走5的位置（根据上文展示的图判断）</span></span><br><span class="line">        <span class="keyword">if</span> ((p1.x = curPoint.x - <span class="number">2</span>) &gt;= <span class="number">0</span> &amp;&amp; (p1.y = curPoint.y - <span class="number">1</span>) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            points.add(<span class="keyword">new</span> Point(p1));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断马儿能走6的位置（根据上文展示的图判断）</span></span><br><span class="line">        <span class="keyword">if</span> ((p1.x = curPoint.x - <span class="number">1</span>) &gt;= <span class="number">0</span> &amp;&amp; (p1.y = curPoint.y - <span class="number">2</span>) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            points.add(<span class="keyword">new</span> Point(p1));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断马儿能走7的位置（根据上文展示的图判断）</span></span><br><span class="line">        <span class="keyword">if</span> ((p1.x = curPoint.x + <span class="number">1</span>) &lt; X &amp;&amp; (p1.y = curPoint.y - <span class="number">2</span>) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            points.add(<span class="keyword">new</span> Point(p1));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断马儿能走0的位置（根据上文展示的图判断）</span></span><br><span class="line">        <span class="keyword">if</span> ((p1.x = curPoint.x + <span class="number">2</span>) &lt; X &amp;&amp; (p1.y = curPoint.y - <span class="number">1</span>) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            points.add(<span class="keyword">new</span> Point(p1));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断马儿能走1的位置（根据上文展示的图判断）</span></span><br><span class="line">        <span class="keyword">if</span> ((p1.x = curPoint.x + <span class="number">2</span>) &lt; X &amp;&amp; (p1.y = curPoint.y + <span class="number">1</span>) &lt; Y) &#123;</span><br><span class="line">            points.add(<span class="keyword">new</span> Point(p1));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断马儿能走2的位置（根据上文展示的图判断）</span></span><br><span class="line">        <span class="keyword">if</span> ((p1.x = curPoint.x + <span class="number">1</span>) &lt; X &amp;&amp; (p1.y = curPoint.y + <span class="number">2</span>) &lt; Y) &#123;</span><br><span class="line">            points.add(<span class="keyword">new</span> Point(p1));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断马儿能走3的位置（根据上文展示的图判断）</span></span><br><span class="line">        <span class="keyword">if</span> ((p1.x = curPoint.x - <span class="number">1</span>) &gt;= <span class="number">0</span> &amp;&amp; (p1.y = curPoint.y + <span class="number">2</span>) &lt; Y) &#123;</span><br><span class="line">            points.add(<span class="keyword">new</span> Point(p1));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断马儿能走4的位置（根据上文展示的图判断）</span></span><br><span class="line">        <span class="keyword">if</span> ((p1.x = curPoint.x - <span class="number">2</span>) &gt;= <span class="number">0</span> &amp;&amp; (p1.y = curPoint.y + <span class="number">1</span>) &lt; Y) &#123;</span><br><span class="line">            points.add(<span class="keyword">new</span> Point(p1));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> points;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//优化</span></span><br><span class="line">    <span class="comment">//根据当前这一步的所有的下一步的选择位置，进行非递减排序,减少回溯的可能</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(ArrayList&lt;Point&gt; points)</span></span>&#123;</span><br><span class="line">        points.sort(<span class="keyword">new</span> Comparator&lt;Point&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Point o1, Point o2)</span> </span>&#123;</span><br><span class="line">                <span class="comment">//获取到o1点的下一步的所有的位置个数</span></span><br><span class="line">                <span class="keyword">int</span> count1 = next(o1).size();</span><br><span class="line">                <span class="comment">//获取到o2点的下一步的所有的位置个数</span></span><br><span class="line">                <span class="keyword">int</span> count2 = next(o2).size();</span><br><span class="line">                <span class="keyword">if</span> (count1&lt;count2)&#123;</span><br><span class="line">                    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span> (count1==count2)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>14.常用10种算法</category>
      </categories>
      <tags>
        <tag>算法与数据结构</tag>
        <tag>二分查找算法</tag>
        <tag>分治算法</tag>
        <tag>动态规划算法</tag>
        <tag>KMP算法</tag>
        <tag>贪心算法</tag>
        <tag>普利姆算法</tag>
        <tag>克鲁斯卡尔算法</tag>
        <tag>迪杰斯特拉算法</tag>
        <tag>弗洛伊德算法</tag>
        <tag>马踏棋盘算法</tag>
      </tags>
  </entry>
</search>
