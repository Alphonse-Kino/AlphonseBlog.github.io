{
    "version": "https://jsonfeed.org/version/1",
    "title": "AlphonseKino • All posts by \"b树\" tag",
    "description": "",
    "home_page_url": "https://alphonse-Kino.github.io",
    "items": [
        {
            "id": "https://alphonse-kino.github.io/2021/07/08/12.%E5%A4%9A%E8%B7%AF%E6%9F%A5%E6%89%BE%E6%A0%91/",
            "url": "https://alphonse-kino.github.io/2021/07/08/12.%E5%A4%9A%E8%B7%AF%E6%9F%A5%E6%89%BE%E6%A0%91/",
            "title": "多路查找树",
            "date_published": "2021-07-08T14:03:46.220Z",
            "content_html": "<h2 id=\"二叉树存在的问题\"><a href=\"#二叉树存在的问题\" class=\"headerlink\" title=\"二叉树存在的问题\"></a>二叉树存在的问题</h2><p>二叉树的操作效率较高，但是也存在问题, 请看下面的二叉树</p>\n<p><a href=\"https://imgtu.com/i/R7fPMj\"><img src=\"https://z3.ax1x.com/2021/07/07/R7fPMj.png\" alt=\"R7fPMj.png\"></a></p>\n<p>1)<strong>二叉树需要加载到内存的，如果二叉树的节点少，没有什么问题，但是如果二叉树的节点很多(比如1亿)， 就存在如下问题:</strong></p>\n<p>2)<strong>问题1：在构建二叉树时，需要多次进行i/o操作(海量数据存在数据库或文件中)，节点海量，构建二叉树时，速度有影响</strong></p>\n<p>3)<strong>问题2：节点海量，也会造成二叉树的高度很大，会降低操作速度.</strong></p>\n<h2 id=\"多叉树\"><a href=\"#多叉树\" class=\"headerlink\" title=\"多叉树\"></a>多叉树</h2><ul>\n<li><p>在二叉树中，每个节点有数据项，最多有两个子节点。1)如果<strong>允许每个节点可以有更多的数据项和更多的子节点</strong>，就是<strong>多叉树（multiway tree）</strong></p>\n</li>\n<li><p><strong>后面我们讲解的2-3树，2-3-4树就是多叉树，多叉树通过重新组织节点，减少树的高度，能对二叉树进行优化。</strong></p>\n</li>\n<li><p><strong>下面2-3树就是一颗多叉树</strong></p>\n</li>\n</ul>\n<p><a href=\"https://imgtu.com/i/R7fAZq\"><img src=\"https://z3.ax1x.com/2021/07/07/R7fAZq.png\" alt=\"R7fAZq.png\"></a></p>\n<h2 id=\"B树\"><a href=\"#B树\" class=\"headerlink\" title=\"B树\"></a>B树</h2><p>B树通过重新组织节点，降低树的高度，并且减少i/o读写次数来提升效率。</p>\n<p><a href=\"https://imgtu.com/i/R7fnWF\"><img src=\"https://z3.ax1x.com/2021/07/07/R7fnWF.png\" alt=\"R7fnWF.png\"></a>1)<strong>如图B树通过重新组织节点， 降低了树的高度.</strong></p>\n<p>2)<strong>文件系统及数据库系统的设计者利用了磁盘预读原理，将一个节点的大小设为等于一个页(页得大小通常为4k)，这样每个节点只需要一次I/O就可以完全载入</strong></p>\n<p>3)将树的度M设置为1024，在600亿个元素中最多只需要4次I/O操作就可以读取到想要的元素, B树(B+)广泛应用于文件存储系统以及数据库系统中</p>\n<p>​        结点的度：就是一个结点下面的子树个数有几个</p>\n<p>​        树的度：指定所有的结点里面度的最大值，就是树的度</p>\n<h2 id=\"2-3树\"><a href=\"#2-3树\" class=\"headerlink\" title=\"2-3树\"></a>2-3树</h2><p>2-3树是最简单的B树结构，有以下特点</p>\n<ol>\n<li><strong>2-3树的所有叶子节点都在同一层（只要是B树都满足这个条件）</strong></li>\n<li>有两个子节点的节点叫做二节点，二节点要么没有子节点，要么有两个子节点</li>\n<li>有三个子节点的节点叫做三节点，三节点要么没有子节点，要么有三个子节点</li>\n<li>2-3树是由二节点和三节点构成的数</li>\n</ol>\n<h3 id=\"实例\"><a href=\"#实例\" class=\"headerlink\" title=\"实例\"></a>实例</h3><p>问题：将数列{16, 24, 12, 32, 14, 26, 34, 10, 8, 28, 38, 20} 构建成2-3树，并保证数据插入的<br> 大小顺序。(演示一下构建2-3树的过程.)</p>\n<p><strong>插入规则:</strong></p>\n<ol>\n<li><p>2-3树的所有叶子节点都在同一层.(只要是B树都满足这个条件)</p>\n</li>\n<li><p>有两个子节点的节点叫二节点，二节点要么没有子节点，要么有两个子节点.</p>\n</li>\n<li><p>有三个子节点的节点叫三节点，三节点要么没有子节点，要么有三个子节点</p>\n</li>\n<li><p>当按照规则插入一个数到某个节点时，不能满足上面三个要求，就需要拆，先向上拆，如果上层满，则拆本层，后仍然需要满足上面3个条件。 </p>\n</li>\n<li><p>对于三节点的子树的值大小仍然遵守(BST 二叉排序树)的规则</p>\n</li>\n</ol>\n<p><a href=\"https://imgtu.com/i/R7fQy9\"><img src=\"https://z3.ax1x.com/2021/07/07/R7fQy9.png\" alt=\"R7fQy9.png\"></a></p>\n<p><a href=\"https://imgtu.com/i/R7f8dx\"><img src=\"https://z3.ax1x.com/2021/07/07/R7f8dx.png\" alt=\"R7f8dx.png\"></a></p>\n<h2 id=\"B树-1\"><a href=\"#B树-1\" class=\"headerlink\" title=\"B树\"></a>B树</h2><p><strong><a href=\"\">B-tree</a><strong>树即<a href=\"\">B树</a><strong>，B即Balanced，平衡的意思。有人把B-tree翻译成B-树，容易让人产生误解。会以为B-树是一种树，而B树又是另一种树。</strong>实际上，</strong>B-tree就是指的B树。</strong></p>\n<p>前面已经介绍了2-3树和2-3-4树，他们就是B树(英语：B-tree 也写成B-树)，这里我们再做一个说明，我们在学习Mysql时，经常听到说某种类型的索引是基于B树或者B+树的，如图:</p>\n<p><a href=\"https://imgtu.com/i/R7fYFK\"><img src=\"https://z3.ax1x.com/2021/07/07/R7fYFK.png\" alt=\"R7fYFK.png\"></a></p>\n<p><strong>B树的说明：</strong></p>\n<ol>\n<li><p>B树的阶：节点的最多子节点个数。比如2-3树的阶是3，2-3-4树的阶是4</p>\n</li>\n<li><p>B-树的搜索，从根结点开始，对结点内的关键字（有序）序列进行二分查找，如果命中则结束，否则进入查询关键字所属范围的儿子结点；重复，直到所对应的儿子指针为空，或已经是叶子结点</p>\n</li>\n<li><p>关键字集合分布在整颗树中, 即叶子节点和非叶子节点都存放数据.</p>\n</li>\n<li><p>搜索有可能在非叶子结点结束</p>\n</li>\n<li><p>其搜索性能等价于在关键字全集内做一次二分查找</p>\n</li>\n</ol>\n<h2 id=\"B-树\"><a href=\"#B-树\" class=\"headerlink\" title=\"B+树\"></a>B+树</h2><p>B+树是B树的变体，也是一种多路搜索树。</p>\n<p><a href=\"https://imgtu.com/i/R7fwyd\"><img src=\"https://z3.ax1x.com/2021/07/07/R7fwyd.png\" alt=\"R7fwyd.png\"></a></p>\n<p><strong>B+树的说明:</strong></p>\n<ol>\n<li><p>B+树的搜索与B树也基本相同，区别是B+树只有达到叶子结点才命中（B树可以在非叶子结点命中），其性能也等价于在关键字全集做一次二分查找</p>\n</li>\n<li><p>所有<strong>关键字都出现在叶子结点的链表中</strong>（即数据只能在叶子节点【也叫稠密索引】），且链表中的关键字(数据)恰好是有序的。</p>\n</li>\n<li><p>不可能在非叶子结点命中</p>\n</li>\n<li><p>非叶子结点相当于是叶子结点的索引（稀疏索引），叶子结点相当于是存储（关键字）数据的数据层</p>\n</li>\n<li><p>更适合文件索引系统</p>\n</li>\n<li><p>B树和B+树各有自己的应用场景，不能说B+树<strong>完全比</strong>B树好，反之亦然.</p>\n</li>\n</ol>\n<h2 id=\"B-树-1\"><a href=\"#B-树-1\" class=\"headerlink\" title=\"B*树\"></a>B*树</h2><p>B*树是B+树的变体，在B+树的非根和非叶子结点再增加指向兄弟的指针。</p>\n<p><a href=\"https://imgtu.com/i/R7fgfS\"><img src=\"https://z3.ax1x.com/2021/07/07/R7fgfS.png\" alt=\"R7fgfS.png\"></a></p>\n<p><strong>B*树的说明:</strong></p>\n<ol>\n<li><p>B* 树定义了非叶子结点关键字个数至少为(2/3) * M，即<strong>块的最低使用率为2/3</strong>，而<strong>B+树的块的最低使用率为1/2</strong>。   M:树的度</p>\n</li>\n<li><p>从第1个特点我们可以看出，B*树分配新结点的概率比B+树要低，空间使用率更高</p>\n</li>\n</ol>\n",
            "tags": [
                "算法与数据结构",
                "多叉树",
                "B树",
                "B+树",
                "B×树"
            ]
        }
    ]
}