{
    "version": "https://jsonfeed.org/version/1",
    "title": "品一份静谧人生 • All posts by \"弗洛伊德算法\" tag",
    "description": "",
    "home_page_url": "https://alphonse-Kino.github.io",
    "items": [
        {
            "id": "https://alphonse-kino.github.io/2021/07/08/14.%E7%A8%8B%E5%BA%8F%E5%91%98%E5%B8%B8%E7%94%A810%E7%A7%8D%E7%AE%97%E6%B3%95/",
            "url": "https://alphonse-kino.github.io/2021/07/08/14.%E7%A8%8B%E5%BA%8F%E5%91%98%E5%B8%B8%E7%94%A810%E7%A7%8D%E7%AE%97%E6%B3%95/",
            "title": "常用10种算法",
            "date_published": "2021-07-08T14:03:46.235Z",
            "content_html": "<h1 id=\"1-二分查找算法非递归\"><a class=\"markdownIt-Anchor\" href=\"#1-二分查找算法非递归\">#</a> 1、二分查找算法 (非递归)</h1>\n<h2 id=\"简单介绍\"><a class=\"markdownIt-Anchor\" href=\"#简单介绍\">#</a> 简单介绍</h2>\n<ol>\n<li>\n<p>二分查找法只适用于从有序的数列中进行查找 (比如数字和字母等)，将数列排序后再进行查找</p>\n</li>\n<li>\n<p>二分查找法的运行时间为对数时间 O (㏒₂n) ，即查找到需要的目标位置<strong>最多</strong>只需要㏒₂n 步，假设从 [0,99] 的队列 (100 个数，即 n=100) 中寻到目标数 30，则需要查找步数为㏒₂100 , 即<strong>最多</strong>需要查找 7 次 (2^6 &lt; 100 &lt; 2^7)</p>\n</li>\n</ol>\n<h2 id=\"代码实现\"><a class=\"markdownIt-Anchor\" href=\"#代码实现\">#</a> 代码实现</h2>\n<ul>\n<li>数组 {1,3, 8, 10, 11, 67, 100}, 编程实现二分查找， 要求使用非递归的方式完成.</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> demo01;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//二分查找算法的非递归实现</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BinarySearchNoRecur</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//测试</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] arr=&#123;<span class=\"number\">1</span>,<span class=\"number\">3</span>,<span class=\"number\">48</span>,<span class=\"number\">10</span>,<span class=\"number\">11</span>,<span class=\"number\">67</span>,<span class=\"number\">100</span>&#125;;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> index=binarySearch(arr,<span class=\"number\">1</span>);</span><br><span class=\"line\">        System.out.println(index);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 二分查找算法的非递归实现</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> arr</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> target</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">binarySearch</span><span class=\"params\">(<span class=\"keyword\">int</span>[] arr, <span class=\"keyword\">int</span> target)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> left = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> right = arr.length - <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (left &lt;= right) &#123; <span class=\"comment\">//满足该条件，可以继续查找</span></span><br><span class=\"line\">            <span class=\"keyword\">int</span> mid = (left + right) / <span class=\"number\">2</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (arr[mid] == target) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> mid;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (arr[mid] &gt; target) &#123;</span><br><span class=\"line\">                right = mid - <span class=\"number\">1</span>;<span class=\"comment\">//需要向左查找</span></span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                left = mid + <span class=\"number\">1</span>;<span class=\"comment\">//需要向右查找</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"2-分治算法\"><a class=\"markdownIt-Anchor\" href=\"#2-分治算法\">#</a> 2、分治算法</h1>\n<h2 id=\"简单介绍-2\"><a class=\"markdownIt-Anchor\" href=\"#简单介绍-2\">#</a> 简单介绍</h2>\n<p>1) 分治法是一种很重要的算法。字面上的解释是 “分而治之”，就是把一个复杂的问题分成两个或更多的相同或相似的子问题，再把子问题分成更小的子问题…… 直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并。这个技巧是很多高效算法的基础，如排序算法 (<a href=\"\">快速排序</a>，<a href=\"\">归并排序</a>)，傅立叶变换 (快速傅立叶变换)……</p>\n<p>​\t二分搜索\t\t\t大整数乘法\t\t\t棋盘覆盖\t\t\t<a href=\"\">合并排序</a>\t\t<a href=\"\">快速排序</a></p>\n<p>​\t线性时间选择\t最接近点对问题\t循环赛日程表\t<strong>汉诺塔</strong></p>\n<h3 id=\"基本步骤\"><a class=\"markdownIt-Anchor\" href=\"#基本步骤\">#</a> 基本步骤</h3>\n<p>1) 分解：将原问题分解为若干个规模较小，相互独立，与原问题形式相同的子问题</p>\n<p>2) 解决：若子问题规模较小而容易被解决则直接解，否则递归地解各个子问题</p>\n<p>3) 合并：将各个子问题的解合并为原问题的解。</p>\n<p><strong>分治 (Divide-and-Conquer§) 算法设计模式如下</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> |P|≤<span class=\"function\">n0</span></span><br><span class=\"line\"><span class=\"function\">   then <span class=\"title\">return</span><span class=\"params\">(ADHOC(P)</span>)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">//将P分解为较小的子问题 P1 ,P2 ,…,Pk</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">for</span> i←1 to k</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">do</span> yi ← Divide-and-<span class=\"title\">Conquer</span><span class=\"params\">(Pi)</span>   递归解决Pi</span></span><br><span class=\"line\"><span class=\"function\">T ← <span class=\"title\">MERGE</span><span class=\"params\">(y1,y2,…,yk)</span>   合并子问题</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">return</span><span class=\"params\">(T)</span></span></span><br></pre></td></tr></table></figure>\n<p>其中 | P | 表示问题 P 的规模；n0 为一阈值，表示当问题 P 的规模不超过 n0 时，问题已容易直接解出，不必再继续分解。ADHOC§ 是该分治法中的基本子算法，用于直接解小规模的问题 P。因此，当 P 的规模不超过 n0 时直接用算法 ADHOC§ 求解。算法 MERGE (y1,y2,…,yk) 是该分治法中的合并子算法，用于将 P 的子问题 P1 ,P2 ,…,Pk 的相应的解 y1,y2,…,yk 合并为 P 的解。</p>\n<h2 id=\"代码实现-2\"><a class=\"markdownIt-Anchor\" href=\"#代码实现-2\">#</a> 代码实现</h2>\n<p>Ø 汉诺塔的传说</p>\n<p>汉诺塔：汉诺塔（又称河内塔）问题是源于印度一个古老传说的益智玩具。大梵天创造世界的时候做了三根<a href=\"https://baike.baidu.com/item/%E9%87%91%E5%88%9A%E7%9F%B3/80698\">金刚石</a>柱子，在一根柱子上从下往上按照大小顺序摞着 64 片黄金圆盘。大梵天命令婆罗门把圆盘从下面开始按大小顺序重新摆放在另一根柱子上。并且规定，在小圆盘上不能放大圆盘，在三根柱子之间一次只能移动一个圆盘。</p>\n<p>假如每秒钟一次，共需多长时间呢？移完这些金片需要 5845.54 亿年以上，太阳系的预期寿命据说也就是数百亿年。真的过了 5845.54 亿年，地球上的一切生命，连同梵塔、庙宇等，都早已经灰飞烟灭。</p>\n<p><strong>思路分析：</strong></p>\n<ol>\n<li>\n<p>如果是有一个盘， A-&gt;C</p>\n<p>​\t如果我们有 n &gt;= 2 情况，我们总是可以看做是两个盘 1. 最下边的盘 2. 上面的盘</p>\n</li>\n<li>\n<p>先把 最上面的盘 A-&gt;B</p>\n</li>\n<li>\n<p>把最下边的盘 A-&gt;C</p>\n</li>\n<li>\n<p>把 B 塔的所有盘 从 B-&gt;C</p>\n</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> demo02;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//分治算法解决汉诺塔问题</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Hanoitower</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        hanoiTower(<span class=\"number\">5</span>,<span class=\"string\">&#x27;A&#x27;</span>,<span class=\"string\">&#x27;B&#x27;</span>,<span class=\"string\">&#x27;C&#x27;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//汉诺塔的移动方法</span></span><br><span class=\"line\">    <span class=\"comment\">//使用分治算法</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">hanoiTower</span><span class=\"params\">(<span class=\"keyword\">int</span> num, <span class=\"keyword\">char</span> a, <span class=\"keyword\">char</span> b, <span class=\"keyword\">char</span> c)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//如果只有一个盘</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (num == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;第1个盘从 &quot;</span> + a + <span class=\"string\">&quot;-&gt;&quot;</span> + c);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">//如果我们有n&gt;=2 情况，我们总是可以看做成两个盘 1.最下边一个盘 2.上面的所有盘</span></span><br><span class=\"line\">            <span class=\"comment\">//1.先把最上面的所有盘A-&gt;B,移动过程会使用到c</span></span><br><span class=\"line\">            hanoiTower(num - <span class=\"number\">1</span>, a, c, b);</span><br><span class=\"line\">            <span class=\"comment\">//2.把最下边的盘A-&gt;C</span></span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;第&quot;</span> + num + <span class=\"string\">&quot;个盘从 &quot;</span> + a + <span class=\"string\">&quot;-&gt;&quot;</span> + c);</span><br><span class=\"line\">            <span class=\"comment\">//3.把B塔的所有盘从B-&gt;C，移动过程使用到a 塔</span></span><br><span class=\"line\">            hanoiTower(num - <span class=\"number\">1</span>, b, a, c);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"3-动态规划算法\"><a class=\"markdownIt-Anchor\" href=\"#3-动态规划算法\">#</a> 3、动态规划算法</h1>\n<h2 id=\"简单介绍-3\"><a class=\"markdownIt-Anchor\" href=\"#简单介绍-3\">#</a> 简单介绍</h2>\n<ol>\n<li>\n<p>动态规划 (<strong>Dynamic Programming</strong>) 算法的核心思想是：将大问题划分为小问题进行解决，从而一步步获取最优解的处理算法</p>\n</li>\n<li>\n<p>动态规划算法与分治算法类似，其基本思想也是将待求解问题分解成若干个子问题，先求解子问题，然后从这些子问题的解得到原问题的解。</p>\n</li>\n<li>\n<p>与分治法不同的是，<strong>适合于用动态规划求解的问题，经分解得到子问题往往不是互相独立的。</strong> (即下一个子阶段的求解是建立在上一个子阶段的解的基础上，进行进一步的求解)</p>\n</li>\n<li>\n<p>动态规划可以通过<strong>填表的方式</strong>来逐步推进，得到最优解.</p>\n</li>\n</ol>\n<h2 id=\"应用场景\"><a class=\"markdownIt-Anchor\" href=\"#应用场景\">#</a> 应用场景</h2>\n<p><a href=\"https://imgtu.com/i/R7h11g\"><img src=\"https://z3.ax1x.com/2021/07/07/R7h11g.png\" alt=\"R7h11g.png\"></a></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1. 要求达到的目标为装入的背包的总价值最大，并且重量不超出</span><br><span class=\"line\">2. 要求装入的物品不能重复</span><br><span class=\"line\">3. 思路分析和图解</span><br><span class=\"line\">   背包问题主要是指一个给定容量的背包、若干具有一定价值和重量的物品，如何选择物品放入背包使物品的价值最大。其中又分01背包和完全背包(完全背包指的是：每种物品都有无限件可用)</span><br><span class=\"line\">   这里的问题属于01背包，即每个物品最多放一个。而无限背包可以转化为01背包</span><br><span class=\"line\">4. 算法的主要思想，利用动态规划来解决。每次遍历到的第i个物品，根据w[i]和v[i]来确定是否需要将该物品放入背包中。即对于给定的n个物品，设v[i]、w[i]分别为第i个物品的价值和重量，C为背包的容量。再令v[i][j]表示在前i个物品中能够装入容量为j的背包中的最大价值。则我们有下面的结果：</span><br><span class=\"line\">   1.  v[i][0]=v[0][j]=0; //表示 填入表 第一行和第一列是0</span><br><span class=\"line\">   2. 当w[i]&gt; j 时：v[i][j]=v[i-1][j]   // 当准备加入新增的商品的容量大于 当前背包的容量时，就直接使用上一个单元格的装入策略</span><br><span class=\"line\">   3. 当j&gt;=w[i]时： v[i][j]=max&#123;v[i-1][j], v[i]+v[i-1][j-w[i]]&#125;  </span><br><span class=\"line\"></span><br><span class=\"line\">      - 当准备加入的新增的商品的容量小于等于当前背包的容量,</span><br><span class=\"line\">      - 装入的方式:</span><br><span class=\"line\">      \t- v[i-1][j]： 就是上一个单元格的装入的最大值</span><br><span class=\"line\">      \t- v[i] : 表示当前商品的价值 </span><br><span class=\"line\">     \t- v[i-1][j-w[i]] ： 装入i-1商品，到剩余空间j-w[i]的最大值</span><br><span class=\"line\">      \t- 当j&gt;=w[i]时： vi=max&#123;vi-1, v[i]+vi-1]&#125; :</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p><a href=\"https://imgtu.com/i/R7haNV\"><img src=\"https://z3.ax1x.com/2021/07/07/R7haNV.png\" alt=\"R7haNV.png\"></a></p>\n<h2 id=\"代码展示\"><a class=\"markdownIt-Anchor\" href=\"#代码展示\">#</a> 代码展示</h2>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> demo03;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//动态规划算法   背包问题</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">KnapsackProblem</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] w = &#123;<span class=\"number\">1</span>, <span class=\"number\">4</span>, <span class=\"number\">3</span>&#125;;<span class=\"comment\">//物品的重量</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] val = &#123;<span class=\"number\">1500</span>, <span class=\"number\">3000</span>, <span class=\"number\">2000</span>&#125;;<span class=\"comment\">//物品的价值 这里的val[i],就是v[i]</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> m = <span class=\"number\">4</span>;<span class=\"comment\">//背包的容量</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> n = val.length;<span class=\"comment\">//物品的个数</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//创建二维数组</span></span><br><span class=\"line\">        <span class=\"comment\">//v[i][j],表示在前i个物品中能够转入容量为j的背包中的最大价值</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span>[][] v = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[n + <span class=\"number\">1</span>][m + <span class=\"number\">1</span>];</span><br><span class=\"line\">        <span class=\"comment\">//为了记录放入商品的情况，我们定义一个二维数组</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span>[][] path = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[n + <span class=\"number\">1</span>][m + <span class=\"number\">1</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//初始化第一行和第一列，这里在本程序中可以不去处理，因为默认就是0</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; v.length; i++) &#123;</span><br><span class=\"line\">            v[i][<span class=\"number\">0</span>] = <span class=\"number\">0</span>;<span class=\"comment\">//将第一列设置为0</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; v[<span class=\"number\">0</span>].length; i++) &#123;</span><br><span class=\"line\">            v[<span class=\"number\">0</span>][i] = <span class=\"number\">0</span>;<span class=\"comment\">//将第一行设置为0</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//根据前面的公式，动态规划处理</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; v.length; i++) &#123; <span class=\"comment\">//不处理第一行 i是从1开始的</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">1</span>; j &lt; v[<span class=\"number\">0</span>].length; j++) &#123; <span class=\"comment\">//不处理第一列 j是从1开始的</span></span><br><span class=\"line\">                <span class=\"comment\">//公式</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (w[i - <span class=\"number\">1</span>] &gt; j) &#123; <span class=\"comment\">//因为我们程序i 是从1开始的，因此我们原来公式中 w[i] 要修改为 w[i-1]</span></span><br><span class=\"line\">                    v[i][j] = v[i - <span class=\"number\">1</span>][j];</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 因为i 是从1开始的</span></span><br><span class=\"line\">                    <span class=\"comment\">//v[i][j]=Math.max(v[i-1][j],val[i-1]+v[i-1][j-w[i-1]]);</span></span><br><span class=\"line\">                    <span class=\"comment\">//为了记录商品存放到背包的情况，不能直接使用上面的公式，要使用if-else来体现公式</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (v[i - <span class=\"number\">1</span>][j] &lt; val[i - <span class=\"number\">1</span>] + v[i - <span class=\"number\">1</span>][j - w[i - <span class=\"number\">1</span>]]) &#123;</span><br><span class=\"line\">                        v[i][j] = val[i - <span class=\"number\">1</span>] + v[i - <span class=\"number\">1</span>][j - w[i - <span class=\"number\">1</span>]];</span><br><span class=\"line\">                        <span class=\"comment\">//把当前的情况记录到path中</span></span><br><span class=\"line\">                        path[i][j] = <span class=\"number\">1</span>;</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                        v[i][j] = v[i - <span class=\"number\">1</span>][j];</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//输出一下 v,看看目前的情况</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; v.length; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; v[<span class=\"number\">0</span>].length; j++) &#123;</span><br><span class=\"line\">                System.out.print(v[i][j] + <span class=\"string\">&quot; &quot;</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            System.out.println();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//输出最后我们是放入了那些商品</span></span><br><span class=\"line\">        <span class=\"comment\">//遍历 path 这样输出会把所有的情况都得到，其实我们只需要最后放入的</span></span><br><span class=\"line\"><span class=\"comment\">//        for (int i = 0; i &lt; path.length; i++) &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//            for (int j = 0; j &lt; path[i].length; j++) &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//                if (path[i][j]==1) &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//                    System.out.printf(&quot;第%d个商品放入到背包\\n&quot;, i);</span></span><br><span class=\"line\"><span class=\"comment\">//                &#125;</span></span><br><span class=\"line\"><span class=\"comment\">//            &#125;</span></span><br><span class=\"line\"><span class=\"comment\">//        &#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">int</span> i = path.length - <span class=\"number\">1</span>;<span class=\"comment\">//行的最大下标</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> j = path[<span class=\"number\">0</span>].length - <span class=\"number\">1</span>; <span class=\"comment\">//列的最大下标</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (i &gt; <span class=\"number\">0</span> &amp;&amp; j &gt; <span class=\"number\">0</span>) &#123; <span class=\"comment\">//从path的最后开始找</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (path[i][j] == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                System.out.printf(<span class=\"string\">&quot;第%d个商品放入到背包\\n&quot;</span>, i);</span><br><span class=\"line\">                j -= w[i - <span class=\"number\">1</span>];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            i--;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h1 id=\"4-kmp算法\"><a class=\"markdownIt-Anchor\" href=\"#4-kmp算法\">#</a> 4、KMP 算法</h1>\n<h2 id=\"问题展示\"><a class=\"markdownIt-Anchor\" href=\"#问题展示\">#</a> 问题展示</h2>\n<p>字符串匹配问题：：</p>\n<ol>\n<li>\n<p>有一个字符串 str1= ““硅硅谷 尚硅谷你尚硅 尚硅谷你尚硅谷你尚硅你好””，和一个子串 str2=“尚硅谷你尚硅你”</p>\n</li>\n<li>\n<p><strong>现在要判断</strong> <strong>str1</strong> <strong>是否含有</strong> <strong>str2</strong>, 如果存在，就返回第一次出现的位置，如果没有，则返回 - 1</p>\n</li>\n</ol>\n<h2 id=\"暴力匹配算法\"><a class=\"markdownIt-Anchor\" href=\"#暴力匹配算法\">#</a> 暴力匹配算法</h2>\n<h3 id=\"思路分析\"><a class=\"markdownIt-Anchor\" href=\"#思路分析\">#</a> 思路分析</h3>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">如果用暴力匹配的思路，并假设现在str1匹配到 i 位置，子串str2匹配到 j 位置，则有:</span><br><span class=\"line\"></span><br><span class=\"line\">\t1. 如果当前字符匹配成功（即str1[i] == str2[j]），则i++，j++，继续匹配下一个字符</span><br><span class=\"line\">\t2. 如果失配（即str1[i]! = str2[j]），令i = i - (j - 1)，j = 0。相当于每次匹配失败时，i 回溯，j 被置为0。</span><br><span class=\"line\">\t3. 用暴力方法解决的话就会有大量的回溯，每次只移动一位，若是不匹配，移动到下一位接着判断，浪费了大量的时间。(不可行!)</span><br></pre></td></tr></table></figure>\n<h3 id=\"代码实现-3\"><a class=\"markdownIt-Anchor\" href=\"#代码实现-3\">#</a> 代码实现</h3>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> demo04;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ViolenceMatch</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//测试暴力匹配算法</span></span><br><span class=\"line\">        String s1=<span class=\"string\">&quot;aaa d d da adad acar&quot;</span>;</span><br><span class=\"line\">        String s2=<span class=\"string\">&quot;d da&quot;</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> index = violenceMatch(s1, s2);</span><br><span class=\"line\">        System.out.println(index);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//暴力匹配算法实现</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">violenceMatch</span><span class=\"params\">(String str1, String str2)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">char</span>[] s1 = str1.toCharArray();</span><br><span class=\"line\">        <span class=\"keyword\">char</span>[] s2 = str2.toCharArray();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">int</span> s1Length = s1.length;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> s2Length = s2.length;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; <span class=\"comment\">//i索引指向s1</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; <span class=\"comment\">//j索引指向s2</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (i &lt; s1Length &amp;&amp; j &lt; s2Length) &#123;<span class=\"comment\">//保证匹配时，不越界</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (s1[i]==s2[j])&#123; <span class=\"comment\">//匹配成功</span></span><br><span class=\"line\">                i++;</span><br><span class=\"line\">                j++;</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">//匹配失败 (即 str1[i] != str2[j]),令 i=i-(j-1),j=0</span></span><br><span class=\"line\">                i=i-(j-<span class=\"number\">1</span>);</span><br><span class=\"line\">                j=<span class=\"number\">0</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//判断是否匹配成功</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (j==s2Length)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> i-j;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"kmp算法\"><a class=\"markdownIt-Anchor\" href=\"#kmp算法\">#</a> KMP 算法</h2>\n<ul>\n<li>\n<p>KMP 是一个解决模式串在文本串是否出现过，如果出现过，最早出现的位置的经典算法</p>\n</li>\n<li>\n<p>Knuth-Morris-Pratt <strong>字符串查找算法</strong>，简称为 “KMP 算法”，常用于在一个文本串 S 内查找一个模式串 P 的出现位置，这个算法由 Donald Knuth、Vaughan Pratt、James H. Morris 三人于 1977 年联合发表，故取这 3 人的姓氏命名此算法.</p>\n</li>\n<li>\n<p>KMP 方法算法就利用之前判断过信息，通过一个 next 数组，保存模式串中前后最长公共子序列的长度，每次回溯时，通过 next 数组找到，前面匹配过的位置，省去了大量的计算时间</p>\n</li>\n</ul>\n<p><strong>(详细了解 KMP 算法的运行【】涉及底层) 参考资料：<a href=\"https://www.cnblogs.com/ZuoAndFutureGirl/p/9028287.html\">https://www.cnblogs.com/ZuoAndFutureGirl/p/9028287.html</a></strong></p>\n<h3 id=\"kmp运行过程\"><a class=\"markdownIt-Anchor\" href=\"#kmp运行过程\">#</a> KMP 运行过程</h3>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">举例来说，有一个字符串 Str1 = “BBC ABCDAB ABCDABCDABDE”，判断，里面是否包含另一个字符串 Str2 = “ABCDABD”？ </span><br><span class=\"line\">1.首先，用Str1的第一个字符和Str2的第一个字符去比较，不符合，关键词向后移动一位 </span><br></pre></td></tr></table></figure>\n<p><a href=\"https://imgtu.com/i/R7hB3F\"><img src=\"https://z3.ax1x.com/2021/07/07/R7hB3F.jpg\" alt=\"R7hB3F.jpg\"></a></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2.重复第一步，还是不符合，再后移</span><br></pre></td></tr></table></figure>\n<p><a href=\"https://imgtu.com/i/R7hrjJ\"><img src=\"https://z3.ax1x.com/2021/07/07/R7hrjJ.jpg\" alt=\"R7hrjJ.jpg\"></a></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">3.一直重复，直到Str1有一个字符与Str2的第一个字符符合为止</span><br></pre></td></tr></table></figure>\n<p><a href=\"https://imgtu.com/i/R7hyu9\"><img src=\"https://z3.ax1x.com/2021/07/07/R7hyu9.jpg\" alt=\"R7hyu9.jpg\"></a></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">4.接着比较字符串和搜索词的下一个字符，还是符合。</span><br></pre></td></tr></table></figure>\n<p><a href=\"https://imgtu.com/i/R7h6BR\"><img src=\"https://z3.ax1x.com/2021/07/07/R7h6BR.jpg\" alt=\"R7h6BR.jpg\"></a></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">5.遇到Str1有一个字符与Str2对应的字符不符合。 </span><br></pre></td></tr></table></figure>\n<p><a href=\"https://imgtu.com/i/R7hcH1\"><img src=\"https://z3.ax1x.com/2021/07/07/R7hcH1.jpg\" alt=\"R7hcH1.jpg\"></a></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">6.这时候，想到的是继续遍历Str1的下一个字符，重复第1步。(其实是很不明智的，因为此时BCD已经比较过了，没有必要再做重复的工作，一个基本事实是，当空格与D不匹配时，你其实知道前面六个字符是”ABCDAB”。KMP 算法的想法是，设法利用这个已知信息，不要把”搜索位置”移回已经比较过的位置，继续把它向后移，这样就提高了效率。) </span><br></pre></td></tr></table></figure>\n<p><a href=\"https://imgtu.com/i/R7hh9O\"><img src=\"https://z3.ax1x.com/2021/07/07/R7hh9O.jpg\" alt=\"R7hh9O.jpg\"></a></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">7.怎么做到把刚刚重复的步骤省略掉？可以对Str2计算出一张《部分匹配表》，这张表的产生在后面介绍 </span><br></pre></td></tr></table></figure>\n<p><a href=\"https://imgtu.com/i/RHSr0x\"><img src=\"https://z3.ax1x.com/2021/07/07/RHSr0x.jpg\" alt=\"RHSr0x.jpg\"></a></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">8.已知空格与D不匹配时，前面六个字符”ABCDAB”是匹配的。查表可知，最后一个匹配字符B对应的”部分匹配值”为2，因此按照下面的公式算出向后移动的位数： </span><br><span class=\"line\"></span><br><span class=\"line\">\t移动位数 = 已匹配的字符数 - 对应的部分匹配值 </span><br><span class=\"line\"></span><br><span class=\"line\">\t因为 6 - 2 等于4，所以将搜索词向后移动 4 位。 </span><br><span class=\"line\"></span><br><span class=\"line\">9.因为空格与Ｃ不匹配，搜索词还要继续往后移。这时，已匹配的字符数为2（”AB”），对应的”部分匹配值”为0。所以，移动位数 = 2 - 0，结果为 2，于是将搜索词向后移 2 位。</span><br></pre></td></tr></table></figure>\n<p><a href=\"https://imgtu.com/i/RHSW1H\"><img src=\"https://z3.ax1x.com/2021/07/07/RHSW1H.jpg\" alt=\"RHSW1H.jpg\"></a></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">10.因为空格与A不匹配，继续后移一位。</span><br></pre></td></tr></table></figure>\n<p><a href=\"https://imgtu.com/i/RHSfcd\"><img src=\"https://z3.ax1x.com/2021/07/07/RHSfcd.jpg\" alt=\"RHSfcd.jpg\"></a></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">11.逐位比较，直到发现C与D不匹配。于是，移动位数 = 6 - 2，继续将搜索词向后移动 4 位。</span><br></pre></td></tr></table></figure>\n<p><a href=\"https://imgtu.com/i/RHSzBq\"><img src=\"https://z3.ax1x.com/2021/07/07/RHSzBq.jpg\" alt=\"RHSzBq.jpg\"></a></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">12.逐位比较，直到搜索词的最后一位，发现完全匹配，于是搜索完成。如果还要继续搜索（即找出全部匹配），移动位数 = 7 - 0，再将搜索词向后移动 7 位，这里就不再重复了。 </span><br></pre></td></tr></table></figure>\n<p><a href=\"https://imgtu.com/i/RHpAgJ\"><img src=\"https://z3.ax1x.com/2021/07/07/RHpAgJ.jpg\" alt=\"RHpAgJ.jpg\"></a></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">13.介绍《部分匹配表》怎么产生的 </span><br><span class=\"line\"></span><br><span class=\"line\">\t先介绍前缀，后缀是什么 </span><br></pre></td></tr></table></figure>\n<p><a href=\"https://imgtu.com/i/RHpeD1\"><img src=\"https://z3.ax1x.com/2021/07/07/RHpeD1.jpg\" alt=\"RHpeD1.jpg\"></a></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">“部分匹配值”就是”前缀”和”后缀”的最长的共有元素的长度。以”ABCDABD”为例， </span><br><span class=\"line\"></span><br><span class=\"line\">\t－”A”的前缀和后缀都为空集，共有元素的长度为0； </span><br><span class=\"line\">\t－”AB”的前缀为[A]，后缀为[B]，共有元素的长度为0； </span><br><span class=\"line\">\t－”ABC”的前缀为[A, AB]，后缀为[BC, C]，共有元素的长度0； </span><br><span class=\"line\">\t－”ABCD”的前缀为[A, AB, ABC]，后缀为[BCD, CD, D]，共有元素的长度为0； </span><br><span class=\"line\">\t－”ABCDA”的前缀为[A, AB, ABC, ABCD]，后缀为[BCDA, CDA, DA, A]，共有元素为”A”，长度为1； </span><br><span class=\"line\">\t－”ABCDAB”的前缀为[A, AB, ABC, ABCD, ABCDA]，后缀为[BCDAB, CDAB, DAB, AB, B]，共有元素为”AB”，长度为2； </span><br><span class=\"line\">\t－”ABCDABD”的前缀为[A, AB, ABC, ABCD, ABCDA, ABCDAB]，后缀为[BCDABD, CDABD, DABD, ABD, BD, D]，共有元素的长度为0。</span><br><span class=\"line\">    </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">14.”部分匹配”的实质是，有时候，字符串头部和尾部会有重复。比如，”ABCDAB”之中有两个”AB”，那么它的”部分匹配值”就是2（”AB”的长度）。搜索词移动的时候，第一个”AB”向后移动 4 位（字符串长度-部分匹配值），就可以来到第二个”AB”的位置。 </span><br><span class=\"line\"></span><br><span class=\"line\">\t~~完毕~~</span><br></pre></td></tr></table></figure>\n<p><a href=\"https://imgtu.com/i/RHpKUK\"><img src=\"https://z3.ax1x.com/2021/07/07/RHpKUK.jpg\" alt=\"RHpKUK.jpg\"></a></p>\n<h3 id=\"代码展示-2\"><a class=\"markdownIt-Anchor\" href=\"#代码展示-2\">#</a> 代码展示</h3>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> demo05;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Arrays;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">KMPAlgonithm</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        String str1=<span class=\"string\">&quot;BBC ABCDAB ABCDABCDABDE&quot;</span>;</span><br><span class=\"line\">        String str2=<span class=\"string\">&quot;ABCDABD&quot;</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] next=kmpNext(str2);</span><br><span class=\"line\">        System.out.println(Arrays.toString(next));</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">int</span> index=kmpSearch(str1,str2,next);</span><br><span class=\"line\">        System.out.println(index);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     *  写出kmp搜索算法</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> str1  源字符串</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> str2  子串</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> next  部分匹配表，是子串对应的部分匹配表</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> 如果是 -1就是没有匹配到，否则返回第一个匹配位置</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">kmpSearch</span><span class=\"params\">(String str1,String str2,<span class=\"keyword\">int</span>[] next)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//遍历</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>,j=<span class=\"number\">0</span>; i &lt; str1.length(); i++) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">//需要考虑str1.charAt(i)！=str2.charAt(j)，去调整 j的大小</span></span><br><span class=\"line\">            <span class=\"comment\">//kmp算法核心点 要了解如何运行，得看底层</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span> (j&gt;<span class=\"number\">0</span> &amp;&amp; str1.charAt(i) != str2.charAt(j))&#123;</span><br><span class=\"line\">                j=next[j-<span class=\"number\">1</span>];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (str1.charAt(i)==str2.charAt(j))&#123;</span><br><span class=\"line\">                j++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (j==str2.length())&#123; <span class=\"comment\">//找到了</span></span><br><span class=\"line\">                <span class=\"keyword\">return</span> i-j+<span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//获取到一个字符串(子串) 的部分匹配值</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span>  <span class=\"keyword\">int</span>[] kmpNext(String dest)&#123;</span><br><span class=\"line\">        <span class=\"comment\">//创建一个next 数组保存部分匹配值</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] next=<span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[dest.length()];</span><br><span class=\"line\">        next[<span class=\"number\">0</span>]=<span class=\"number\">0</span>;<span class=\"comment\">//如果字符串是长度为1，部分匹配值就是 0</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>,j=<span class=\"number\">0</span>; i &lt; dest.length(); i++) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//当 dest.charAt(i)!=dest.charAt(j),我们需要从next[j-1]获取新的j</span></span><br><span class=\"line\">            <span class=\"comment\">//直到我们发现 有 dest.charAt(i) == dest.charAt(j)成立才退出</span></span><br><span class=\"line\">            <span class=\"comment\">//这是kmp算法的核心点  要了解如何运行，得看底层</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span> (j&gt;<span class=\"number\">0</span> &amp;&amp; dest.charAt(i) != dest.charAt(j))&#123;</span><br><span class=\"line\">                j=next[j-<span class=\"number\">1</span>];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">//当 dest.charAt(i)==dest.charAt(j) 满足时，部分匹配值就是 +1</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (dest.charAt(i)==dest.charAt(j))&#123;</span><br><span class=\"line\">                j++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            next[i]=j;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"5-贪心算法\"><a class=\"markdownIt-Anchor\" href=\"#5-贪心算法\">#</a> 5、贪心算法</h1>\n<h2 id=\"简单介绍-4\"><a class=\"markdownIt-Anchor\" href=\"#简单介绍-4\">#</a> 简单介绍</h2>\n<ol>\n<li>\n<p>贪婪算法 (贪心算法) 是指在对问题进行求解时，在每一步选择中都采取最好或者最优 (即最有利) 的选择，从而希望能够导致结果是最好或者最优的算法</p>\n</li>\n<li>\n<p>贪婪算法所得到的结果<strong>不一定是最优的结果 (有时候会是最优解)</strong>，但是都是相对近似 (接近) 最优解的结果</p>\n</li>\n</ol>\n<h2 id=\"应用场景-2\"><a class=\"markdownIt-Anchor\" href=\"#应用场景-2\">#</a> 应用场景</h2>\n<p>1) 假设存在如下表的需要付费的广播台，以及广播台信号可以覆盖的地区。 <strong>如何选择最少的广播台</strong>，让所有的地区都可以接收到信号</p>\n<table>\n<thead>\n<tr>\n<th>广播台</th>\n<th>覆盖地区</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>K1</td>\n<td>“北京”, “上海”, “天津”</td>\n</tr>\n<tr>\n<td>K2</td>\n<td>“广州”, “北京”, “深圳”</td>\n</tr>\n<tr>\n<td>K3</td>\n<td>“成都”, “上海”, “杭州”</td>\n</tr>\n<tr>\n<td>K4</td>\n<td>“上海”, “天津”</td>\n</tr>\n<tr>\n<td>K5</td>\n<td>“杭州”, “大连”</td>\n</tr>\n</tbody>\n</table>\n<ol start=\"2\">\n<li>\n<p>思路分析</p>\n<ul>\n<li>穷举法</li>\n<li>使用穷举法实现，列出每个可能的广播台的集合，这被称为幂集。假设总的有 n 个广播台，则广播台的组合总共有 2ⁿ -1 个，假设每秒可以计算 10 个子集， 如图:</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>广播台数量 n</th>\n<th>子集总数 2ⁿ</th>\n<th>需要的时间</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>5</td>\n<td>32</td>\n<td>3.2 秒</td>\n</tr>\n<tr>\n<td>10</td>\n<td>1024</td>\n<td>102.4 秒</td>\n</tr>\n<tr>\n<td>32</td>\n<td>4294967296</td>\n<td>13.6 年</td>\n</tr>\n<tr>\n<td>100</td>\n<td>1.26*100³º</td>\n<td>4x10²³ 年</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li>\n<p>Ø 贪婪算法，效率高:</p>\n</li>\n<li>\n<p>目前并没有算法可以快速计算得到准备的值， 使用贪婪算法，则可以得到非常接近的解，并且效率高。选择策略上，因为需要覆盖全部地区的最小集合:</p>\n<ol>\n<li>\n<p>遍历所有的广播电台，找到一个覆盖了最多<strong>未覆盖的地区</strong>的电台 (此电台可能包含一些已覆盖的地区，但没有关系）</p>\n</li>\n<li>\n<p>将这个电台加入到一个集合中 (比如 ArrayList), 想办法把该电台覆盖的地区在下次比较时去掉。</p>\n</li>\n<li>\n<p>重复第 1 步直到覆盖了全部的地区</p>\n</li>\n</ol>\n</li>\n</ul>\n</li>\n</ol>\n<p><strong>注意事项：</strong></p>\n<ul>\n<li><strong>贪婪算法所得到的结果不一定是最优的结果 (有时候会是最优解)，但是都是相对近似 (接近) 最优解的结果</strong></li>\n<li>* 比如上题的 ** 算法选出的是 K1, K2, K3, K5，符合覆盖了全部的地区</li>\n<li>但是我们发现 K2, K3,K4,K5 也可以覆盖全部地区，如果 K2 的使用成本低于 K1, 那么我们上题的 K1, K2, K3, K5 虽然是满足条件，但是并不是最优的.</li>\n</ul>\n<h2 id=\"代码展示-3\"><a class=\"markdownIt-Anchor\" href=\"#代码展示-3\">#</a> 代码展示</h2>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> demo06;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.ArrayList;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.HashMap;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.HashSet;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Map;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">GreedyAlgorithm</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//创建广播电台，放入到Map中</span></span><br><span class=\"line\">        Map&lt;String, HashSet&lt;String&gt;&gt; broadcasts = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">        <span class=\"comment\">//将各个广播电台放入到broadcasts</span></span><br><span class=\"line\">        HashSet&lt;String&gt; hashSet1=<span class=\"keyword\">new</span> HashSet&lt;&gt;();</span><br><span class=\"line\">        hashSet1.add(<span class=\"string\">&quot;北京&quot;</span>);</span><br><span class=\"line\">        hashSet1.add(<span class=\"string\">&quot;上海&quot;</span>);</span><br><span class=\"line\">        hashSet1.add(<span class=\"string\">&quot;天津&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        HashSet&lt;String&gt; hashSet2=<span class=\"keyword\">new</span> HashSet&lt;&gt;();</span><br><span class=\"line\">        hashSet2.add(<span class=\"string\">&quot;广州&quot;</span>);</span><br><span class=\"line\">        hashSet2.add(<span class=\"string\">&quot;北京&quot;</span>);</span><br><span class=\"line\">        hashSet2.add(<span class=\"string\">&quot;深圳&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        HashSet&lt;String&gt; hashSet3=<span class=\"keyword\">new</span> HashSet&lt;&gt;();</span><br><span class=\"line\">        hashSet3.add(<span class=\"string\">&quot;成都&quot;</span>);</span><br><span class=\"line\">        hashSet3.add(<span class=\"string\">&quot;上海&quot;</span>);</span><br><span class=\"line\">        hashSet3.add(<span class=\"string\">&quot;杭州&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        HashSet&lt;String&gt; hashSet4=<span class=\"keyword\">new</span> HashSet&lt;&gt;();</span><br><span class=\"line\">        hashSet4.add(<span class=\"string\">&quot;上海&quot;</span>);</span><br><span class=\"line\">        hashSet4.add(<span class=\"string\">&quot;天津&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        HashSet&lt;String&gt; hashSet5=<span class=\"keyword\">new</span> HashSet&lt;&gt;();</span><br><span class=\"line\">        hashSet5.add(<span class=\"string\">&quot;杭州&quot;</span>);</span><br><span class=\"line\">        hashSet5.add(<span class=\"string\">&quot;大连&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//加入到Map</span></span><br><span class=\"line\">        broadcasts.put(<span class=\"string\">&quot;K1&quot;</span>,hashSet1);</span><br><span class=\"line\">        broadcasts.put(<span class=\"string\">&quot;K2&quot;</span>,hashSet2);</span><br><span class=\"line\">        broadcasts.put(<span class=\"string\">&quot;K3&quot;</span>,hashSet3);</span><br><span class=\"line\">        broadcasts.put(<span class=\"string\">&quot;K4&quot;</span>,hashSet4);</span><br><span class=\"line\">        broadcasts.put(<span class=\"string\">&quot;K5&quot;</span>,hashSet5);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//存放所有地区</span></span><br><span class=\"line\">        HashSet&lt;String&gt; allAreas = <span class=\"keyword\">new</span> HashSet&lt;&gt;();</span><br><span class=\"line\">        allAreas.add(<span class=\"string\">&quot;北京&quot;</span>);</span><br><span class=\"line\">        allAreas.add(<span class=\"string\">&quot;上海&quot;</span>);</span><br><span class=\"line\">        allAreas.add(<span class=\"string\">&quot;天津&quot;</span>);</span><br><span class=\"line\">        allAreas.add(<span class=\"string\">&quot;广州&quot;</span>);</span><br><span class=\"line\">        allAreas.add(<span class=\"string\">&quot;深圳&quot;</span>);</span><br><span class=\"line\">        allAreas.add(<span class=\"string\">&quot;成都&quot;</span>);</span><br><span class=\"line\">        allAreas.add(<span class=\"string\">&quot;杭州&quot;</span>);</span><br><span class=\"line\">        allAreas.add(<span class=\"string\">&quot;大连&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//创建ArrayList，存放选择的电台集合</span></span><br><span class=\"line\">        ArrayList&lt;String&gt; selects=<span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//定义一个临时的集合，在遍历的过程中，存放遍历过程中的电台覆盖的地区和当前还没有覆盖的地区的交集</span></span><br><span class=\"line\">        HashSet&lt;String&gt; tempSet=<span class=\"keyword\">new</span> HashSet&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//定义一个maxKey，保存在一次遍历中，能够覆盖最大未覆盖的的地区对应的电台key</span></span><br><span class=\"line\">        <span class=\"comment\">//如果maxKey 不为 null ，则会加入到selects</span></span><br><span class=\"line\">        String maxKey=<span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (allAreas.size()!=<span class=\"number\">0</span>)&#123; <span class=\"comment\">//如果allAreas不为0，则表示还没有覆盖到所有的地区</span></span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">//每进行一次while，需要将maxKey置空</span></span><br><span class=\"line\">            maxKey=<span class=\"keyword\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">//遍历broadcast，取出对应的key</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (String key:broadcasts.keySet())&#123;</span><br><span class=\"line\">                <span class=\"comment\">//每进行一次for都需要将tempSet中的数据清除</span></span><br><span class=\"line\">                tempSet.clear();</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\">//当前这个key能够覆盖的地区</span></span><br><span class=\"line\">                HashSet&lt;String&gt; areas=broadcasts.get(key);</span><br><span class=\"line\">                tempSet.addAll(areas);</span><br><span class=\"line\">                <span class=\"comment\">//求出tempSet和allAreas 集合的交集，交集会付给tempSet</span></span><br><span class=\"line\">                <span class=\"comment\">//tempSet.retainAll(allAreas); 把tempSet 和allAreas 共有的部分 取出来，赋给tempSet</span></span><br><span class=\"line\">                tempSet.retainAll(allAreas);</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\">//如果当前这个集合包含的未覆盖地区的数量，比maxKey指向的集合地区还多</span></span><br><span class=\"line\">                <span class=\"comment\">//就需要重置maxKey</span></span><br><span class=\"line\">                <span class=\"comment\">//tempSet.size()&gt;broadcasts.get(key).size() 体现出贪心算法的特点，每次都选择最优的</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (tempSet.size()&gt;<span class=\"number\">0</span>&amp;&amp;(maxKey==<span class=\"keyword\">null</span>||tempSet.size()&gt;broadcasts.get(key).size()))&#123;</span><br><span class=\"line\">                    maxKey=key;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">//maxKey != null，就应该将maxKey加入到 selects</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (maxKey!=<span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">                selects.add(maxKey);</span><br><span class=\"line\">                <span class=\"comment\">//将maxKey指向的广播电台覆盖的地区，从allAreas中去掉</span></span><br><span class=\"line\">                allAreas.removeAll(broadcasts.get(maxKey));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;得到的结果是：&quot;</span>+selects);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h1 id=\"6-普利姆算法\"><a class=\"markdownIt-Anchor\" href=\"#6-普利姆算法\">#</a> 6、普利姆算法</h1>\n<h2 id=\"最小生成树\"><a class=\"markdownIt-Anchor\" href=\"#最小生成树\">#</a> 最小生成树</h2>\n<p><strong>最小生成树 (Minimum Cost Spanning Tree)，简称 MST。</strong></p>\n<ol>\n<li>\n<p>给定一个带权的无向连通图，如何选取一棵生成树，使树上所有<strong>边上权的总和为最小</strong>，这叫最小生成树</p>\n</li>\n<li>\n<p>N 个顶点，一定有 N-1 条边</p>\n</li>\n<li>\n<p>包含全部顶点</p>\n</li>\n<li>\n<p>N-1 条边都在图中</p>\n</li>\n</ol>\n<p><a href=\"https://imgtu.com/i/RHpLa6\"><img src=\"https://z3.ax1x.com/2021/07/07/RHpLa6.png\" alt=\"RHpLa6.png\"></a></p>\n<p>求最小生成树的算法主要是<strong>普里姆算法</strong>和<strong>克鲁斯卡尔算法</strong></p>\n<h2 id=\"简单介绍-5\"><a class=\"markdownIt-Anchor\" href=\"#简单介绍-5\">#</a> 简单介绍</h2>\n<p>1) 普利姆 (Prim) 算法求最小生成树，也就是在包含 n 个顶点的连通图中，找出只有 (n-1) 条边包含所有 n 个顶点的连通子图，也就是所谓的<strong>极小连通子图</strong></p>\n<p>2) 普利姆的算法如下:</p>\n<p>(1) 设 G=(V,E) 是连通网，T=(U,D) 是最小生成树，V,U 是顶点集合，E,D 是边的集合</p>\n<p>(2) 若从顶点 u 开始构造最小生成树，则从集合 V 中取出顶点 u 放入集合 U 中，标记顶点 v 的 visited [u]=1</p>\n<p>(3) 若集合 U 中顶点 ui 与集合 V-U 中的顶点 vj 之间存在边，则寻找这些边中权值最小的边，但不能构成回路，将顶点 vj 加入集合 U 中，将边（ui,vj）加入集合 D 中，标记 visited [vj]=1</p>\n<p>(4) 重复步骤②，直到 U 与 V 相等，即所有顶点都被标记为访问过，此时 D 中有 n-1 条边</p>\n<p><a href=\"https://imgtu.com/i/RH99sA\"><img src=\"https://z3.ax1x.com/2021/07/07/RH99sA.png\" alt=\"RH99sA.png\"></a></p>\n<h2 id=\"应用场景修理问题\"><a class=\"markdownIt-Anchor\" href=\"#应用场景修理问题\">#</a> 应用场景 (修理问题)</h2>\n<p><a href=\"https://imgtu.com/i/RH30vd\"><img src=\"https://z3.ax1x.com/2021/07/07/RH30vd.png\" alt=\"RH30vd.png\"></a></p>\n<p>1) 有胜利乡有 7 个村庄 (A, B, C, D, E, F, G) ，现在需要修路把 7 个村庄连通</p>\n<p>2) 各个村庄的距离用边线表示 (权) ，比如 A – B 距离 5 公里</p>\n<p>3) 问：如何修路保证各个村庄都能连通，并且总的修建公路总里程最短？</p>\n<p>思路：将 10 条边，连接即可，但是总的里程数不是最小.</p>\n<p><strong>正确的思路</strong>，就是尽可能的选择少的路线，并且每条路线最小，保证总里程数最少.</p>\n<h2 id=\"代码展示-4\"><a class=\"markdownIt-Anchor\" href=\"#代码展示-4\">#</a> 代码展示</h2>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> demo07;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Arrays;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PrimAlgorithm</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//测试看看图是否创建成功</span></span><br><span class=\"line\">        <span class=\"keyword\">char</span>[] data = <span class=\"keyword\">new</span> <span class=\"keyword\">char</span>[]&#123;<span class=\"string\">&#x27;A&#x27;</span>, <span class=\"string\">&#x27;B&#x27;</span>, <span class=\"string\">&#x27;C&#x27;</span>, <span class=\"string\">&#x27;D&#x27;</span>, <span class=\"string\">&#x27;E&#x27;</span>, <span class=\"string\">&#x27;F&#x27;</span>, <span class=\"string\">&#x27;G&#x27;</span>&#125;;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> verxs = data.length;</span><br><span class=\"line\">        <span class=\"comment\">//邻接矩阵的关系使用二维数组表示,10000这个大数，表示两个点不连通</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span>[][] weight = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[][]&#123;</span><br><span class=\"line\">                &#123;<span class=\"number\">10000</span>, <span class=\"number\">5</span>, <span class=\"number\">7</span>, <span class=\"number\">10000</span>, <span class=\"number\">10000</span>, <span class=\"number\">10000</span>, <span class=\"number\">2</span>&#125;,</span><br><span class=\"line\">                &#123;<span class=\"number\">5</span>, <span class=\"number\">10000</span>, <span class=\"number\">10000</span>, <span class=\"number\">9</span>, <span class=\"number\">10000</span>, <span class=\"number\">10000</span>, <span class=\"number\">3</span>&#125;,</span><br><span class=\"line\">                &#123;<span class=\"number\">7</span>, <span class=\"number\">10000</span>, <span class=\"number\">10000</span>, <span class=\"number\">10000</span>, <span class=\"number\">8</span>, <span class=\"number\">10000</span>, <span class=\"number\">10000</span>&#125;,</span><br><span class=\"line\">                &#123;<span class=\"number\">10000</span>, <span class=\"number\">9</span>, <span class=\"number\">10000</span>, <span class=\"number\">10000</span>, <span class=\"number\">10000</span>, <span class=\"number\">4</span>, <span class=\"number\">10000</span>&#125;,</span><br><span class=\"line\">                &#123;<span class=\"number\">10000</span>, <span class=\"number\">10000</span>, <span class=\"number\">8</span>, <span class=\"number\">10000</span>, <span class=\"number\">10000</span>, <span class=\"number\">5</span>, <span class=\"number\">4</span>&#125;,</span><br><span class=\"line\">                &#123;<span class=\"number\">10000</span>, <span class=\"number\">10000</span>, <span class=\"number\">10000</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">10000</span>, <span class=\"number\">6</span>&#125;,</span><br><span class=\"line\">                &#123;<span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">10000</span>, <span class=\"number\">10000</span>, <span class=\"number\">4</span>, <span class=\"number\">6</span>, <span class=\"number\">10000</span>&#125;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        <span class=\"comment\">//创建一个MGraph对象</span></span><br><span class=\"line\">        MGraph graph=<span class=\"keyword\">new</span> MGraph(verxs);</span><br><span class=\"line\">        <span class=\"comment\">//创建一个MinTree对象</span></span><br><span class=\"line\">        MinTree minTree=<span class=\"keyword\">new</span> MinTree();</span><br><span class=\"line\">        minTree.createGraph(graph,verxs,data,weight);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//输出</span></span><br><span class=\"line\">        minTree.showGraph(graph);</span><br><span class=\"line\">        <span class=\"comment\">//测试普利姆算法</span></span><br><span class=\"line\">        minTree.prim(graph,<span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//创建最小生成树 -&gt; 村庄路线图</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MinTree</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 创建图的邻接矩阵</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> graph  图对象</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> verxs  图对应的顶点个数</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> data   图的各个顶点的值</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> weight 图的邻接矩阵</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">createGraph</span><span class=\"params\">(MGraph graph, <span class=\"keyword\">int</span> verxs, <span class=\"keyword\">char</span>[] data, <span class=\"keyword\">int</span>[][] weight)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> i, j;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; verxs; i++) &#123; <span class=\"comment\">//顶点</span></span><br><span class=\"line\">            graph.data[i] = data[i];</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (j = <span class=\"number\">0</span>; j &lt; verxs; j++) &#123;</span><br><span class=\"line\">                graph.weight[i][j] = weight[i][j];</span><br><span class=\"line\"></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//显示图的方法 就是显示图的邻接矩阵</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">showGraph</span><span class=\"params\">(MGraph graph)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span>[] link : graph.weight) &#123;</span><br><span class=\"line\">            System.out.println(Arrays.toString(link));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     *  编写Prim算法，生成最小生成树</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> graph  图</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> v   表示从图的第几个顶点开始生成 &#x27;A&#x27;-0 &#x27;B&#x27;-1...</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">prim</span><span class=\"params\">(MGraph graph,<span class=\"keyword\">int</span> v)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//visited[] 标记结点(顶点) 是否被访问过</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] visited=<span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[graph.verxs];</span><br><span class=\"line\">        <span class=\"comment\">//visited[] 默认元素的值都是0，表示没有访问过</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; graph.verxs; i++) &#123;</span><br><span class=\"line\">            visited[i]=<span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//把当前这个节点标记为已访问</span></span><br><span class=\"line\">        visited[v] = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"comment\">// h1 和 h2 记录两个顶点的下标</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> h1=-<span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> h2=-<span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> minWeight=<span class=\"number\">10000</span>; <span class=\"comment\">//将 minWeight 初始成一个大叔，后面遍历过程中，会被替换</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> k = <span class=\"number\">1</span>; k &lt; graph.verxs; k++) &#123; <span class=\"comment\">// 因为有 graph.verxs 个顶点，普利姆算法结束后有 graph.verxs-1 条边</span></span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">//这个是确定每一次生成的子图，和那个结点的距离最近</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; graph.verxs; i++) &#123; <span class=\"comment\">// i 结点表示被访问过的结点</span></span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; graph.verxs; j++) &#123; <span class=\"comment\">//j 结点表示没有被访问过的结点</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (visited[i] ==<span class=\"number\">1</span> &amp;&amp; visited[j]==<span class=\"number\">0</span>&amp;&amp;graph.weight[i][j]&lt;minWeight)&#123;</span><br><span class=\"line\">                        <span class=\"comment\">//替换minWeight (寻找已经访问过的结点和未访问过的结点的权值最小的边)</span></span><br><span class=\"line\">                        minWeight=graph.weight[i][j];</span><br><span class=\"line\">                        h1=i;</span><br><span class=\"line\">                        h2=j;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">//找到一条边是最小</span></span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;边&lt;&quot;</span>+graph.data[h1]+<span class=\"string\">&quot;,&quot;</span>+graph.data[h2]+<span class=\"string\">&quot;&gt;权值为：&quot;</span>+minWeight);</span><br><span class=\"line\">            <span class=\"comment\">//将当前这个节点标记为已经访问</span></span><br><span class=\"line\">            visited[h2] = <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"comment\">// minWeight 重新设置为最大值 10000</span></span><br><span class=\"line\">            minWeight=<span class=\"number\">10000</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MGraph</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> verxs; <span class=\"comment\">//表示图的节点个数</span></span><br><span class=\"line\">    <span class=\"keyword\">char</span>[] data; <span class=\"comment\">//存放结点数据</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span>[][] weight; <span class=\"comment\">//存放边，就是邻接矩阵</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">MGraph</span><span class=\"params\">(<span class=\"keyword\">int</span> verxs)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.verxs = verxs;</span><br><span class=\"line\">        data = <span class=\"keyword\">new</span> <span class=\"keyword\">char</span>[verxs];</span><br><span class=\"line\">        weight = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[verxs][verxs];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"7-克鲁斯卡尔算法\"><a class=\"markdownIt-Anchor\" href=\"#7-克鲁斯卡尔算法\">#</a> 7、克鲁斯卡尔算法</h1>\n<h2 id=\"简单介绍-6\"><a class=\"markdownIt-Anchor\" href=\"#简单介绍-6\">#</a> 简单介绍</h2>\n<p>1) 克鲁斯卡尔 (Kruskal) 算法，是用来求加权连通图的最小生成树的算法。</p>\n<p>2)<strong> 基本思想</strong>：按照权值从小到大的顺序选择 n-1 条边，并保证这 n-1 条边不构成回路</p>\n<p>3)<strong> 具体做法</strong>：首先构造一个只含 n 个顶点的森林，然后依权值从小到大从连通网中选择边加入到森林中，并使森林中不产生回路，直至森林变成一棵树为止</p>\n<h2 id=\"思路分析1-最小生成树\"><a class=\"markdownIt-Anchor\" href=\"#思路分析1-最小生成树\">#</a> 思路分析 1、最小生成树</h2>\n<p>在含有 n 个顶点的连通图中选择 n-1 条边，构成一棵极小连通子图，并使该连通子图中 n-1 条边上权值之和达到最小，则称其为连通网的最小生成树。</p>\n<p><a href=\"https://imgtu.com/i/RH8PIK\"><img src=\"https://z3.ax1x.com/2021/07/07/RH8PIK.png\" alt=\"RH8PIK.png\"></a></p>\n<p>例如，对于如上图 G4 所示的连通网可以有多棵权值总和不相同的生成树</p>\n<p><a href=\"https://imgtu.com/i/RH8kGD\"><img src=\"https://z3.ax1x.com/2021/07/07/RH8kGD.png\" alt=\"RH8kGD.png\"></a></p>\n<h2 id=\"思路分析2-算法图解\"><a class=\"markdownIt-Anchor\" href=\"#思路分析2-算法图解\">#</a> 思路分析 2、算法图解</h2>\n<p>以上图 G4 为例，来对克鲁斯卡尔进行演示 (假设，用数组 R 保存最小生成树结果)。</p>\n<p><a href=\"https://imgtu.com/i/RH8ARe\"><img src=\"https://z3.ax1x.com/2021/07/07/RH8ARe.png\" alt=\"RH8ARe.png\"></a></p>\n<p><strong>第 1 步</strong>：将边 &lt;E,F&gt; 加入 R 中。<br>\n边 &lt;E,F&gt; 的权值最小，因此将它加入到最小生成树结果 R 中。<br>\n<strong>第 2 步</strong>：将边 &lt;C,D&gt; 加入 R 中。<br>\n上一步操作之后，边 &lt;C,D&gt; 的权值最小，因此将它加入到最小生成树结果 R 中。<br>\n<strong>第 3 步</strong>：将边 &lt;D,E&gt; 加入 R 中。<br>\n上一步操作之后，边 &lt;D,E&gt; 的权值最小，因此将它加入到最小生成树结果 R 中。<br>\n<strong>第 4 步</strong>：将边 &lt;B,F&gt; 加入 R 中。<br>\n上一步操作之后，边 &lt;C,E&gt; 的权值最小，但 &lt; C,E &gt; 会和已有的边构成回路；因此，跳过边 &lt; C,E&gt;。同理，跳过边 &lt; C,F&gt;。将边 &lt; B,F &gt; 加入到最小生成树结果 R 中。<br>\n<strong>第 5 步</strong>：将边 &lt;E,G&gt; 加入 R 中。<br>\n上一步操作之后，边 &lt;E,G&gt; 的权值最小，因此将它加入到最小生成树结果 R 中。<br>\n<strong>第 6 步</strong>：将边 &lt;A,B&gt; 加入 R 中。<br>\n上一步操作之后，边 &lt;F,G&gt; 的权值最小，但 &lt; F,G &gt; 会和已有的边构成回路；因此，跳过边 &lt; F,G&gt;。同理，跳过边 &lt; B,C&gt;。将边 &lt; A,B &gt; 加入到最小生成树结果 R 中。</p>\n<p>此时，最小生成树构造完成！它包括的边依次是：<strong>&lt;E,F&gt; &lt;C,D&gt; &lt;D,E&gt; &lt;B,F&gt; &lt;E,G&gt; &lt;A,B&gt;</strong></p>\n<h2 id=\"思路分析3-算法分析\"><a class=\"markdownIt-Anchor\" href=\"#思路分析3-算法分析\">#</a> 思路分析 3、算法分析</h2>\n<p>根据前面介绍的克鲁斯卡尔算法的基本思想和做法，我们能够了解到，克鲁斯卡尔算法重点需要解决的以下两个问题：<br>\n<strong>问题一</strong> 对图的所有边按照权值大小进行排序。<br>\n<strong>问题二</strong> 将边添加到最小生成树中时，怎么样判断是否形成了回路。</p>\n<p>问题一很好解决，采用排序算法进行排序即可。</p>\n<p>问题二，处理方式是：记录顶点在 &quot;最小生成树&quot; 中的终点，顶点的终点是 &quot;在最小生成树中与它连通的最大顶点&quot;。然后每次需要将一条边添加到最小生存树时，判断该边的两个顶点的终点是否重合，重合的话则会构成回路。</p>\n<h2 id=\"思路分析4-判断是否构成回路\"><a class=\"markdownIt-Anchor\" href=\"#思路分析4-判断是否构成回路\">#</a> 思路分析 4、判断是否构成回路</h2>\n<p><a href=\"https://imgtu.com/i/RH8ExH\"><img src=\"https://z3.ax1x.com/2021/07/07/RH8ExH.png\" alt=\"RH8ExH.png\"></a></p>\n<p>在将 &lt;E,F&gt; &lt;C,D&gt; &lt;D,E &gt; 加入到最小生成树 R 中之后，这几条边的顶点就都有了终点：</p>\n<p>​\t\t<strong>(01)</strong> C 的终点是 F。<br>\n<strong>(02)</strong> D 的终点是 F。<br>\n<strong>(03)</strong> E 的终点是 F。<br>\n​\t\t<strong>(04)</strong> F 的终点是 F。</p>\n<p>关于终点的说明：</p>\n<ol>\n<li>就是将所有顶点按照从小到大的顺序排列好之后；某个顶点的终点就是 &quot;与它连通的最大顶点&quot;。</li>\n</ol>\n<p>因此，接下来，虽然 &lt;C,E&gt; 是权值最小的边。但是 C 和 E 的终点都是 F，即它们的终点相同，因此，将 &lt; C,E &gt; 加入最小生成树的话，会形成回路。这就是判断回路的方式。也就是说，我们加入的<strong>边</strong>的<strong>两个顶点不能都指向同一个终点</strong>，否则将构成回路。【后面有代码说明】</p>\n<h2 id=\"代码展示-5\"><a class=\"markdownIt-Anchor\" href=\"#代码展示-5\">#</a> 代码展示</h2>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br><span class=\"line\">194</span><br><span class=\"line\">195</span><br><span class=\"line\">196</span><br><span class=\"line\">197</span><br><span class=\"line\">198</span><br><span class=\"line\">199</span><br><span class=\"line\">200</span><br><span class=\"line\">201</span><br><span class=\"line\">202</span><br><span class=\"line\">203</span><br><span class=\"line\">204</span><br><span class=\"line\">205</span><br><span class=\"line\">206</span><br><span class=\"line\">207</span><br><span class=\"line\">208</span><br><span class=\"line\">209</span><br><span class=\"line\">210</span><br><span class=\"line\">211</span><br><span class=\"line\">212</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> demo08;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Arrays;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//克鲁斯卡尔算法 解决 公交问题</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">KruskalCase</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> edgeNum; <span class=\"comment\">//记录边的个数</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">char</span>[] vertexs; <span class=\"comment\">//顶点数组</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span>[][] matrix; <span class=\"comment\">//邻接矩阵</span></span><br><span class=\"line\">    <span class=\"comment\">//使用 INF 表示两个顶点不能连通</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> INF = Integer.MAX_VALUE;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">char</span>[] vertexs = &#123;<span class=\"string\">&#x27;A&#x27;</span>, <span class=\"string\">&#x27;B&#x27;</span>, <span class=\"string\">&#x27;C&#x27;</span>, <span class=\"string\">&#x27;D&#x27;</span>, <span class=\"string\">&#x27;E&#x27;</span>, <span class=\"string\">&#x27;F&#x27;</span>, <span class=\"string\">&#x27;G&#x27;</span>&#125;;</span><br><span class=\"line\">        <span class=\"keyword\">int</span>[][] matrix = &#123;</span><br><span class=\"line\">                <span class=\"comment\">/*A     B   C      D   E    F    G  */</span></span><br><span class=\"line\">                <span class=\"comment\">/* A */</span>   &#123;<span class=\"number\">0</span>, <span class=\"number\">12</span>, INF, INF, INF, <span class=\"number\">16</span>, <span class=\"number\">14</span>&#125;,</span><br><span class=\"line\">                <span class=\"comment\">/* B */</span>   &#123;<span class=\"number\">12</span>, <span class=\"number\">0</span>, <span class=\"number\">10</span>, INF, INF, <span class=\"number\">7</span>, INF&#125;,</span><br><span class=\"line\">                <span class=\"comment\">/* C */</span>   &#123;INF, <span class=\"number\">10</span>, <span class=\"number\">0</span>, <span class=\"number\">3</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>, INF&#125;,</span><br><span class=\"line\">                <span class=\"comment\">/* D */</span>   &#123;INF, INF, <span class=\"number\">3</span>, <span class=\"number\">0</span>, <span class=\"number\">4</span>, INF, INF&#125;,</span><br><span class=\"line\">                <span class=\"comment\">/* E */</span>   &#123;INF, INF, <span class=\"number\">5</span>, <span class=\"number\">4</span>, <span class=\"number\">0</span>, <span class=\"number\">2</span>, <span class=\"number\">8</span>&#125;,</span><br><span class=\"line\">                <span class=\"comment\">/* F */</span>   &#123;<span class=\"number\">16</span>, <span class=\"number\">7</span>, <span class=\"number\">6</span>, INF, <span class=\"number\">2</span>, <span class=\"number\">0</span>, <span class=\"number\">9</span>&#125;,</span><br><span class=\"line\">                <span class=\"comment\">/* G */</span>   &#123;<span class=\"number\">14</span>, INF, INF, INF, <span class=\"number\">8</span>, <span class=\"number\">9</span>, <span class=\"number\">0</span>&#125;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//创建KruskalCase 对象实例</span></span><br><span class=\"line\">        KruskalCase kruskalCase = <span class=\"keyword\">new</span> KruskalCase(vertexs, matrix);</span><br><span class=\"line\">        kruskalCase.print();</span><br><span class=\"line\"></span><br><span class=\"line\">        EDate[] edges = kruskalCase.getEdges();</span><br><span class=\"line\">        <span class=\"comment\">//未排序</span></span><br><span class=\"line\">        System.out.println(Arrays.toString(edges));</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//已排序</span></span><br><span class=\"line\">        kruskalCase.sortEdge(edges);</span><br><span class=\"line\">        System.out.println(Arrays.toString(edges));</span><br><span class=\"line\"></span><br><span class=\"line\">        kruskalCase.kruskal();</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">kruskal</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> index = <span class=\"number\">0</span>; <span class=\"comment\">//表示最后结果数组的索引</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] ends = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[edgeNum]; <span class=\"comment\">//用于保存 “已有最小生成树” 中的每个顶点在最小生成树中的终点</span></span><br><span class=\"line\">        <span class=\"comment\">//创建结果数组 保存最后的最小生成树</span></span><br><span class=\"line\">        EDate[] rets = <span class=\"keyword\">new</span> EDate[edgeNum];</span><br><span class=\"line\">        <span class=\"comment\">//先获取图中所有的边的集合</span></span><br><span class=\"line\">        EDate[] edges = getEdges();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;图的边的集合&quot;</span> + Arrays.toString(edges) + <span class=\"string\">&quot;共&quot;</span> + edges.length + <span class=\"string\">&quot;条边&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//按照边的权值大小进行排序（从小到大）</span></span><br><span class=\"line\">        sortEdge(edges);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//遍历 edges 数组，将边添加到最小生成树中时，判断准备加入的边是否构成回路，如果没有，就加入 rets,否则不能加入</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; edgeNum; i++) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//获取到第 i 条边的第一个顶点（起点）</span></span><br><span class=\"line\">            <span class=\"keyword\">int</span> p1 = getPosition(edges[i].start); <span class=\"comment\">//p1</span></span><br><span class=\"line\">            <span class=\"comment\">//获取第 i 条边的第2个顶点</span></span><br><span class=\"line\">            <span class=\"keyword\">int</span> p2 = getPosition(edges[i].end);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">//获取p1这个顶点在已有最小生成树中的终点</span></span><br><span class=\"line\">            <span class=\"keyword\">int</span> m = getEnd(ends, p1);</span><br><span class=\"line\">            <span class=\"comment\">//取p1这个顶点在已有最小生成树中的终点</span></span><br><span class=\"line\">            <span class=\"keyword\">int</span> n = getEnd(ends, p2);</span><br><span class=\"line\">            <span class=\"comment\">//判断是否构成回路</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (m != n) &#123;<span class=\"comment\">//说明没有构成回路</span></span><br><span class=\"line\">                ends[m] = n; <span class=\"comment\">// 设置m在 “已有最小生成树” 中的终点 &lt;E,F&gt; [0,0,0,0,0,0,0,0,0,0,0,0]</span></span><br><span class=\"line\">                rets[index++] = edges[i];<span class=\"comment\">//有一条边 加入到</span></span><br><span class=\"line\"></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//统计并打印 “最小生成树” ，输出 rets</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;最小生成树为&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; index; i++) &#123;</span><br><span class=\"line\">            System.out.println(rets[i]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//构造器</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">KruskalCase</span><span class=\"params\">(<span class=\"keyword\">char</span>[] vertexs, <span class=\"keyword\">int</span>[][] matrix)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//初始化顶点数和边的个数</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> vlen = vertexs.length;</span><br><span class=\"line\">        <span class=\"comment\">//初始化顶点,复制拷贝的方式</span></span><br><span class=\"line\">        <span class=\"keyword\">this</span>.vertexs = <span class=\"keyword\">new</span> <span class=\"keyword\">char</span>[vlen];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; vertexs.length; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.vertexs[i] = vertexs[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//初始化边,使用的是复制拷贝的方式</span></span><br><span class=\"line\">        <span class=\"keyword\">this</span>.matrix = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[vlen][vlen];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; vlen; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; vlen; j++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">this</span>.matrix[i][j] = matrix[i][j];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//统计边的条数</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; vlen; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = i + <span class=\"number\">1</span>; j &lt; vlen; j++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.matrix[i][j] != INF) &#123;</span><br><span class=\"line\">                    edgeNum++;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//打印邻接矩阵</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">print</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;邻接矩阵为：&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; vertexs.length; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; vertexs.length; j++) &#123;</span><br><span class=\"line\">                System.out.printf(<span class=\"string\">&quot;%12d\\t&quot;</span>, matrix[i][j]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">//换行处理</span></span><br><span class=\"line\">            System.out.println();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 对边的权值进行排序处理冒泡排序</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> edges 边的集合</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">sortEdge</span><span class=\"params\">(EDate[] edges)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; edges.length - <span class=\"number\">1</span>; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; edges.length - <span class=\"number\">1</span> - i; j++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (edges[j].weight &gt; edges[j + <span class=\"number\">1</span>].weight) &#123;<span class=\"comment\">//交换</span></span><br><span class=\"line\">                    EDate tmp = edges[j];</span><br><span class=\"line\">                    edges[j] = edges[j + <span class=\"number\">1</span>];</span><br><span class=\"line\">                    edges[j + <span class=\"number\">1</span>] = tmp;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> ch 顶点的值，比如&#x27;A&#x27; &#x27;B&#x27;</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> 返回 ch 顶点对应的下标，如果找不到，返回 -1</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> <span class=\"title\">getPosition</span><span class=\"params\">(<span class=\"keyword\">char</span> ch)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; vertexs.length; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (vertexs[i] == ch) &#123; <span class=\"comment\">//找到</span></span><br><span class=\"line\">                <span class=\"keyword\">return</span> i;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//找不到 返回 -1</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 功能：获取图中边，放到EDate[] 数组中，后面我们需要遍历该数组</span></span><br><span class=\"line\"><span class=\"comment\">     * 是通过matrix 邻接矩阵来获取</span></span><br><span class=\"line\"><span class=\"comment\">     * EDate 形式[[&#x27;A&#x27;,&#x27;B&#x27;,12],[&#x27;B&#x27;,&#x27;F&#x27;,7]...]</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> EDate[] getEdges() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> index = <span class=\"number\">0</span>;</span><br><span class=\"line\">        EDate[] edges = <span class=\"keyword\">new</span> EDate[edgeNum];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; vertexs.length; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = i + <span class=\"number\">1</span>; j &lt; vertexs.length; j++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (matrix[i][j] != INF) &#123;</span><br><span class=\"line\">                    edges[index++] = <span class=\"keyword\">new</span> EDate(vertexs[i], vertexs[j], matrix[i][j]);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> edges;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 获取下标为 i 的顶点的终点，用于后面判断两个顶点的终点是否相同</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> ends 数组就是记录了各个顶点对应的终点是哪个， ends 数组是在遍历过程中逐步形成的</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> i    表示传入的顶点对应的下标</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> 返回下标为 i的这个顶点对应的终点的下标</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> <span class=\"title\">getEnd</span><span class=\"params\">(<span class=\"keyword\">int</span>[] ends, <span class=\"keyword\">int</span> i)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (ends[i] != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            i = ends[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> i;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//创建一个类EDate，它的对象实例就是一条边</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">EDate</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> start; <span class=\"comment\">//边的一个点</span></span><br><span class=\"line\">    <span class=\"keyword\">char</span> end;  <span class=\"comment\">//边的另一个店</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> weight; <span class=\"comment\">//边的权值</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//构造器</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">EDate</span><span class=\"params\">(<span class=\"keyword\">char</span> start, <span class=\"keyword\">char</span> end, <span class=\"keyword\">int</span> weight)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.start = start;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.end = end;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.weight = weight;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//重写toString方法，便于输出边</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">toString</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;EDate&#123;&lt;&quot;</span> + start + <span class=\"string\">&quot;,&quot;</span> + end + <span class=\"string\">&quot;&gt; = &quot;</span> + weight + <span class=\"string\">&#x27;&#125;&#x27;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h1 id=\"8-迪杰斯特拉算法\"><a class=\"markdownIt-Anchor\" href=\"#8-迪杰斯特拉算法\">#</a> 8、迪杰斯特拉算法</h1>\n<h2 id=\"简单介绍-7\"><a class=\"markdownIt-Anchor\" href=\"#简单介绍-7\">#</a> 简单介绍</h2>\n<p>迪杰斯特拉 (Dijkstra) 算法是<strong>典型最短路径算法</strong>，用于计算一个结点到其他结点的最短路径。 它的主要特点是以起始点为中心向外层层扩展 (<strong>广度优先</strong>搜索思想)，直到扩展到终点为止</p>\n<h2 id=\"思路分析-2\"><a class=\"markdownIt-Anchor\" href=\"#思路分析-2\">#</a> 思路分析</h2>\n<p>设置出发顶点为 v，顶点集合 V {v1,v2,vi…}，v 到 V 中各顶点的距离构成距离集合 Dis，Dis {d1,d2,di…}，Dis 集合记录着 v 到图中各顶点的距离 (到自身可以看作 0，v 到 vi 距离对应为 di)</p>\n<p>1) 从 Dis 中选择值最小的 di 并移出 Dis 集合，同时移出 V 集合中对应的顶点 vi，此时的 v 到 vi 即为最短路径</p>\n<p>2) 更新 Dis 集合，更新规则为：比较 v 到 V 集合中顶点的距离值，与 v 通过 vi 到 V 集合中顶点的距离值，保留值较小的一个 (同时也应该更新顶点的前驱节点为 vi，表明是通过 vi 到达的)</p>\n<p>3) 重复执行两步骤，直到最短路径顶点为目标顶点即可结束</p>\n<p><a href=\"https://imgtu.com/i/RH8KdP\"><img src=\"https://z3.ax1x.com/2021/07/07/RH8KdP.png\" alt=\"RH8KdP.png\"></a></p>\n<h2 id=\"应用场景-最短路径\"><a class=\"markdownIt-Anchor\" href=\"#应用场景-最短路径\">#</a> 应用场景 - 最短路径</h2>\n<p><a href=\"https://imgtu.com/i/RH30vd\"><img src=\"https://z3.ax1x.com/2021/07/07/RH30vd.png\" alt=\"RH30vd.png\"></a></p>\n<p>1) 战争时期，胜利乡有 7 个村庄 (A, B, C, D, E, F, G) ，现在有六个邮差，从 G 点出发，需要分别把邮件分别送到 A, B, C , D, E, F 六个村庄</p>\n<p>2) 各个村庄的距离用边线表示 (权) ，比如 A – B 距离 5 公里</p>\n<p>3) 问：如何计算出 G 村庄到 其它各个村庄的最短距离？</p>\n<p>4) 如果从其它点出发到各个点的最短距离又是多少？</p>\n<h2 id=\"代码展示-6\"><a class=\"markdownIt-Anchor\" href=\"#代码展示-6\">#</a> 代码展示</h2>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> demo09;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Arrays;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DijkstraAlforithm</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">char</span>[] vertex = <span class=\"keyword\">new</span> <span class=\"keyword\">char</span>[]&#123;<span class=\"string\">&#x27;A&#x27;</span>, <span class=\"string\">&#x27;B&#x27;</span>, <span class=\"string\">&#x27;C&#x27;</span>, <span class=\"string\">&#x27;D&#x27;</span>, <span class=\"string\">&#x27;E&#x27;</span>, <span class=\"string\">&#x27;F&#x27;</span>, <span class=\"string\">&#x27;G&#x27;</span>&#125;;</span><br><span class=\"line\">        <span class=\"comment\">//邻接矩阵</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span>[][] matrix = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[vertex.length][vertex.length];</span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> N = <span class=\"number\">65535</span>;<span class=\"comment\">//表示不可连接</span></span><br><span class=\"line\">        matrix[<span class=\"number\">0</span>] = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[]&#123;N, <span class=\"number\">5</span>, <span class=\"number\">7</span>, N, N, N, <span class=\"number\">2</span>&#125;;</span><br><span class=\"line\">        matrix[<span class=\"number\">1</span>] = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[]&#123;<span class=\"number\">5</span>, N, N, <span class=\"number\">9</span>, N, N, <span class=\"number\">3</span>&#125;;</span><br><span class=\"line\">        matrix[<span class=\"number\">2</span>] = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[]&#123;<span class=\"number\">7</span>, N, N, N, <span class=\"number\">8</span>, N, N&#125;;</span><br><span class=\"line\">        matrix[<span class=\"number\">3</span>] = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[]&#123;N, <span class=\"number\">9</span>, N, N, N, <span class=\"number\">4</span>, N&#125;;</span><br><span class=\"line\">        matrix[<span class=\"number\">4</span>] = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[]&#123;N, N, <span class=\"number\">8</span>, N, N, <span class=\"number\">5</span>, <span class=\"number\">4</span>&#125;;</span><br><span class=\"line\">        matrix[<span class=\"number\">5</span>] = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[]&#123;N, N, N, <span class=\"number\">4</span>, <span class=\"number\">5</span>, N, <span class=\"number\">6</span>&#125;;</span><br><span class=\"line\">        matrix[<span class=\"number\">6</span>] = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[]&#123;<span class=\"number\">2</span>, <span class=\"number\">3</span>, N, N, <span class=\"number\">4</span>, <span class=\"number\">6</span>, N&#125;;</span><br><span class=\"line\">        <span class=\"comment\">//创建Graph对象</span></span><br><span class=\"line\">        Graph graph = <span class=\"keyword\">new</span> Graph(vertex, matrix);</span><br><span class=\"line\">        <span class=\"comment\">//测试，看看图的邻接矩阵是否OK</span></span><br><span class=\"line\">        graph.show();</span><br><span class=\"line\">        <span class=\"comment\">//测试一把迪杰斯特拉算法</span></span><br><span class=\"line\">        graph.dijkstra(<span class=\"number\">6</span>);</span><br><span class=\"line\">        graph.showDijkstra();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//创建图</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Graph</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">char</span>[] vertex;  <span class=\"comment\">//顶点数组</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span>[][] matrix; <span class=\"comment\">//邻接矩阵</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> VisitedVertex vv; <span class=\"comment\">//已经访问的顶点的集合</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//构造器</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Graph</span><span class=\"params\">(<span class=\"keyword\">char</span>[] vertex, <span class=\"keyword\">int</span>[][] matrix)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.vertex = vertex;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.matrix = matrix;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//显示图</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">show</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span>[] link : matrix) &#123;</span><br><span class=\"line\">            System.out.println(Arrays.toString(link));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//迪杰斯特拉算法实现</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">dijkstra</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span> </span>&#123;</span><br><span class=\"line\">        vv = <span class=\"keyword\">new</span> VisitedVertex(vertex.length, index);</span><br><span class=\"line\">        update(index); <span class=\"comment\">//更新index顶点到周围顶点的距离和前驱顶点</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">1</span>; j &lt; vertex.length; j++) &#123;</span><br><span class=\"line\">            index=vv.updateArr();<span class=\"comment\">//选择并返回新的访问顶点</span></span><br><span class=\"line\">            update(index); <span class=\"comment\">//更新index顶点到周围顶点的距离和前驱顶点</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//更新index下标顶点到周围顶点的距离和中欧为顶点的前驱顶点</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">update</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> len = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"comment\">//根据遍历我们的邻接矩阵 matrix[index]</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; matrix[index].length; j++) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// len 含义是：出发顶点到index顶点的距离 + 从 index 到 j 顶点的距离的和</span></span><br><span class=\"line\">            len = vv.getDis(index) + matrix[index][j];</span><br><span class=\"line\">            <span class=\"comment\">//如果 j 顶点没有被访问过，并且len 小于出发顶点到 j 顶点 的距离，就需要更新</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!vv.in(j) &amp;&amp; len &lt; vv.getDis(j)) &#123;</span><br><span class=\"line\">                vv.updatePre(j, index); <span class=\"comment\">//更新 j 顶点的前驱为 index 顶点</span></span><br><span class=\"line\">                vv.updateDis(j, len);  <span class=\"comment\">// 更新出发顶点到 j 顶点的距离</span></span><br><span class=\"line\"></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">showDijkstra</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        vv.show();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//已访问顶点的集合</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">VisitedVertex</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//记录各个顶点是否访问，1表示访问过，0未访问，会动态更新</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">int</span>[] already_arr;</span><br><span class=\"line\">    <span class=\"comment\">//每个下标对应的值为前一个顶点下标，会动态更新</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">int</span>[] pre_visited;</span><br><span class=\"line\">    <span class=\"comment\">//记录出发顶点到其他所有顶点的距离，比如 G 为出发顶点，就会记录G到其他顶点的距离，会动态更新，求出的最短距离就会记录到dis</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">int</span>[] dis;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 构造器</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> length 表示顶点的个数</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> index  表示出发顶点对应的下标 比如G顶点，下标就是6</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">VisitedVertex</span><span class=\"params\">(<span class=\"keyword\">int</span> length, <span class=\"keyword\">int</span> index)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.already_arr = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[length];</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.pre_visited = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[length];</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.dis = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[length];</span><br><span class=\"line\">        <span class=\"comment\">//初始化 dis 数组</span></span><br><span class=\"line\">        Arrays.fill(dis, <span class=\"number\">65535</span>);</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.already_arr[index] = <span class=\"number\">1</span>; <span class=\"comment\">//设置出发订单被访问为1</span></span><br><span class=\"line\">        <span class=\"keyword\">this</span>.dis[index] = <span class=\"number\">0</span>;<span class=\"comment\">//设置出发顶点的访问距离为0</span></span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 判断index顶点是否被访问过</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> index</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> 如果被访问过，就返回true，否则返回false</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">in</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> already_arr[index] == <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 更新出发顶点到index顶点的距离</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> index</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> len</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">updateDis</span><span class=\"params\">(<span class=\"keyword\">int</span> index, <span class=\"keyword\">int</span> len)</span> </span>&#123;</span><br><span class=\"line\">        dis[index] = len;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 更新pre这个顶点的前驱顶点为index顶点</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> pre</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> index</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">updatePre</span><span class=\"params\">(<span class=\"keyword\">int</span> pre, <span class=\"keyword\">int</span> index)</span> </span>&#123;</span><br><span class=\"line\">        pre_visited[pre] = index;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 返回出发顶点到index顶点的距离</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> index</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getDis</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dis[index];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//继续选择并返回新的访问顶点，比如G点完后，就是A点作为新的访问顶点（注意不是出发顶点）</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">updateArr</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> min = <span class=\"number\">65535</span>, index = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; already_arr.length; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (already_arr[i] == <span class=\"number\">0</span> &amp;&amp; dis[i] &lt; min) &#123;</span><br><span class=\"line\">                min = dis[i];</span><br><span class=\"line\">                index = i;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//更新index，顶点被访问过</span></span><br><span class=\"line\">        already_arr[index]=<span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> index;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//显示最后的结果</span></span><br><span class=\"line\">    <span class=\"comment\">//即将三个数组的情况输出</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">show</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        System.out.println();</span><br><span class=\"line\">        <span class=\"comment\">//输出already_arr</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i : already_arr) &#123;</span><br><span class=\"line\">            System.out.print(i+<span class=\"string\">&quot; &quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println();</span><br><span class=\"line\">        <span class=\"comment\">//输出pre_visited</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i : pre_visited)&#123;</span><br><span class=\"line\">            System.out.print(i+<span class=\"string\">&quot; &quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println();</span><br><span class=\"line\">        <span class=\"comment\">//输出dis</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i : dis)&#123;</span><br><span class=\"line\">            System.out.print(i+<span class=\"string\">&quot; &quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"9-弗洛伊德算法\"><a class=\"markdownIt-Anchor\" href=\"#9-弗洛伊德算法\">#</a> 9、弗洛伊德算法</h1>\n<h2 id=\"简单介绍-8\"><a class=\"markdownIt-Anchor\" href=\"#简单介绍-8\">#</a> 简单介绍</h2>\n<p>1、和 Dijkstra 算法一样，弗洛伊德 (Floyd) 算法也是一种用于寻找给定的加权图中顶点间最短路径的算法。该算法名称以创始人之一、1978 年图灵奖获得者、斯坦福大学计算机科学系教授<strong>罗伯特・弗洛伊德</strong>命名</p>\n<p>2、弗洛伊德算法 (Floyd) 计算图中各个顶点之间的最短路径</p>\n<p>3、迪杰斯特拉算法用于计算图中某一个顶点到其他顶点的最短路径。</p>\n<p>4、<strong>弗洛伊德算法 VS 迪杰斯特拉算法</strong>：迪杰斯特拉算法通过<strong>选定的被访问顶点</strong>，求出从出<strong>发访问顶点到其他顶点的最短路径</strong>；弗洛伊德算法中<strong>每一个顶点都是出发访问点</strong>，所以需要将每一个顶点看做被访问顶点，求出从<strong>每一个顶点到其他顶点的最短路径</strong>。</p>\n<h2 id=\"思路分析-3\"><a class=\"markdownIt-Anchor\" href=\"#思路分析-3\">#</a> 思路分析</h2>\n<p>1) 设置顶点 vi 到顶点 vk 的最短路径已知为 Lik，顶点 vk 到 vj 的最短路径已知为 Lkj，顶点 vi 到 vj 的路径为 Lij，则 vi 到 vj 的最短路径为：min ((Lik+Lkj),Lij)，vk 的取值为图中所有顶点，则可获得 vi 到 vj 的最短路径</p>\n<p>2) 至于 vi 到 vk 的最短路径 Lik 或者 vk 到 vj 的最短路径 Lkj，是以同样的方式获得</p>\n<p>3) 弗洛伊德 (Floyd) 算法图解分析 - 举例说明</p>\n<p><a href=\"https://imgtu.com/i/RH83Rg\"><img src=\"https://z3.ax1x.com/2021/07/07/RH83Rg.png\" alt=\"RH83Rg.png\"></a></p>\n<h2 id=\"应用场景-3\"><a class=\"markdownIt-Anchor\" href=\"#应用场景-3\">#</a> 应用场景</h2>\n<p><a href=\"https://imgtu.com/i/RH30vd\"><img src=\"https://z3.ax1x.com/2021/07/07/RH30vd.png\" alt=\"RH30vd.png\"></a></p>\n<p>1) 战争时期，胜利乡有 7 个村庄 (A, B, C, D, E, F, G) ，现在有六个邮差，从 G 点出发，需要分别把邮件分别送到 A, B, C , D, E, F 六个村庄</p>\n<p>2) 各个村庄的距离用边线表示 (权) ，比如 A – B 距离 5 公里</p>\n<p>3) 问：如何计算出<strong>各村庄</strong>到 <strong>其它各村庄</strong>的最短距离？</p>\n<h2 id=\"代码展示-7\"><a class=\"markdownIt-Anchor\" href=\"#代码展示-7\">#</a> 代码展示</h2>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> demo10;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Arrays;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//弗洛伊德算法</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FloydAlgorithm</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//测试看看图是否创建成功</span></span><br><span class=\"line\">        <span class=\"keyword\">char</span>[] vertex = &#123;<span class=\"string\">&#x27;A&#x27;</span>, <span class=\"string\">&#x27;B&#x27;</span>, <span class=\"string\">&#x27;C&#x27;</span>, <span class=\"string\">&#x27;D&#x27;</span>, <span class=\"string\">&#x27;E&#x27;</span>, <span class=\"string\">&#x27;F&#x27;</span>, <span class=\"string\">&#x27;G&#x27;</span>&#125;;</span><br><span class=\"line\">        <span class=\"comment\">//创建邻接矩阵</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span>[][] matrix = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[vertex.length][vertex.length];</span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> N = <span class=\"number\">65535</span>;</span><br><span class=\"line\">        matrix[<span class=\"number\">0</span>] = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[]&#123;<span class=\"number\">0</span>, <span class=\"number\">5</span>, <span class=\"number\">7</span>, N, N, N, <span class=\"number\">2</span>&#125;;</span><br><span class=\"line\">        matrix[<span class=\"number\">1</span>] = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[]&#123;<span class=\"number\">5</span>, <span class=\"number\">0</span>, N, <span class=\"number\">9</span>, N, N, <span class=\"number\">3</span>&#125;;</span><br><span class=\"line\">        matrix[<span class=\"number\">2</span>] = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[]&#123;<span class=\"number\">7</span>, N, <span class=\"number\">0</span>, N, <span class=\"number\">8</span>, N, N&#125;;</span><br><span class=\"line\">        matrix[<span class=\"number\">3</span>] = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[]&#123;N, <span class=\"number\">9</span>, N, <span class=\"number\">0</span>, N, <span class=\"number\">4</span>, N&#125;;</span><br><span class=\"line\">        matrix[<span class=\"number\">4</span>] = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[]&#123;N, N, <span class=\"number\">8</span>, N, <span class=\"number\">0</span>, <span class=\"number\">5</span>, <span class=\"number\">4</span>&#125;;</span><br><span class=\"line\">        matrix[<span class=\"number\">5</span>] = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[]&#123;N, N, N, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">0</span>, <span class=\"number\">6</span>&#125;;</span><br><span class=\"line\">        matrix[<span class=\"number\">6</span>] = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[]&#123;<span class=\"number\">2</span>, <span class=\"number\">3</span>, N, N, <span class=\"number\">4</span>, <span class=\"number\">6</span>, <span class=\"number\">0</span>&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//创建一个图对象</span></span><br><span class=\"line\">        Graph graph = <span class=\"keyword\">new</span> Graph(vertex.length, matrix, vertex);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//调用 floyd()</span></span><br><span class=\"line\">        graph.floyd();</span><br><span class=\"line\">        graph.show();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//创建图</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Graph</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">char</span>[] vertex; <span class=\"comment\">//存放顶点数组</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span>[][] dis; <span class=\"comment\">//保存从各个顶点出发到其他顶点的距离，最后结果也保存在该数组中</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span>[][] pre; <span class=\"comment\">//保存到达目标顶点的前驱顶点</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 构造器</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> length 大小</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> matrix 邻接矩阵</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> vertex 顶点数组</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Graph</span><span class=\"params\">(<span class=\"keyword\">int</span> length, <span class=\"keyword\">int</span>[][] matrix, <span class=\"keyword\">char</span>[] vertex)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.vertex = vertex;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.dis = matrix;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.pre = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[length][length];</span><br><span class=\"line\">        <span class=\"comment\">//对pre数组初始化，存放的是前驱顶点的下标</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; length; i++) &#123;</span><br><span class=\"line\">            Arrays.fill(pre[i], i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//显示方法，显示dis数组和pre数组</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">show</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//为了便于查看</span></span><br><span class=\"line\">        <span class=\"keyword\">char</span>[] vertex = &#123;<span class=\"string\">&#x27;A&#x27;</span>, <span class=\"string\">&#x27;B&#x27;</span>, <span class=\"string\">&#x27;C&#x27;</span>, <span class=\"string\">&#x27;D&#x27;</span>, <span class=\"string\">&#x27;E&#x27;</span>, <span class=\"string\">&#x27;F&#x27;</span>, <span class=\"string\">&#x27;G&#x27;</span>&#125;;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> k = <span class=\"number\">0</span>; k &lt; dis.length; k++) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//先将pre数组输出的一行数据</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; dis.length; i++) &#123;</span><br><span class=\"line\">                System.out.print(vertex[pre[k][i]] + <span class=\"string\">&quot; &quot;</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            System.out.println();</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">//输出dis 的一行数据</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; dis.length; i++) &#123;</span><br><span class=\"line\">                System.out.print(<span class=\"string\">&quot;(&quot;</span> + vertex[k] + <span class=\"string\">&quot;到&quot;</span> + vertex[i] + <span class=\"string\">&quot;的最短路径是&quot;</span> + dis[k][i] + <span class=\"string\">&quot;) &quot;</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            System.out.println();</span><br><span class=\"line\">            System.out.println();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//弗洛伊德算法</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">floyd</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> len = <span class=\"number\">0</span>; <span class=\"comment\">//变量保存距离</span></span><br><span class=\"line\">        <span class=\"comment\">//对中间顶点遍历，k就是中间顶点下标</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> k = <span class=\"number\">0</span>; k &lt; dis.length; k++) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//从 i 顶点开始出发 [&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;, &#x27;D&#x27;, &#x27;E&#x27;, &#x27;F&#x27;, &#x27;G&#x27;]</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; dis.length; i++) &#123;</span><br><span class=\"line\">                <span class=\"comment\">//到达终点 j [&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;, &#x27;D&#x27;, &#x27;E&#x27;, &#x27;F&#x27;, &#x27;G&#x27;]</span></span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; dis.length; j++) &#123;</span><br><span class=\"line\">                    len = dis[i][k] + dis[k][j]; <span class=\"comment\">// =&gt; 求出从 i 顶点出发，经过k中间顶点，到达j顶点距离</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (len &lt; dis[i][j]) &#123; <span class=\"comment\">//如果len 小于 dis[i][j]</span></span><br><span class=\"line\">                        dis[i][j] = len; <span class=\"comment\">// 更新距离</span></span><br><span class=\"line\">                        pre[i][j] = pre[k][j]; <span class=\"comment\">//更新前驱顶点</span></span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"10-马踏棋盘算法\"><a class=\"markdownIt-Anchor\" href=\"#10-马踏棋盘算法\">#</a> 10、马踏棋盘算法</h1>\n<h2 id=\"游戏展示\"><a class=\"markdownIt-Anchor\" href=\"#游戏展示\">#</a> 游戏展示</h2>\n<p><strong>马踏棋盘算法介绍和游戏演示</strong></p>\n<p>1) 马踏棋盘算法也被称为骑士周游问题</p>\n<p>2) 将马随机放在国际象棋的 8×8 棋盘 Board [0～7][0～7] 的某个方格中，马按走棋规则 (<strong>马走日字</strong>) 进行移动。要求每个方格只进入一次，走遍棋盘上全部 64 个方格</p>\n<p><a href=\"https://imgtu.com/i/RH8ad0\"><img src=\"https://z3.ax1x.com/2021/07/07/RH8ad0.png\" alt=\"RH8ad0.png\"></a></p>\n<h2 id=\"思路分析-4\"><a class=\"markdownIt-Anchor\" href=\"#思路分析-4\">#</a> 思路分析</h2>\n<p>1) 马踏棋盘问题 (骑士周游问题) 实际上是图的深度优先搜索 (DFS) 的应用。</p>\n<p>2) 如果使用回溯（就是深度优先搜索）来解决，假如马儿踏了 53 个点，如图：走到了第 53 个，坐标（1,0），发现已经走到尽头，没办法，那就只能回退了，查看其他的路径，就在棋盘上不停的回溯…… ，思路分析 + 代码实现</p>\n<p>3) 分析第一种方式的问题，并使用贪心算法（greedyalgorithm）进行优化。解决马踏棋盘问题.</p>\n<p>使用前面的游戏来验证算法是否正确</p>\n<h2 id=\"解决步骤\"><a class=\"markdownIt-Anchor\" href=\"#解决步骤\">#</a> 解决步骤</h2>\n<ol>\n<li>创建棋盘 chessBoard , 是一个二维数组</li>\n<li>将当前位置设置为已经访问，然后根据当前位置，计算马儿还能走哪些位置，并放入到一个集合中 (ArrayList), 最多有 8 个位置， 每走一步，就使用 step+1</li>\n<li>遍历 ArrayList 中存放的所有位置，看看哪个可以走通，如果走通，就继续，走不通，就<strong>回溯</strong>.</li>\n<li>判断马儿是否完成了任务，使用   step 和应该走的步数比较 ， 如果没有达到数量，则表示没有完成任务，将整个棋盘置 0</li>\n</ol>\n<p><strong>注意：马儿不同的走法（策略），会得到不同的结果，效率也会有影响 (优化)</strong></p>\n<figure class=\"highlight tex\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//创建一个Point</span><br><span class=\"line\">Point p1 = new Point();</span><br><span class=\"line\">if((p1.x = curPoint.x - 2) &gt;= 0 <span class=\"built_in\">&amp;</span><span class=\"built_in\">&amp;</span> (p1.y = curPoint.y -1) &gt;= 0) &#123;</span><br><span class=\"line\">\tps.add(new Point(p1));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>使用贪心算法对原来的算法优化</strong></p>\n<figure class=\"highlight tex\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1. 我们获取当前位置，可以走的下一个位置的集合</span><br><span class=\"line\">//获取当前位置可以走的下一个位置的集合 </span><br><span class=\"line\">ArrayList&lt;Point&gt; ps = next(new Point(column, row));</span><br><span class=\"line\">2. 我们需要对 ps 中所有的Point 的下一步的所有集合的数目，进行非递减排序,就ok ,  </span><br><span class=\"line\">\t9, 7, 6, 5, 3, 2, 1 //递减排序</span><br><span class=\"line\">\t1, 2, 3, 4, 5, 6, 10, //递增排序</span><br><span class=\"line\"></span><br><span class=\"line\">\t1, 2, 2, 2, 3, 3, 4, 5, 6 // 非递减  递增，但有重复数</span><br><span class=\"line\">\t9, 7, 6, 6, 6, 5, 5, 3, 2, 1  //非递增  递减，但有重复数</span><br></pre></td></tr></table></figure>\n<h2 id=\"代码展示-8\"><a class=\"markdownIt-Anchor\" href=\"#代码展示-8\">#</a> 代码展示</h2>\n<p><a href=\"https://imgtu.com/i/RH8ad0\"><img src=\"https://z3.ax1x.com/2021/07/07/RH8ad0.png\" alt=\"RH8ad0.png\"></a></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> demo11;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.awt.*;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.ArrayList;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Comparator;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HorseChessborad</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> X; <span class=\"comment\">//表示棋盘的列数</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> Y; <span class=\"comment\">//表示棋盘的行数</span></span><br><span class=\"line\">    <span class=\"comment\">//创建一个数组，标记棋盘的各个位置是否被访问过</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">boolean</span>[] visited;</span><br><span class=\"line\">    <span class=\"comment\">//使用一个属性标记是否棋盘的所有位置都被标记</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">boolean</span> finished; <span class=\"comment\">//如果为true,表示成功</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;骑士周游算法，开始执行~~&quot;</span>);</span><br><span class=\"line\">        <span class=\"comment\">//测试骑士周游算法是否正确</span></span><br><span class=\"line\">        X=<span class=\"number\">8</span>;</span><br><span class=\"line\">        Y=<span class=\"number\">8</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> row=<span class=\"number\">1</span>; <span class=\"comment\">//马儿初始位置的行，从1开始编号</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> column=<span class=\"number\">1</span>; <span class=\"comment\">//马儿初始位置的列，从1开始编号</span></span><br><span class=\"line\">        <span class=\"comment\">//创建棋盘</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span>[][] chessboard=<span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[X][Y];</span><br><span class=\"line\">        visited=<span class=\"keyword\">new</span> <span class=\"keyword\">boolean</span>[X*Y];<span class=\"comment\">// 初始值都是false</span></span><br><span class=\"line\">        <span class=\"comment\">//测试耗时</span></span><br><span class=\"line\">        <span class=\"keyword\">long</span> start = System.currentTimeMillis();</span><br><span class=\"line\">        traversalChessboard(chessboard,row-<span class=\"number\">1</span>,column-<span class=\"number\">1</span>,<span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"keyword\">long</span> end = System.currentTimeMillis();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;共耗时：&quot;</span>+(end-start)+<span class=\"string\">&quot;毫秒&quot;</span>);</span><br><span class=\"line\">        <span class=\"comment\">//输出棋盘的最后情况</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span>[] rows:chessboard)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> step:rows)&#123;</span><br><span class=\"line\">                System.out.print(step+<span class=\"string\">&quot;\\t&quot;</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            System.out.println();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 完成骑士周游问题的算法</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> chessboard 棋盘</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> row        马儿当前的位置的行 从0开始</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> column     马儿当前的位置的列 从0开始</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> step       是第几步，初始位置就是第一步</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">traversalChessboard</span><span class=\"params\">(<span class=\"keyword\">int</span>[][] chessboard, <span class=\"keyword\">int</span> row, <span class=\"keyword\">int</span> column, <span class=\"keyword\">int</span> step)</span> </span>&#123;</span><br><span class=\"line\">        chessboard[row][column] = step;</span><br><span class=\"line\">        <span class=\"comment\">//标记该位置已访问</span></span><br><span class=\"line\">        visited[row * X + column] = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        <span class=\"comment\">//获取当前位置可以走的下一个位置的集合</span></span><br><span class=\"line\">        ArrayList&lt;Point&gt; points = next(<span class=\"keyword\">new</span> Point(column, row));</span><br><span class=\"line\">        <span class=\"comment\">//对points进行排序，排序的规则就是对points的所有的Point对象的下一步的位置的数目，进行非递减排序</span></span><br><span class=\"line\">        <span class=\"comment\">//优化方法</span></span><br><span class=\"line\">        sort(points);</span><br><span class=\"line\">        <span class=\"comment\">//遍历points</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!points.isEmpty()) &#123;</span><br><span class=\"line\">            Point p = points.remove(<span class=\"number\">0</span>);<span class=\"comment\">//取出下一个可以走的位置</span></span><br><span class=\"line\">            <span class=\"comment\">//判断该点是否已经访问过</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!visited[p.y * X + p.x]) &#123;<span class=\"comment\">//说明还没有访问过</span></span><br><span class=\"line\">                traversalChessboard(chessboard, p.y, p.x, step + <span class=\"number\">1</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//判断马儿是否完成任务，使用 step 和应该走的步数比较</span></span><br><span class=\"line\">        <span class=\"comment\">//如果没有达到数量，则表示没有完成任务，将整个棋盘置 0</span></span><br><span class=\"line\">        <span class=\"comment\">//说明</span></span><br><span class=\"line\">        <span class=\"comment\">//step &lt; X * Y 成立的情况有两种</span></span><br><span class=\"line\">        <span class=\"comment\">//1. 棋盘到目前位置，仍然没有走完</span></span><br><span class=\"line\">        <span class=\"comment\">//2. 棋盘处于一个回溯过程</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (step &lt; X * Y &amp;&amp; !finished) &#123;</span><br><span class=\"line\">            chessboard[row][column] = <span class=\"number\">0</span>;</span><br><span class=\"line\">            visited[row * X + column] = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            finished=<span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 功能：根据当前位置（Point），计算马儿还能走哪些位置（Point），并放入到一个集合中（ArrayList），最多有8个位置</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> curPoint</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ArrayList&lt;Point&gt; <span class=\"title\">next</span><span class=\"params\">(Point curPoint)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//创建一个ArrayList</span></span><br><span class=\"line\">        ArrayList&lt;Point&gt; points = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">        <span class=\"comment\">//创建一个Point</span></span><br><span class=\"line\">        Point p1 = <span class=\"keyword\">new</span> Point();</span><br><span class=\"line\">        <span class=\"comment\">//判断马儿能走5的位置（根据上文展示的图判断）</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((p1.x = curPoint.x - <span class=\"number\">2</span>) &gt;= <span class=\"number\">0</span> &amp;&amp; (p1.y = curPoint.y - <span class=\"number\">1</span>) &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            points.add(<span class=\"keyword\">new</span> Point(p1));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//判断马儿能走6的位置（根据上文展示的图判断）</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((p1.x = curPoint.x - <span class=\"number\">1</span>) &gt;= <span class=\"number\">0</span> &amp;&amp; (p1.y = curPoint.y - <span class=\"number\">2</span>) &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            points.add(<span class=\"keyword\">new</span> Point(p1));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//判断马儿能走7的位置（根据上文展示的图判断）</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((p1.x = curPoint.x + <span class=\"number\">1</span>) &lt; X &amp;&amp; (p1.y = curPoint.y - <span class=\"number\">2</span>) &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            points.add(<span class=\"keyword\">new</span> Point(p1));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//判断马儿能走0的位置（根据上文展示的图判断）</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((p1.x = curPoint.x + <span class=\"number\">2</span>) &lt; X &amp;&amp; (p1.y = curPoint.y - <span class=\"number\">1</span>) &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            points.add(<span class=\"keyword\">new</span> Point(p1));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//判断马儿能走1的位置（根据上文展示的图判断）</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((p1.x = curPoint.x + <span class=\"number\">2</span>) &lt; X &amp;&amp; (p1.y = curPoint.y + <span class=\"number\">1</span>) &lt; Y) &#123;</span><br><span class=\"line\">            points.add(<span class=\"keyword\">new</span> Point(p1));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//判断马儿能走2的位置（根据上文展示的图判断）</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((p1.x = curPoint.x + <span class=\"number\">1</span>) &lt; X &amp;&amp; (p1.y = curPoint.y + <span class=\"number\">2</span>) &lt; Y) &#123;</span><br><span class=\"line\">            points.add(<span class=\"keyword\">new</span> Point(p1));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//判断马儿能走3的位置（根据上文展示的图判断）</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((p1.x = curPoint.x - <span class=\"number\">1</span>) &gt;= <span class=\"number\">0</span> &amp;&amp; (p1.y = curPoint.y + <span class=\"number\">2</span>) &lt; Y) &#123;</span><br><span class=\"line\">            points.add(<span class=\"keyword\">new</span> Point(p1));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//判断马儿能走4的位置（根据上文展示的图判断）</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((p1.x = curPoint.x - <span class=\"number\">2</span>) &gt;= <span class=\"number\">0</span> &amp;&amp; (p1.y = curPoint.y + <span class=\"number\">1</span>) &lt; Y) &#123;</span><br><span class=\"line\">            points.add(<span class=\"keyword\">new</span> Point(p1));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> points;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//优化</span></span><br><span class=\"line\">    <span class=\"comment\">//根据当前这一步的所有的下一步的选择位置，进行非递减排序,减少回溯的可能</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">sort</span><span class=\"params\">(ArrayList&lt;Point&gt; points)</span></span>&#123;</span><br><span class=\"line\">        points.sort(<span class=\"keyword\">new</span> Comparator&lt;Point&gt;() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">compare</span><span class=\"params\">(Point o1, Point o2)</span> </span>&#123;</span><br><span class=\"line\">                <span class=\"comment\">//获取到o1点的下一步的所有的位置个数</span></span><br><span class=\"line\">                <span class=\"keyword\">int</span> count1 = next(o1).size();</span><br><span class=\"line\">                <span class=\"comment\">//获取到o2点的下一步的所有的位置个数</span></span><br><span class=\"line\">                <span class=\"keyword\">int</span> count2 = next(o2).size();</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (count1&lt;count2)&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">                &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (count1==count2)&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">                &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n",
            "tags": [
                "算法与数据结构",
                "二分查找算法",
                "分治算法",
                "动态规划算法",
                "KMP算法",
                "贪心算法",
                "普利姆算法",
                "克鲁斯卡尔算法",
                "迪杰斯特拉算法",
                "弗洛伊德算法",
                "马踏棋盘算法"
            ]
        }
    ]
}